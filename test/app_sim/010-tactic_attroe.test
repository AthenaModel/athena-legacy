# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    010-tactic_attroe.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    tactic_attroe(sim) tests.
#
#    This test suite tests the tactic_attroe(sim) class.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Set up for tests

    proc setup {} {
        variable T1
        variable T2
        variable coffer

        ted create JOE BOB NB1 NB2 BLUE BRIT TAL ALQ

        # set attack cost to 1 dollar
        rdb eval {UPDATE frcgroups SET attack_cost = 1000.0}

        cash load
        personnel start
        personnel load
        set coffer [coffer new JOE]

        set B1 [ted addblock JOE]
        set T1 [ted addtactic $B1 ATTROE]

        set B2 [ted addblock BOB]
        set T2 [ted addtactic $B2 ATTROE]
    }

    # Clean up after a test

    proc cleanup {} {
        variable coffer
        $coffer destroy
        ted cleanup
    }

    #-------------------------------------------------------------------
    # tactic::ATTROE reset

    test reset-1.1 {clears ROE table} -setup {
        setup
        rdb eval {
            INSERT INTO attroe_nfg(n,f,g) 
            VALUES('NB1','BLUE','TAL')
        }
    } -body {
        tactic::ATTROE reset
        rdb onecolumn {SELECT count(n) FROM attroe_nfg}
    } -cleanup {
        cleanup
    } -result {0}

    #-------------------------------------------------------------------
    # tactic::ATTROE refund

    # TBD    

    #-------------------------------------------------------------------
    # Constructor

    test constructor-1.1 {default state} -setup {
        setup
    } -body {
        ted pdicts [$T1 getdict]
    } -cleanup {
        cleanup
    } -match dictglob -result {
        attacks    1
        execstatus NONE
        f          {}
        faildict   {}
        g          {}
        id         5
        n          {}
        parent     ::bean::block4
        roe        DO_NOT_ATTACK
        state      invalid
    }

    test constructor-1.2 {can set options} -setup {
        setup
    } -body {
        set T1 [tactic::ATTROE new -parent DUMMY]
        $T1 get parent
    } -cleanup {
        cleanup
    } -result {DUMMY}
    

    #-------------------------------------------------------------------
    # narrative

    test narrative-1.1 {narrative, default state} -setup {
        setup
    } -body {
        $T1 narrative
    } -cleanup {
        cleanup
    } -result {Group ??? will not attack ??? in ???.}

    test narrative-1.2 {narrative, ATTACK} -setup {
        setup
        $T1 configure -f BLUE -g TAL -n NB1 -roe ATTACK -attacks 1
    } -body {
        $T1 narrative
    } -cleanup {
        cleanup
    } -result {Group {group:BLUE} attacks {group:TAL} in {nbhood:NB1} up to 1 time/week.}

    test narrative-1.3 {narrative, HIT_AND_RUN, multiple} -setup {
        setup
        $T1 configure -f TAL -g BLUE -n NB1 -roe HIT_AND_RUN -attacks 5
    } -body {
        $T1 narrative
    } -cleanup {
        cleanup
    } -result {Group {group:TAL} attacks {group:BLUE} in {nbhood:NB1} with ROE HIT_AND_RUN up to 5 times/week.}

    #-------------------------------------------------------------------
    # check

    test check-1.1 {Initial state fails} -setup {
        setup
    } -body {
        ted pdict [$T1 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        f {No group selected.}
        g {No group selected.}
        n {No neighborhood selected.}
    }

    test check-1.2 {f not owned by actor} -setup {
        setup
        $T1 configure -f NONESUCH -g TAL -n NB1
    } -body {
        ted pdict [$T1 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        f {JOE does not own a force group called "NONESUCH".}
    }

    test check-1.3 {invalid g} -setup {
        setup
    } -body {
        $T1 configure -f BLUE -g NONESUCH -n NB1
        ted pdict [$T1 check]
    } -cleanup {
        cleanup
    } -match dictglob -result {
        g {Invalid force group, should be one of: *}
    }

    test check-1.4 {f and g both uniformed} -setup {
        setup
        $T1 configure -f BLUE -g BRIT -n NB1
    } -body {
        ted pdict [$T1 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        g {Groups "BLUE" and "BRIT" are both uniformed.}
    }

    test check-1.5 {f and g both non-uniformed} -setup {
        setup
        $T2 configure -f TAL -g ALQ -n NB1
    } -body {
        ted pdict [$T2 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        g {Groups "TAL" and "ALQ" are both non-uniformed.}
    }

    test check-1.6 {invalid ROE, uniformed} -setup {
        setup
        $T1 configure -f BLUE -g ALQ -n NB1 -roe HIT_AND_RUN
    } -body {
        ted pdict [$T1 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        roe {ROE is invalid for a uniformed group: "HIT_AND_RUN".}
    }

    test check-1.7 {invalid ROE, non-uniformed} -setup {
        setup
        $T2 configure -f TAL -g BRIT -n NB1 -roe ATTACK
    } -body {
        ted pdict [$T2 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        roe {ROE is invalid for a non-uniformed group: "ATTACK".}
    }

    test check-1.8 {n does not exist} -setup {
        setup
        $T1 configure -f BLUE -g TAL -n NONESUCH
    } -body {
        ted pdict [$T1 check]
    } -cleanup {
        cleanup
    } -match dict -result {
        n {No such neighborhood: "NONESUCH".}
    }


    test check-2.1 {Success} -setup {
        setup
        $T1 configure -f BLUE -g TAL -n NB1 -roe ATTACK
    } -body {
        $T1 check
    } -cleanup {
        cleanup
    } -result {}

    #-------------------------------------------------------------------
    # obligate

    test obligate-1.1 {DO_NOT_ATTACK always succeeds.} -setup {
        setup
        $T1 configure -f BLUE -g TAL -roe DO_NOT_ATTACK -attacks 100
    } -body {
        list \
            [$coffer cash]         \
            [$T1 obligate $coffer] \
            [$coffer cash]
    } -cleanup {
        cleanup
    } -result {10000.0 1 10000.0}

    test obligate-1.2 {ATTACK fails on insufficient cash.} -setup {
        setup
        $T1 configure -f BLUE -g TAL -roe ATTACK -attacks 100
    } -body {
        $T1 obligate $coffer
        $T1 faildict
    } -cleanup {
        cleanup
    } -result {CASH {Required $100,000, but had only $10,000.}}

    test obligate-1.3 {ATTACK succeeds with sufficient cash.} -setup {
        setup
        $T1 configure -f BLUE -g TAL -roe ATTACK -attacks 4
    } -body {
        list \
            [$coffer cash]         \
            [$T1 obligate $coffer] \
            [$coffer cash]
    } -cleanup {
        cleanup
    } -result {10000.0 1 6000.0}

    #-------------------------------------------------------------------
    # execute

    test execute-1.1 {sets ROE} -setup {
        setup
        $T1 configure -f BLUE -g TAL -n NB1 -roe ATTACK
        $T1 obligate $coffer
    } -body {
        $T1 execute
        ted query {SELECT * FROM attroe_nfg}
    } -cleanup {
        cleanup
    } -result {
n   f    g   uniformed roe    max_attacks attacks 
--- ---- --- --------- ------ ----------- ------- 
NB1 BLUE TAL 1         ATTACK 1           0       
    }

    test execute-1.2 {expends cash} -setup {
        setup
        $T1 configure -f BLUE -g TAL -n NB1 -roe ATTACK -attacks 4
        $T1 obligate $coffer
    } -body {
        $T1 execute
        rdb onecolumn {SELECT cash_on_hand FROM working_cash WHERE a='JOE'}
    } -cleanup {
        cleanup
    } -result {6000.0}

    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::athena_test::tests::








