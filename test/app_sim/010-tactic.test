# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    010-tactic.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    tactic(sim) tests.
#
#    This test suite tests the tactic(sim) mutators and queries
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Set up for tests

    proc setup {} {
        ted create JOE BOB NB1 NB2 BLUE BRIT

        # Verify that unused columns contain NULL
        rdb nullvalue "@"
    }

    # Clean up after a test

    proc cleanup {} {
        # Clean up the test environment
        rdb nullvalue ""
        array unset parms
        ted cleanup
    }

    # Dump priorities
    proc dumpPriority {} {
        return [ted query {
            SELECT tactic_id,tactic_type,owner,priority
            FROM tactics ORDER BY priority
        }]
    }

    proc mkupdate {tactic_id parms} {
        dict set parms tactic_id $tactic_id
        return $parms
    }

    # Standard Tactics
    
    set T1 {
        tactic_type DEPOSIT
        owner       JOE
        priority    top
        amount      10
        once        0
    }

    set T2 {
        tactic_type DEFROE
        owner       JOE
        priority    top
        n           NB1
        g           BLUE
        text1       HOLD_FIRE
    }

    set T3 {
        tactic_type DEFROE
        owner       JOE
        priority    top
        once        1
        n           NB2
        g           BRIT
        text1       HOLD_FIRE
    }

    #-------------------------------------------------------------------
    # mutate create

    test create-1.1 {tactic is created: once is omitted} -setup {
        setup
    } -body {
        tactic mutate create $T1
        ted querylist {SELECT * FROM tactics}
    } -cleanup {
        cleanup
    } -result {
tactic_id    1
tactic_type  DEPOSIT
owner        JOE
narrative    Deposit $10.00 to the cash reserve.
priority     1
once         0
on_lock      0
state        normal
exec_ts      @
exec_flag    0
pdict        amount 10
    }

    test create-1.2 {tactic is created: once=1} -setup {
        setup
    } -body {
        tactic mutate create $T3
        ted querylist {SELECT * FROM tactics}
    } -cleanup {
        cleanup
    } -result {
tactic_id    1
tactic_type  DEFROE
owner        JOE
narrative    Group BRIT defends in NB2 with ROE HOLD_FIRE
priority     1
once         1
on_lock      0
state        normal
exec_ts      @
exec_flag    0
pdict        n NB2 g BRIT text1 HOLD_FIRE
    }

    test create-1.3 {priority is set} -setup {
        setup
    } -body {
        tactic mutate create $T1
        tactic mutate create $T2

        # T2 should appear before T1
        dumpPriority
    } -cleanup {
        cleanup
    } -result {
tactic_id tactic_type owner priority 
--------- ----------- ----- -------- 
2         DEFROE      JOE   1        
1         DEPOSIT     JOE   2        
    }

    test create-1.4 {priority defaults to bottom if unset} -setup {
        setup
    } -body {
        tactic mutate create [dict merge $T1 {priority ""}]
        tactic mutate create [dict merge $T2 {priority ""}]

        dumpPriority
    } -cleanup {
        cleanup
    } -result {
tactic_id tactic_type owner priority 
--------- ----------- ----- -------- 
1         DEPOSIT     JOE   1        
2         DEFROE      JOE   2        
    }



    test create-2.1 {undo deletes the tactic} -setup {
        setup
        set undo [tactic mutate create $T1]
    } -body {
        namespace eval :: $undo
        rdb eval {SELECT * FROM tactics}
    } -cleanup {
        cleanup
    } -result {}

    test create-2.2 {undo resets priorities} -setup {
        setup
        tactic mutate create $T1
        set undo [tactic mutate create $T2]
    } -body {
        namespace eval :: $undo
        dumpPriority
    } -cleanup {
        cleanup
    } -result {
tactic_id tactic_type owner priority 
--------- ----------- ----- -------- 
1         DEPOSIT     JOE   1        
    }

    test create-3.1 {tactic type must match agent type} -setup {
        setup
    } -body {
        tactic mutate create [dict merge $T1 {owner SYSTEM}]
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Agent SYSTEM cannot own DEPOSIT tactics}

    #-------------------------------------------------------------------
    # mutate delete

    test delete-1.1 {Tactic is deleted} -setup {
        setup
        tactic mutate create $T1
        tactic mutate create $T2
    } -body {
        tactic mutate delete 1

        rdb eval {SELECT tactic_id FROM tactics}
    } -cleanup {
        cleanup
    } -result {2}

    test delete-2.1 {Undo restores tactic} -setup {
        setup
        tactic mutate create $T1
        tactic mutate create $T2
        set undo [tactic mutate delete 2]
    } -body {
        namespace eval :: $undo
        ted querylist {SELECT * FROM tactics ORDER BY priority}
    } -cleanup {
        cleanup
    } -result {
tactic_id    2
tactic_type  DEFROE
owner        JOE
narrative    Group BLUE defends in NB1 with ROE HOLD_FIRE
priority     1
once         0
on_lock      0
state        normal
exec_ts      @
exec_flag    0
pdict        n NB1 g BLUE text1 HOLD_FIRE

tactic_id    1
tactic_type  DEPOSIT
owner        JOE
narrative    Deposit $10.00 to the cash reserve.
priority     2
once         0
on_lock      0
state        normal
exec_ts      @
exec_flag    0
pdict        amount 10
    }

    test delete-3.1 {Condition is deleted} -setup {
        setup
        tactic mutate create $T1
        ted order CONDITION:CASH:CREATE cc_id 1 a JOE op1 LT x1 500
    } -body {
        tactic mutate delete 1

        rdb eval {SELECT condition_id FROM conditions}
    } -cleanup {
        cleanup
    } -result {}

    test delete-3.2 {Condition is restored on undo} -setup {
        setup
        tactic mutate create $T1
        ted order CONDITION:CASH:CREATE cc_id 1 a JOE op1 LT x1 500

        set undo [tactic mutate delete 1]
    } -body {
        namespace eval :: $undo
        rdb eval {SELECT condition_id FROM conditions}
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # mutate update

    test update-1.1 {tactic is updated} -setup {
        setup
        tactic mutate create $T2
    } -body {
        tactic mutate update [mkupdate 1 {
            text1      FIRE_BACK_IMMEDIATELY
            once       1
        }]

        # This verifies both that requested changes are made, and
        # that NULL columns remain NULL.
        ted querylist {SELECT * FROM tactics}
    } -cleanup {
        cleanup
    } -result {
tactic_id    1
tactic_type  DEFROE
owner        JOE
narrative    Group BLUE defends in NB1 with ROE FIRE_BACK_IMMEDIATELY
priority     1
once         1
on_lock      0
state        normal
exec_ts      @
exec_flag    0
pdict        n NB1 g BLUE text1 FIRE_BACK_IMMEDIATELY
    }

    test update-1.2 {empty values are OK} -setup {
        setup
        tactic mutate create $T2
    } -body {
        set a [ted query {SELECT * FROM tactics}]

        tactic mutate update [mkupdate 1 {}]

        set b [ted query {SELECT * FROM tactics}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test update-1.3 {exec_* cleared on update} -setup {
        setup
        tactic mutate create $T2
        rdb eval { 
            UPDATE tactics 
            SET exec_ts = 10,
                exec_flag = 1
        }
    } -body {
        tactic mutate update [mkupdate 1 {
            text1      FIRE_BACK_IMMEDIATELY
            once       1
        }]

        # This verifies both that requested changes are made, and
        # that NULL columns remain NULL.
        rdb eval {SELECT tactic_id, exec_ts, exec_flag FROM tactics}
    } -cleanup {
        cleanup
    } -result {1 @ 0}

    test update-2.1 {undo undoes the change} -setup {
        setup
        tactic mutate create $T2
    } -body {

        set a [ted query {SELECT * FROM tactics}]

        set undo [tactic mutate update [mkupdate 1 {
            roe          FIRE_BACK_IMMEDIATELY
            once         1
            n            NB2
            g            BRIT
        }]]

        namespace eval :: $undo

        set b [ted query {SELECT * FROM tactics}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}

    #-------------------------------------------------------------------
    # mutate state

    test state-1.1 {tactic state is changed} -setup {
        setup
        tactic mutate create $T2
    } -body {
        tactic mutate state 1 disabled

        # This verifies both that requested changes are made, and
        # that NULL columns remain NULL.
        ted query {SELECT tactic_id,state FROM tactics}
    } -cleanup {
        cleanup
    } -result {
tactic_id state    
--------- -------- 
1         disabled 
    }


    test state-2.1 {undo undoes the change} -setup {
        setup
        tactic mutate create $T2
    } -body {

        set a [ted query {SELECT * FROM tactics}]

        set undo [tactic mutate state 1 disabled]

        namespace eval :: $undo

        set b [ted query {SELECT * FROM tactics}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}

    #-------------------------------------------------------------------
    # mutate priority

    proc setup_priority {} {
        variable T1
        variable T2
        variable T3
        setup

        # Create tactics with IDs 1, 2, and 3 such that the
        # priority ordering is 1, 2, 3, to make changes easier
        # to interpret.
        tactic mutate create [dict merge $T1 {priority bottom}]
        tactic mutate create [dict merge $T2 {priority bottom}]
        tactic mutate create [dict merge $T3 {priority bottom}]
    }

    test priority-1.1 {item gets first priority} -setup {
        setup_priority
    } -body {
        tactic mutate priority 3 top
        
        rdb eval {SELECT tactic_id FROM tactics ORDER BY priority}
    } -cleanup {
        cleanup
    } -result {3 1 2}


    test priority-1.2 {item priority is raised} -setup {
        setup_priority
    } -body {
        tactic mutate priority 3 raise
        
        rdb eval {SELECT tactic_id FROM tactics ORDER BY priority}
    } -cleanup {
        cleanup
    } -result {1 3 2}

    test priority-1.3 {item priority is lowered} -setup {
        setup_priority
    } -body {
        tactic mutate priority 1 lower
        
        rdb eval {SELECT tactic_id FROM tactics ORDER BY priority}
    } -cleanup {
        cleanup
    } -result {2 1 3}

    test priority-1.4 {item gets last priority} -setup {
        setup_priority
    } -body {
        tactic mutate priority 1 bottom
        
        rdb eval {SELECT tactic_id FROM tactics ORDER BY priority}
    } -cleanup {
        cleanup
    } -result {2 3 1}

    test priority-2.1 {undo undoes the change.} -setup {
        setup_priority
    } -body {
        set a [rdb eval {SELECT tactic_id FROM tactics ORDER BY priority}]

        set undo [tactic mutate priority 1 bottom]

        namespace eval :: $undo

        set b [rdb eval {SELECT tactic_id FROM tactics ORDER BY priority}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # names

    test names-1.1 {Returns names: none defined} -body {
        tactic names
    } -cleanup {
        cleanup
    } -result {}

    test names-1.2 {Returns names} -setup {
        setup
        tactic mutate create $T1
        tactic mutate create $T2
        tactic mutate create $T3
    } -body {
        tactic names
    } -cleanup {
        cleanup
    } -result {1 2 3}


    #-------------------------------------------------------------------
    # validate

    test validate-1.1 {Invalid ID: none defined} -body {
        tactic validate NONESUCH
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Invalid tactic ID: "NONESUCH"}

    test validate-2.1 {Valid name} -setup {
        setup
        tactic mutate create $T1
    } -body {
        tactic validate 1
    } -cleanup {
        cleanup
    } -result {1}

    #-------------------------------------------------------------------
    # get

    proc setup_get {} {
        variable T2
        setup
        tactic mutate create $T2
    }

    test get-1.1 {get tactic dict} -setup {
        setup_get
    } -body {
        ted pdict [tactic get 1]
    } -cleanup {
        cleanup
    } -result {
        state       normal
        exec_ts     @
        narrative   {Group BLUE defends in NB1 with ROE HOLD_FIRE}
        once        0
        tactic_type DEFROE
        priority    1
        owner       JOE
        tactic_id   1
        pdict       {n NB1 g BLUE text1 HOLD_FIRE}
        on_lock     0
        exec_flag   0
        n           NB1
        g           BLUE
        text1       HOLD_FIRE
    }

    test get-1.2 {get parameter} -setup {
        setup_get
    } -body {
        tactic get 1 owner
    } -cleanup {
        cleanup
    } -result {JOE}

    #-------------------------------------------------------------------
    # execute

    test execute-2.1 {once=1, tactic is disabled} -setup {
        setup
        tactic mutate create $T3
    } -body {
        tactic execute [tactic get 1]
        ted query {SELECT tactic_id, state FROM tactics}
    } -cleanup {
        cleanup
    } -result {
tactic_id state    
--------- -------- 
1         disabled 
    }

    test execute-2.2 {once=0, tactic is normal} -setup {
        setup
        tactic mutate create $T2
    } -body {
        tactic execute [tactic get 1]
        ted query {SELECT tactic_id, state FROM tactics}
    } -cleanup {
        cleanup
    } -result {
tactic_id state  
--------- ------ 
1         normal 
    }


    #-------------------------------------------------------------------
    # tempschema
    
    test tempschema-1.1 {temp view defined} -setup {
        setup
        tactic mutate create $T1
    } -body {
        ted querylist {SELECT * FROM tactics_DEPOSIT}
    } -cleanup {
        cleanup
    } -result {
tactic_id    1
tactic_type  DEPOSIT
owner        JOE
narrative    Deposit $10.00 to the cash reserve.
priority     1
amount       10
state        normal
exec_ts      @
exec_flag    0
    }
    
    #-------------------------------------------------------------------
    # delta
    
    test delta-1.1 {retrieve data} -setup {
        setup
        tactic mutate create $T1
    } -body {
        set p(tactic_id) 1
        set p(amount)    ""
        tactic delta p
        ted pdict [array get p]
    } -cleanup {
        cleanup
    } -result {
        amount    10
        tactic_id 1
        owner     JOE
    }

    #-------------------------------------------------------------------
    # rebase


    test rebase-1.1 {rebase occurs properly} -setup {
        ted create JOE BLUE BRIT SHIA

        # Create a tactic that has:
        # * the on_lock parameter
        # * that will execute each tock
        ted order TACTIC:DEPLOY:CREATE \
            owner JOE g BLUE text1 ALL nlist NB1 on_lock 1

        # Create a tactic that has:
        # * the on_lock parameter
        # * that will not execute without it (due to false condition)
        ted order TACTIC:ASSIGN:CREATE \
            owner JOE g BLUE n NB1 text1 PATROL int1 5 on_lock 1
        ted order CONDITION:EXPR:CREATE \
            cc_id 2 text1 0

        # Create a tactic that:
        # * does not have the on_lock parameter
        # * that will execute each tock
        ted order TACTIC:DEFROE:CREATE \
            owner JOE g BLUE n NB1 text1 HOLD_FIRE

        ted lock
        ted step
    } -body {
        tactic rebase

        # The following things should be true at this time:
        #
        # * tactics executed in the last go round get on_lock=1 if they
        #   support on_lock.
        #
        # * tactics executed in the last go round get on_lock=0 if they do not
        #   support on_lock.
        #
        # * tactics not executed in the last go round get on_lock=0
        #
        # * exec_flag = 0 for all tactics
        #
        # * exec_ts is NULL for all tactics. 
        #
        # Note, then, only tactic 1 should have its on_lock flag set.

        ted query {
            SELECT tactic_id, tactic_type, on_lock, exec_ts, exec_flag
            FROM tactics
        }
    } -cleanup {
        cleanup
    } -result {
tactic_id tactic_type on_lock exec_ts exec_flag 
--------- ----------- ------- ------- --------- 
1         DEPLOY      1               0         
2         ASSIGN      0               0         
3         DEFROE      0               0         
    }
    
    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::athena_test::tests::







