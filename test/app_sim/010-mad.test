# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    010-mad.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    mad(sim) tests.
#
#    This test suite tests the mad(sim) mutators and queries
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Standard MADs

    set m1 {
        narrative "The First MAD" 
        cause     UNIQUE
        s         1.0
        p         1.0
        q         0.9
    }

    set m2 {
        narrative "The Second MAD"
        cause     CIVCAS
        s         0.9
        p         0.8
        q         0.7
    }

    set m3 {
        narrative "The Third MAD"
        cause     PATROL
        s         0.7
        p         0.6
        q         0.5
    }



    # Lock scenario during setup
    
    proc lock {} {
        ted create JOE NB1 BLUE USAID SHIA
        ted lock
        
        # Delete existing drivers, to make things simpler
        rdb eval {DELETE FROM drivers}
        rdb eval {DELETE FROM rule_firings}
        rdb eval {DELETE FROM rule_inputs}
    }

    # Clean up after a test

    proc cleanup {} {
        # Clean up the test environment
        ted cleanup
    }

    # empty g
    #
    # Makes g an empty group.

    proc empty {g} {
        rdb eval {UPDATE demog_g SET population=0 WHERE g=$g}
    }

    # Do an initial clean-up; this will remove the Adjustments
    # MAD.
    cleanup

    #-------------------------------------------------------------------
    # mutate create

    test create-1.1 {MADs are created} -setup {
        ted create NB1 BLUE USAID SHIA 
    } -body {
        mad mutate create $m1
        mad mutate create $m2
        mad mutate create $m3

        ted query {SELECT * FROM mads}
    } -cleanup {
        cleanup
    } -result {
driver_id dtype narrative      cause  s   p   q   
--------- ----- -------------- ------ --- --- --- 
1000      MAGIC The First MAD  UNIQUE 1.0 1.0 0.9 
1001      MAGIC The Second MAD CIVCAS 0.9 0.8 0.7 
1002      MAGIC The Third MAD  PATROL 0.7 0.6 0.5 
    }


    test create-2.1 {undo deletes the mad} -setup {
        mad mutate create $m1
        set undo [mad mutate create $m2]
    } -body {
        eval $undo
        rdb eval {SELECT driver_id FROM mads}
    } -cleanup {
        cleanup
    } -result {1000}


    test create-2.2 {undo deletes the driver} -setup {
        set undo [mad mutate create $m1]
        set driver_id [rdb onecolumn {
            SELECT driver_id FROM mads WHERE narrative='First MAD'
        }]
    } -body {
        eval $undo
        rdb exists {SELECT * FROM drivers WHERE driver_id=$driver_id}
    } -cleanup {
        cleanup
    } -result {0}


    #-------------------------------------------------------------------
    # mutate delete

    test delete-1.1 {MAD is deleted} -setup {
        mad mutate create $m1   ;# 1000
        mad mutate create $m2   ;# 1001
    } -body {
        mad mutate delete 1000

        # Is 1000 gone?
        rdb eval {SELECT driver_id FROM mads}
    } -cleanup {
        cleanup
    } -result {1001}


    test delete-1.2 {driver is deleted} -setup {
        mad mutate create $m1   ;# 1000
        mad mutate create $m2   ;# 1001
    } -body {
        mad mutate delete 1000

        # Is 1000 gone?
        rdb eval {SELECT driver_id FROM drivers}
    } -cleanup {
        cleanup
    } -result {1001}


    test delete-2.1 {Undo restores MAD and driver} -setup {
        mad mutate create $m1  ;# 1000
        set undo [mad mutate delete 1000]
    } -body {
        {*}$undo

        # mads view includes drivers table data
        ted query {SELECT * FROM mads}
    } -cleanup {
        cleanup
    } -result {
driver_id dtype narrative     cause  s   p   q   
--------- ----- ------------- ------ --- --- --- 
1000      MAGIC The First MAD UNIQUE 1.0 1.0 0.9 
    }




    #-------------------------------------------------------------------
    # mutate update

    test update-1.1 {MAD is updated} -setup {
        mad mutate create $m1  ;# 1000
    } -body {
        mad mutate update {
            driver_id 1000 
            narrative Modified
            cause     HUNGER
            s         0.5
            p         0.1
            q         0.0
        }

        ted query {SELECT * FROM mads}
    } -cleanup {
        cleanup
    } -result {
driver_id dtype narrative cause  s   p   q   
--------- ----- --------- ------ --- --- --- 
1000      MAGIC Modified  HUNGER 0.5 0.1 0.0 
    }

    test update-2.1 {undo undoes the change} -setup {
        mad mutate create $m1  ;# 1000
    } -body {
        set a [ted query {SELECT * FROM mads}]

        set undo [mad mutate update {
            driver_id 1000 
            narrative Modified
            cause     HUNGER
            p         0.1
            q         0.0
        }]

        {*}$undo

        set b [ted query {SELECT * FROM mads}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # hrel

    test hrel-1.1 {input is created} -setup {
        lock

        mad mutate create $m1  ;# 1000
    } -body {
        mad mutate hrel {
            driver_id 1000 mode persistent f SHIA g BLUE mag 5
        }

        ted query {
            SELECT driver_id,pflag,cause,f,g,mag
            FROM uram_hrel_effects
        }
    } -cleanup {
        cleanup
    } -result {
driver_id pflag cause f    g    mag 
--------- ----- ----- ---- ---- --- 
1000      1     1000  SHIA BLUE 5.0 
    }


    test hrel-1.2 {rule_firings created} -setup {
        lock

        mad mutate create $m1
    } -body {
        mad mutate hrel {
            driver_id 1000 mode persistent f SHIA g BLUE mag 5
        }

        ted querylist {SELECT * FROM rule_firings}
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-1-1
fdict      f SHIA g BLUE narrative {The First MAD}
    }

    test hrel-1.3 {f is empty civilian group} -setup {
        lock
        mad mutate create $m1  ;# 1000
        empty SHIA
    } -body {
        mad mutate hrel {
            driver_id 1000 mode persistent f SHIA g BLUE mag 5
        }
        
        rdb onecolumn {SELECT count(*) FROM uram_hrel_effects}
    } -cleanup {
        cleanup
    } -result {0}

    test hrel-1.4 {g is empty civilian group} -setup {
        lock
        mad mutate create $m1  ;# 1000
        empty SHIA
    } -body {
        mad mutate hrel {
            driver_id 1000 mode persistent f BLUE g SHIA mag 5
        }
        
        rdb onecolumn {SELECT count(*) FROM uram_hrel_effects}
    } -cleanup {
        cleanup
    } -result {0}


    #-------------------------------------------------------------------
    # vrel

    test vrel-1.1 {input is created} -setup {
        lock

        mad mutate create $m1  ;# 1000
    } -body {
        mad mutate vrel {
            driver_id 1000 mode persistent g SHIA a JOE mag 5
        }

        ted query {
            SELECT driver_id,pflag,cause,g,a,mag
            FROM uram_vrel_effects
        }
    } -cleanup {
        cleanup
    } -result {
driver_id pflag cause g    a   mag 
--------- ----- ----- ---- --- --- 
1000      1     1000  SHIA JOE 5.0 
    }


    test vrel-1.2 {creates rule_firings entry} -setup {
        lock

        mad mutate create $m1
    } -body {
        mad mutate vrel {
            driver_id 1000 mode persistent g SHIA a JOE mag 5
        }

        ted querylist {SELECT * FROM rule_firings}
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-2-1
fdict      g SHIA a JOE narrative {The First MAD}
    }

    test vrel-1.3 {g is empty civilian group} -setup {
        lock
        mad mutate create $m1  ;# 1000
        empty SHIA
    } -body {
        mad mutate vrel {
            driver_id 1000 mode persistent g SHIA a JOE mag 5
        }
        
        rdb onecolumn {SELECT count(*) FROM uram_vrel_effects}
    } -cleanup {
        cleanup
    } -result {0}


    #-------------------------------------------------------------------
    # sat

    test sat-1.1 {input is created} -setup {
        lock

        mad mutate create $m1   ;# 1000
    } -body {
        mad mutate sat {
            driver_id 1000 mode T g SHIA c AUT mag 5 
        }

        ted query {
            SELECT driver_id,pflag,cause,g,c,mag
            FROM uram_sat_effects
        }
    } -cleanup {
        cleanup
    } -result {
driver_id pflag cause g    c   mag 
--------- ----- ----- ---- --- --- 
1000      0     1000  SHIA AUT 5.0 
    }


    test sat-1.2 {creates rule_firings entry} -setup {
        lock

        mad mutate create $m1  ;# 1000
    } -body {
        mad mutate sat {
            driver_id 1000 mode T g SHIA c AUT mag 5 
        }

        ted querylist {SELECT * FROM rule_firings}
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-3-1
fdict      n NB1 g SHIA c AUT narrative {The First MAD}
    }

    test sat-1.3 {g is empty civilian group} -setup {
        lock
        mad mutate create $m1  ;# 1000
        empty SHIA
    } -body {
        mad mutate sat {
            driver_id 1000 mode persistent g SHIA c AUT mag 5
        }
        
        rdb onecolumn {SELECT count(*) FROM uram_sat_effects}
    } -cleanup {
        cleanup
    } -result {0}



    #-------------------------------------------------------------------
    # coop

    test coop-1.1 {input is created} -setup {
        lock

        mad mutate create $m1  ;# 1000
    } -body {
        mad mutate coop {
            driver_id 1000 mode persistent f SHIA g BLUE mag 5
        }

        ted query {
            SELECT driver_id,pflag,cause,f,g,mag
            FROM uram_coop_effects
        }
    } -cleanup {
        cleanup
    } -result {
driver_id pflag cause f    g    mag 
--------- ----- ----- ---- ---- --- 
1000      1     1000  SHIA BLUE 5.0 
    }


    test coop-1.2 {Level input sends report} -setup {
        lock

        mad mutate create $m1
    } -body {
        mad mutate coop {
            driver_id 1000 mode persistent f SHIA g BLUE mag 5
        }

        ted querylist {SELECT * FROM rule_firings}
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-4-1
fdict      n NB1 f SHIA g BLUE narrative {The First MAD}
    }
    
    test coop-1.3 {f is empty civilian group} -setup {
        lock
        mad mutate create $m1  ;# 1000
        empty SHIA
    } -body {
        mad mutate coop {
            driver_id 1000 mode persistent f SHIA g BLUE mag 5
        }
        
        rdb onecolumn {SELECT count(*) FROM uram_coop_effects}
    } -cleanup {
        cleanup
    } -result {0}



    #-------------------------------------------------------------------
    # names

    test names-1.1 {Returns names: none defined} -body {
        mad names
    } -cleanup {
        cleanup
    } -result {}


    test names-1.2 {Returns names} -setup {
        mad mutate create $m1
        mad mutate create $m2
    } -body {
        mad names
    } -cleanup {
        cleanup
    } -result {1000 1001}


    #-------------------------------------------------------------------
    # validate

    test validate-1.1 {Invalid ID} -body {
        mad validate NONESUCH
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {MAD does not exist: "NONESUCH"}


    test validate-2.1 {Valid ID} -setup {
        mad mutate create $m1  ;# 1000
    } -body {
        mad validate 1000
    } -cleanup {
        cleanup
    } -result {1000}


    #-------------------------------------------------------------------
    # initial names

    test initial_names-1.1 {Returns names: none defined} -body {
        mad initial names
    } -cleanup {
        cleanup
    } -result {}


    test initial_names-1.2 {Returns names} -setup {
        mad mutate create $m1  ;# 1000
        mad mutate create $m2  ;# 1001
        mad mutate create $m3  ;# 1002
    } -body {
        mad initial names
    } -cleanup {
        cleanup
    } -result {1000 1001 1002}

    test initial_names-1.3 {Names with inputs are excluded} -setup {
        lock

        mad mutate create $m1  ;# 1000
        mad mutate create $m2  ;# 1001
        mad mutate create $m3  ;# 1002

        mad mutate coop {
            driver_id 1001 mode persistent f SHIA g BLUE mag 5
        }
    } -body {
        mad initial names
    } -cleanup {
        cleanup
    } -result {1000 1002}


    #-------------------------------------------------------------------
    # initial validate

    test initial_validate-1.1 {Invalid ID} -body {
        mad initial validate NONESUCH
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {MAD does not exist or is not in initial state: "NONESUCH"}

    test initial_validate-1.2 {Not in initial state} -setup {
        lock
        
        mad mutate create $m1  ;# 1000
        mad mutate create $m2  ;# 1001
        mad mutate create $m3  ;# 1002

        mad mutate coop {
            driver_id 1001 mode persistent f SHIA g BLUE mag 5
        }
    } -body {
        mad initial validate 1001
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {MAD does not exist or is not in initial state: "1001"}

    test initial_validate-2.1 {Valid ID} -setup {
        lock
        
        mad mutate create $m1  ;# 1000
        mad mutate create $m2  ;# 1001
        mad mutate create $m3  ;# 1002

        mad mutate coop {
            driver_id 1001 mode persistent f SHIA g BLUE mag 5
        }
    } -body {
        mad initial validate 1002
    } -cleanup {
        cleanup
    } -result {1002}

    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::athena_test::tests::





