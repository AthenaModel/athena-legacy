# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    010-unit.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    unit(sim) tests.
#
#    This test suite tests the unit(sim) mutators and queries
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Clean up after a test

    proc cleanup {} {
        # Clean up the test environment
        array unset parms
        ted cleanup
    }

    set u1 {
        u         U1 
        g         BLUE 
        origin    NONE
        location  {1 1} 
        personnel 1 
        a         NONE
    }

    set u2 {
        u         U2 
        g         USAID
        origin    NONE
        location  {999 999} 
        personnel 1 
        a         NONE
    }

    set u3 {
        u         U3 
        g         SHIA
        origin    NB1
        location  {999 999} 
        personnel 1 
        a         NONE
    }

    #-------------------------------------------------------------------
    # mutate create

    test create-1.1 {units are created} -setup {
        ted create NB1 BLUE USAID SHIA 
    } -body {
        # FRC unit
        unit mutate create $u1
        unit mutate create $u2
        unit mutate create $u3

        ted query {SELECT * FROM units}
    } -cleanup {
        cleanup
    } -result {
u  g     origin personnel location a    gtype n a_effective 
-- ----- ------ --------- -------- ---- ----- - ----------- 
U1 BLUE  NONE   1         1 1      NONE FRC     0           
U2 USAID NONE   1         999 999  NONE ORG     0           
U3 SHIA  NB1    1         999 999  NONE CIV     0           
    }


    test create-1.2 {<Entity> create} -body {
        ted notifier bind ::unit <Entity>
        unit mutate create $u1
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> create U1}
    }


    test create-1.3 {n is set} -setup {
        ted create NB1 BLUE
        set loc [dict get [ted entity NB1] refpoint]
    } -body {
        unit mutate create [dict merge $u1 [list location $loc]]

        ted query {SELECT * FROM units}
    } -cleanup {
        cleanup
    } -result {
u  g    origin personnel location a    gtype n   a_effective 
-- ---- ------ --------- -------- ---- ----- --- ----------- 
U1 BLUE NONE   1         100 100  NONE FRC   NB1 0           
    }

    test create-2.1 {undo deletes the unit} -setup {
        ted create BLUE
        set undo [unit mutate create $u1]
    } -body {
        {*}$undo
        rdb eval {SELECT u FROM units}
    } -cleanup {
        cleanup
    } -result {}


    test create-2.2 {On undo, <Entity> delete} -setup {
        ted create BLUE
        set undo [unit mutate create $u1]
    } -body {
        ted notifier bind ::unit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> delete U1}
    }

    #-------------------------------------------------------------------
    # mutate delete

    test delete-1.1 {Unit is deleted} -setup {
        ted create BLUE USAID
        unit mutate create $u1
        unit mutate create $u2
    } -body {
        unit mutate delete U1

        # Is U1 gone?
        rdb eval {SELECT u FROM units}
    } -cleanup {
        cleanup
    } -result {U2}


    test delete-1.2 {<Entity> delete} -setup {
        ted create BLUE
        unit mutate create $u1
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate delete U1
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> delete U1}
    }


    test delete-2.1 {Undo restores unit} -setup {
        ted create BLUE
        unit mutate create $u1
        set undo [unit mutate delete U1]
    } -body {
        {*}$undo
        ted query {SELECT * FROM units}
    } -cleanup {
        cleanup
    } -result {
u  g    origin personnel location a    gtype n a_effective 
-- ---- ------ --------- -------- ---- ----- - ----------- 
U1 BLUE NONE   1         1 1      NONE FRC     0           
    }


    test delete-2.2 {On undo, <Entity> create} -setup {
        ted create BLUE
        unit mutate create $u1
        set undo [unit mutate delete U1]
    } -body {
        ted notifier bind ::unit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> create U1}
    }

    #-------------------------------------------------------------------
    # mutate move

    test move-1.1 {unit is moved} -setup {
        ted create NB1 BLUE
        unit mutate create $u1
    } -body {
        unit mutate move U1 {2 2}

        ted query {SELECT * FROM units}
    } -cleanup {
        cleanup
    } -result {
u  g    origin personnel location a    gtype n a_effective 
-- ---- ------ --------- -------- ---- ----- - ----------- 
U1 BLUE NONE   1         2 2      NONE FRC     0           
    }


    test move-1.2 {<Entity> update} -setup {
        unit mutate create $u1
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate move U1 {3 3}
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    test move-1.3 {n is updated} -setup {
        ted create NB1
        set loc [dict get [ted entity NB1] refpoint]
        unit mutate create $u1
    } -body {
        unit mutate move U1 $loc

        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n   
-- --- 
U1 NB1 
    }


    test move-2.1 {undo undoes the change} -setup {
        ted create BLUE USAID
        unit mutate create $u1
    } -body {

        set a [ted query {SELECT * FROM units}]

        set undo [unit mutate move U1 {3 3}]

        {*}$undo

        set b [ted query {SELECT * FROM units}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test move-2.2 {undo sends <Entity> update} -setup {
        unit mutate create $u1
    } -body {
        set undo [unit mutate move U1 {3 3}]

        ted notifier bind ::unit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    #-------------------------------------------------------------------
    # mutate activity

    test activity-1.1 {unit's activity is set} -setup {
        ted create BLUE
        unit mutate create $u1
    } -body {
        unit mutate activity U1 PATROL

        ted query {SELECT * FROM units}
    } -cleanup {
        cleanup
    } -result {
u  g    origin personnel location a      gtype n a_effective 
-- ---- ------ --------- -------- ------ ----- - ----------- 
U1 BLUE NONE   1         1 1      PATROL FRC     0           
    }


    test activity-1.2 {<Entity> update} -setup {
        unit mutate create $u1
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate activity U1 PATROL
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    test activity-2.1 {undo undoes the change} -setup {
        ted create BLUE USAID
        unit mutate create $u1
    } -body {

        set a [ted query {SELECT * FROM units}]

        set undo [unit mutate activity U1 PATROL]

        {*}$undo

        set b [ted query {SELECT * FROM units}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test activity-2.2 {undo sends <Entity> update} -setup {
        unit mutate create $u1
    } -body {
        set undo [unit mutate activity U1 PATROL]

        ted notifier bind ::unit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    #-------------------------------------------------------------------
    # mutate personnel


    test personnel-1.1 {unit is updated} -setup {
        ted create NB1 BLUE
        unit mutate create $u1
    } -body {
        unit mutate personnel U1 3


        ted query {SELECT * FROM units}
    } -cleanup {
        cleanup
    } -result {
u  g    origin personnel location a    gtype n a_effective 
-- ---- ------ --------- -------- ---- ----- - ----------- 
U1 BLUE NONE   3         1 1      NONE FRC     0           
    }


    test personnel-1.2 {<Entity> update} -setup {
        unit mutate create $u1
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate personnel  U1 25
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    test personnel-2.1 {undo undoes the change} -setup {
        ted create BLUE
        unit mutate create $u1
    } -body {

        set a [ted query {SELECT * FROM units}]

        set undo [unit mutate personnel U1 25]

        {*}$undo

        set b [ted query {SELECT * FROM units}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}

    test personnel-2.2 {undo sends <Entity> update} -setup {
        unit mutate create $u1
    } -body {
        set undo [unit mutate personnel U1 25]

        ted notifier bind ::unit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    #-------------------------------------------------------------------
    # reconcile

    # reconcile-1.*: Units for which no group exists should be
    # deleted; others should remain.  The undo should restore the
    # units as they were.  Both should send <Entity> events.

    test reconcile-1.1 {delete units for which no group exists} -setup {
        ted create BLUE USAID
        unit mutate create $u1
        unit mutate create $u2
        frcgroup mutate delete BLUE
    } -body {
        unit mutate reconcile
        rdb eval {SELECT u FROM units}
    } -cleanup {
        cleanup
    } -result {U2}


    test reconcile-1.2 {send <Entity> delete} -setup {
        ted create BLUE USAID
        unit mutate create $u1
        unit mutate create $u2
        frcgroup mutate delete BLUE
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate reconcile
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> delete U1}
    }


    test reconcile-1.3 {restore deleted units on undo} -setup {
        ted create BLUE USAID
        unit mutate create $u1
        unit mutate create $u2
        frcgroup mutate delete BLUE
        set undo [unit mutate reconcile]
    } -body {
        eval $undo
        rdb eval {SELECT u FROM units}
    } -cleanup {
        cleanup
    } -result {U2 U1}


    test reconcile-1.4 {send <Entity> create on undo} -setup {
        ted create BLUE USAID
        unit mutate create $u1
        unit mutate create $u2
        frcgroup mutate delete BLUE
        set undo [unit mutate reconcile]
    } -body {
        ted notifier bind ::unit <Entity>
        eval $undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> create U1}
    }


    # reconcile-2.*: Units should have their "n" reset, if their neighborhood
    # has changed.for which the "n" is unknown should have
    # "n" set, if they are in a neighborhood.  The undo should clear
    # the "n" again. Both should send <Entity> events.

    test reconcile-2.1 {Set n for units in new neighborhoods} -setup {
        # Create u1 in NB3 at NB4's refpoint; when NB4 is created,
        # verify that U1's nbhood is updated.
        ted create NB3 BLUE USAID
        set loc [dict get [ted entity NB4] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
        unit mutate create $u2
        ted create NB4
    } -body {
        unit mutate reconcile
        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n   
-- --- 
U1 NB4 
U2     
    }


    test reconcile-2.2 {Set n for units in deleted neighborhoods} -setup {
        # Create U1 in NB4 on NB3, and U2 in NB1.  Delete NB4 and NB1.
        # verify that U1 is in NB3 and U2 is in no neighborhood.
        ted create NB1 NB3 NB4 BLUE USAID
        set loc1 [dict get [ted entity NB1] refpoint]
        set loc4 [dict get [ted entity NB4] refpoint]
        unit mutate create [dict merge $u1 [list location $loc4]]
        unit mutate create [dict merge $u2 [list location $loc1]]

    } -body {
        nbhood mutate delete NB1
        nbhood mutate delete NB4
        unit mutate reconcile
        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n   
-- --- 
U1 NB3 
U2     
    }


    test reconcile-2.3 {Set n for units when raising nbhood} -setup {
        # Create U1 in NB4 on NB3, and then restack
        ted create NB3 NB4 BLUE USAID
        set loc [dict get [ted entity NB4] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
    } -body {
        nbhood mutate raise NB3
        unit mutate reconcile
        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n   
-- --- 
U1 NB3 
    }


    test reconcile-2.4 {Set n for units when lowering nbhood} -setup {
        # Create U1 in NB4 on NB3, and then restack
        ted create NB3 NB4 BLUE USAID
        set loc [dict get [ted entity NB4] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
    } -body {
        nbhood mutate lower NB4
        unit mutate reconcile
        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n   
-- --- 
U1 NB3 
    }


    test reconcile-2.5 {Set n for units when polygon moves} -setup {
        # Create U1 in NB1, then move NB1
        ted create NB1 BLUE
        set loc [dict get [ted entity NB1] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
    } -body {
        nbhood mutate update                                   \
            [list                                              \
                 n        NB1                                  \
                 refpoint [dict get [ted entity NB4] refpoint] \
                 polygon  [dict get [ted entity NB4] polygon]]

        unit mutate reconcile

        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n 
-- - 
U1   
    }


    test reconcile-2.6 {Send <Entity> update when n is set} -setup {
        ted create BLUE USAID
        set loc [dict get [ted entity NB1] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
        unit mutate create $u2
        ted create NB1
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate reconcile
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    test reconcile-2.7 {Reset n on undo} -setup {
        ted create BLUE USAID
        set loc [dict get [ted entity NB1] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
        unit mutate create $u2
        ted create NB1

        set undo [unit mutate reconcile]
    } -body {
        eval $undo
        ted query {SELECT u,n FROM units}
    } -cleanup {
        cleanup
    } -result {
u  n 
-- - 
U1   
U2   
    }


    test reconcile-2.8 {Send <Entity> update on undo} -setup {
        ted create BLUE USAID
        set loc [dict get [ted entity NB1] refpoint]
        unit mutate create [dict merge $u1 [list location $loc]]
        unit mutate create $u2
        ted create NB1

        set undo [unit mutate reconcile]
    } -body {
        ted notifier bind ::unit <Entity>
        eval $undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> update U1}
    }


    # reconcile-3.*: CIV Units should be deleted if their nbgroup is
    # deleted.  The undo should restore the unit.
    # Both should send <Entity> events.

    test reconcile-3.1 {Delete CIV units with no nbgroup.} -setup {
        ted create NB1 SHIA
        unit mutate create $u3
    } -body {
        unit mutate reconcile
        rdb eval {SELECT u FROM units}
    } -cleanup {
        cleanup
    } -result {}


    test reconcile-3.2 {Send <Entity> delete} -setup {
        ted create NB1 SHIA
        unit mutate create $u3
    } -body {
        ted notifier bind ::unit <Entity>
        unit mutate reconcile
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> delete U3}
    }


    test reconcile-3.3 {Restore unit on undo} -setup {
        ted create NB1 SHIA
        unit mutate create $u3

        set undo [unit mutate reconcile]
    } -body {
        eval $undo
        rdb eval {SELECT u FROM units}
    } -cleanup {
        cleanup
    } -result {U3}


    test reconcile-3.4 {Send <Entity> update on undo} -setup {
        ted create NB1 SHIA
        unit mutate create $u3

        set undo [unit mutate reconcile]
    } -body {
        ted notifier bind ::unit <Entity>
        eval $undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::unit <Entity> create U3}
    }


    #-------------------------------------------------------------------
    # names

    test names-1.1 {Returns names: none defined} -body {
        unit names
    } -cleanup {
        cleanup
    } -result {}


    test names-1.2 {Returns names} -setup {
        unit mutate create $u1
        unit mutate create $u2
    } -body {
        unit names
    } -cleanup {
        cleanup
    } -result {U1 U2}


    #-------------------------------------------------------------------
    # validate

    test validate-1.1 {Invalid name} -body {
        unit validate NONESUCH
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Invalid unit name: "NONESUCH"}


    test validate-2.1 {Valid name} -setup {
        unit mutate create $u1
    } -body {
        unit validate U1
    } -cleanup {
        cleanup
    } -result {U1}

    #-------------------------------------------------------------------
    # origin names

    test origin_names-1.1 {Returns names of nbhoods, plus NONE} -setup {
        ted create NB1 NB2
    } -body {
        unit origin names
    } -cleanup {
        cleanup
    } -result {NONE NB1 NB2}


    #-------------------------------------------------------------------
    # origin validate

    test origin_validate-1.1 {Invalid name} -setup {
        ted create NB1 NB2
    } -body {
        unit origin validate NONESUCH
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Invalid unit origin, should be one of: NONE, NB1, NB2}


    test origin_validate-2.1 {Valid name} -setup {
        ted create NB1 NB2
    } -body {
        unit origin validate NB2
    } -cleanup {
        cleanup
    } -result {NB2}

    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::athena_test::tests::





