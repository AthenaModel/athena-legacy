# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    010-ensit.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    ensit(sim) tests.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Clean up after a test

    proc cleanup {} {
        ted cleanup
    }

    set s1 [dict create \
                stype     BADWATER                             \
                location  [dict get [ted entity NB1] refpoint] \
                coverage  1.0                                  \
                g         BLUE                                 \
                resolver  NONE                                 \
                inception 1                                    \
                rduration ""] 

    set s2 [dict create \
                stype     COMMOUT                              \
                location  [dict get [ted entity NB1] refpoint] \
                coverage  0.5                                  \
                g         NONE                                 \
                resolver  BLUE                                 \
                inception 0                                    \
                rduration ""] 

    #-------------------------------------------------------------------
    # table
  
    test table-1.1 {Check return value} -body {
        ensit table
    } -result {ensits_t}

    #-------------------------------------------------------------------
    # mutate create

    test create-1.1 {Ensit is created} -setup {
        ted create NB1 BLUE
    } -body {
        ensit mutate create $s1
        ensit mutate create $s2

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state   ts tc change flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ------- -- -- ------ ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      INITIAL 0  0  NEW    ALL   BLUE           100 100  1         NONE     5         0       
2 ::ensit COMMOUT  -1     NB1 0.5      INITIAL 0  0  NEW    ALL   NONE           100 100  0         BLUE     7         0       
    }
    

    test create-1.2 {Ensit is created, duration can be set} -setup {
        ted create NB1 BLUE
    } -body {
        ensit mutate create [dict merge $s1 [list rduration 20]]

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state   ts tc change flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ------- -- -- ------ ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      INITIAL 0  0  NEW    ALL   BLUE           100 100  1         NONE     20        0       
    }
    

    test create-1.3 {<Entity> create} -setup {
        ted create NB1 BLUE
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate create $s1
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> create 1}
    }


    test create-2.1 {Undo deletes the entity} -setup {
        ted create NB1 BLUE
        set undo [ensit mutate create $s1]
    } -body {
        {*}$undo
        rdb query {SELECT s FROM ensits}
    } -cleanup {
        cleanup
    } -result {}


    test create-2.2 {On undo, <Entity> delete} -setup {
        ted create NB1 BLUE
        set undo [ensit mutate create $s1]
    } -body {
        ted notifier bind ::ensit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> delete 1}
    }


    #-------------------------------------------------------------------
    # mutate delete

    test delete-1.1 {Entity is deleted} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit mutate delete 1

        # Is 1 gone?
        rdb eval {SELECT s FROM ensits}
    } -cleanup {
        cleanup
    } -result {2}


    test delete-1.2 {<Entity> delete} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate delete 1
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> delete 1}
    }


    test delete-2.1 {Undo restores ensit} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        set undo [ensit mutate delete 1]
    } -body {
        {*}$undo
        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state   ts tc change flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ------- -- -- ------ ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      INITIAL 0  0  NEW    ALL   BLUE           100 100  1         NONE     5         0       
    }


    test delete-2.2 {On undo, <Entity> create} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        set undo [ensit mutate delete 1]
    } -body {
        ted notifier bind ::ensit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> create 1}
    }


    #-------------------------------------------------------------------
    # mutate update


    test update-1.1 {ensit is updated} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ensit mutate update {
            s         1 
            stype     BADFOOD
            location  {101 101} 
            coverage  0.5
            inception 0
            g         NONE
            resolver  BLUE
            rduration 10
        }

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype   driver n   coverage state   ts tc change flist g    signature location inception resolver rduration rdriver 
- ------- ------- ------ --- -------- ------- -- -- ------ ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADFOOD -1     NB1 0.5      INITIAL 0  0  NEW    ALL   NONE           101 101  0         BLUE     10        0       
    }

    test update-1.2 {identical values are OK} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        ensit mutate update [concat {s 1} $s1]

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test update-1.3 {empty values are OK} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        ensit mutate update  {
            s         1
            stype     ""
            location  ""
            coverage  ""
            inception ""
            g         ""
            resolver  ""
            rduration ""
        }

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test update-1.4 {<Entity> update} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate update  {
            s         1
            stype     ""
            location  ""
            coverage  ""
            inception ""
            g         ""
            resolver  ""
            rduration ""
        }
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    test update-1.5 {n is updated} -setup {
        ted create NB1 NB2 BLUE
        set loc [dict get [ted entity NB2] refpoint]
        ensit mutate create $s1
    } -body {
        ensit mutate update [dict merge $s1 [list s 1 location $loc]]

        ted query {SELECT s,n FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s n   
- --- 
1 NB2 
    }


    test update-2.1 {undo undoes the change} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        set undo [ensit mutate update {
            s         1 
            stype     BADFOOD
            location  ""
            coverage  ""
            inception ""
            g         ""
            resolver  ""
            rduration ""
        }]

        {*}$undo

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test update-2.2 {undo sends <Entity> update} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set undo [ensit mutate update {
            s         1 
            stype     BADFOOD
            location  ""
            coverage  ""
            inception ""
            g         ""
            resolver  ""
            rduration ""
        }]

        ted notifier bind ::ensit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    #-------------------------------------------------------------------
    # mutate resolve


    test resolve-1.1 {ensit is resolved by NONE} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ensit mutate resolve {
            s         1 
            resolver  NONE
        }

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state ts tc change   flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ----- -- -- -------- ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      ENDED 0  0  RESOLVED ALL   BLUE           100 100  1         NONE     5         0       
    }


    test resolve-1.2 {<Entity> update} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate resolve  {
            s        1
            resolver NONE
        }
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    test resolve-2.1 {undo undoes the change} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        set undo [ensit mutate resolve {
            s        1
            resolver NONE
        }]

        {*}$undo

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test resolve-2.2 {undo sends <Entity> update} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set undo [ensit mutate resolve {
            s        1
            resolver NONE
        }]

        ted notifier bind ::ensit <Entity>
        {*}$undo
        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    #-------------------------------------------------------------------
    # mutate reconcile

    # g set to NONE if g doesn't exist

    test reconcile-1.1 {g set to NONE if g doesn't exist} -setup {
        ted create NB1
        ensit mutate create [dict merge $s1 [list g NONESUCH]]
    } -body {
        ensit mutate reconcile

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state   ts tc change flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ------- -- -- ------ ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      INITIAL 0  0  NEW    ALL   NONE           100 100  1         NONE     5         0       
    }


    test reconcile-1.2 {<Entity> update} -setup {
        ted create NB1
        ensit mutate create [dict merge $s1 [list g NONESUCH]]
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate reconcile

        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    # resolver set to NONE if resolver doesn't exist

    test reconcile-2.1 {resolver set to NONE if resolver doesn't exist} -setup {
        ted create NB1
        ensit mutate create [dict merge $s1 [list g NONE]]
        ensit mutate resolve [list s 1 resolver BLUE]
    } -body {
        ensit mutate reconcile

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state ts tc change   flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ----- -- -- -------- ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      ENDED 0  0  RESOLVED ALL   NONE           100 100  1         NONE     5         0       
    }


    test reconcile-2.2 {<Entity> update} -setup {
        ted create NB1
        ensit mutate create [dict merge $s1 [list g NONE]]
        ensit mutate resolve [list s 1 resolver BLUE]
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate reconcile

        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    # n reset

    test reconcile-3.1 {n reset} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        nbhood mutate delete NB1
    } -body {
        ensit mutate reconcile

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n coverage state   ts tc change flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ - -------- ------- -- -- ------ ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1       1.0      INITIAL 0  0  NEW    ALL   BLUE           100 100  1         NONE     5         0       
    }


    test reconcile-3.2 {<Entity> update} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        nbhood mutate delete NB1
    } -body {
        ted notifier bind ::ensit <Entity>
        ensit mutate reconcile

        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
    }


    # Undo restores everything

    test reconcile-4.1 {Undo restores everything} -setup {
        ted create NB1
        ensit mutate create $s1
        ensit mutate resolve [list s 1 resolver BRIT]
        nbhood mutate delete NB1

        set undo [ensit mutate reconcile]
    } -body {
        eval $undo

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state ts tc change   flist g    signature location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ----- -- -- -------- ----- ---- --------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER -1     NB1 1.0      ENDED 0  0  RESOLVED ALL   BLUE           100 100  1         BRIT     5         0       
    }


    test reconcile-4.2 {Undo sends <Entity> update} -setup {
        ted create NB1
        ensit mutate create $s1
        ensit mutate resolve [list s 1 resolver BRIT]
        nbhood mutate delete NB1

        set undo [ensit mutate reconcile]
    } -body {
        ted notifier bind ::ensit <Entity>
        eval $undo

        ted notifier received
    } -cleanup {
        cleanup
    } -result {
        {::ensit <Entity> update 1}
        {::ensit <Entity> update 1}
    }


    #-------------------------------------------------------------------
    # get

    test get-1.1 {get -all} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        set sit [ensit get 1]
        $sit oneliner
    } -cleanup {
        cleanup
    } -result {BADWATER in NB1}


    test get-1.2 {get -live} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve { 
            s        1 
            resolver NONE
        }
    } -body {
        set sit [ensit get 1 -live]
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {no such live situation: "1"}


    #-------------------------------------------------------------------
    # existsInNbhood

    test existsInNbhood-1.1 {get list of live ensits} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit existsInNbhood NB1
    } -cleanup {
        cleanup
    } -result {BADWATER}


    test existsInNbhood-1.2 {Check existence of types} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        list \
            [ensit existsInNbhood NB1 BADWATER] \
            [ensit existsInNbhood NB1 COMMOUT]
    } -cleanup {
        cleanup
    } -result {1 0}


    #-------------------------------------------------------------------
    # absentFromNbhood

    test absentFromNbhood-1.1 {get list of absent ensits} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        # Only BADWATER should be missing.
        ensit absentFromNbhood NB1
    } -cleanup {
        cleanup
    } -result {BADFOOD COMMOUT DISASTER DISEASE DMGCULT DMGSACRED EPIDEMIC FOODSHRT FUELSHRT GARBAGE INDSPILL MINEFIELD NOWATER ORDNANCE PIPELINE POWEROUT REFINERY SEWAGE}

    
    #-------------------------------------------------------------------
    # names/validate
    #
    # enum(n)-like subcommands for all ensits, live and ended.

    test names-1.1 {get list of ensit IDs} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit names
    } -cleanup {
        cleanup
    } -result {1 2}
    

    test names-1.2 {validate valid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit validate 2
    } -cleanup {
        cleanup
    } -result {2}
    

    test names-1.3 {validate invalid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit validate 3
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Invalid environmental situation ID: "3"}
    

    #-------------------------------------------------------------------
    # initial names/validate
    #
    # enum(n)-like subcommands for ensits in the INITIAL state

    test initial_names-1.1 {get list of ensit IDs} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit initial names
    } -cleanup {
        cleanup
    } -result {1}
    

    test initial_names-1.2 {validate valid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit initial validate 1
    } -cleanup {
        cleanup
    } -result {1}
    

    test initial_names-1.3 {validate ended ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit initial validate 2
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {not a "live" situation: "2"}
    

    test initial_names-1.4 {validate active ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        [ensit get 2] set state ACTIVE
    } -body {
        ensit initial validate 2
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {operation is invalid; time has passed.}

    #-------------------------------------------------------------------
    # live names/validate
    #
    # enum(n)-like subcommands for ensits that "live"

    test live_names-1.1 {get list of ensit IDs} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit live names
    } -cleanup {
        cleanup
    } -result {1}
    

    test live_names-1.2 {validate valid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit live validate 1
    } -cleanup {
        cleanup
    } -result {1}
    

    test live_names-1.3 {validate invalid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit live validate 2
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {not a "live" situation: "2".}


    #-------------------------------------------------------------------
    # spawn

    test spawn-1.1 {Spawn is not yet scheduled on create} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
    } -body {
        ensit mutate create $s1
        ted query {SELECT * FROM eventq_queue_ensitSpawn}
    } -cleanup {
        cleanup
    } -result {
    }


    test spawn-1.2 {Spawn is scheduled on first assess} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
    } -body {
        ted order SIM:RUN days 1 block yes
        ted query {SELECT * FROM eventq_queue_ensitSpawn}
    } -cleanup {
        cleanup
    } -result {
id t etype      s 
-- - ---------- - 
1  2 ensitSpawn 1 
    }


    test spawn-1.3 {spawn is canceled on resolve} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
        ted order SIM:RUN days 1 block yes
    } -body {
        ensit mutate resolve {
            s        1
            resolver NONE
        }

        ted query {SELECT * FROM eventq_queue_ensitSpawn}
    } -cleanup {
        cleanup
    } -result {
    }


    test spawn-1.4 {undo restores scheduled spawn} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
        ted order SIM:RUN days 1 block yes
        set undo [ensit mutate resolve {
            s        1
            resolver NONE
        }]
    } -body {
        {*}$undo

        ted query {SELECT * FROM eventq_queue_ensitSpawn}
    } -cleanup {
        cleanup
    } -result {
id t etype      s 
-- - ---------- - 
3  2 ensitSpawn 1 
    }


    test spawn-1.5 {Ensits spawn at spawn time} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
    } -body {
        ted order SIM:RUN days 3 block yes

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype    driver n   coverage state  ts tc change flist g    signature         location inception resolver rduration rdriver 
- ------- -------- ------ --- -------- ------ -- -- ------ ----- ---- ----------------- -------- --------- -------- --------- ------- 
1 ::ensit BADWATER 1      NB1 1.0      ACTIVE 0  0         ALL   BLUE BADWATER-2-1 none 100 100  0         NONE     5         0       
2 ::ensit DISEASE  2      NB1 1.0      ACTIVE 2  2  NEW    ALL   BLUE DISEASE-2-1 none  100 100  0         NONE     30        0       
    }




    #-------------------------------------------------------------------
    # auto-resolve

    test auto-resolve-1.1 {Auto-Resolve is not yet scheduled on create} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
    } -body {
        ensit mutate create $s1
        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
    }


    test auto-resolve-1.2 {Auto-Resolve is scheduled on first assess} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
    } -body {
        ted order SIM:RUN days 1 block yes
        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
id t etype            s 
-- - ---------------- - 
2  6 ensitAutoResolve 1 
    }


    test auto-resolve-1.3 {auto-resolve is canceled on resolve} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
        ted order SIM:RUN days 1 block yes
    } -body {
        ensit mutate resolve {
            s        1
            resolver NONE
        }

        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
    }


    test auto-resolve-1.4 {undo restores scheduled auto-resolve} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create $s1
        ted order SIM:RUN days 1 block yes
        set undo [ensit mutate resolve {
            s        1
            resolver NONE
        }]
    } -body {
        {*}$undo

        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
id t etype            s 
-- - ---------------- - 
4  6 ensitAutoResolve 1 
    }


    test auto-resolve-1.5 {Ensits auto-resolve at auto-resolve time} -setup {
        ted create NB1 BLUE SHIA NB1SHIA
        ensit mutate create [dict merge $s2 [list rduration 2]]
    } -body {
        ted order SIM:RUN days 4 block yes

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype   driver n   coverage state ts tc change   flist g    signature   location inception resolver rduration rdriver 
- ------- ------- ------ --- -------- ----- -- -- -------- ----- ---- ----------- -------- --------- -------- --------- ------- 
1 ::ensit COMMOUT 1      NB1 0.5      ENDED 0  3  RESOLVED ALL   NONE COMMOUT-3-1 100 100  0         BLUE     2         2       
    }



    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::athena_test::tests::









