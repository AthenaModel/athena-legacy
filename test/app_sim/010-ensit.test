# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    010-ensit.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    ensit(sim) tests.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Clean up after a test

    proc cleanup {} {
        ted cleanup
    }

    set s1 [dict create \
                stype     BADWATER                             \
                location  [dict get [ted entity NB1] refpoint] \
                coverage  1.0                                  \
                g         BLUE                                 \
                resolver  NONE                                 \
                inception 1                                    \
                rduration ""] 

    set s2 [dict create \
                stype     COMMOUT                              \
                location  [dict get [ted entity NB1] refpoint] \
                coverage  0.5                                  \
                g         NONE                                 \
                resolver  BLUE                                 \
                inception 0                                    \
                rduration ""] 

    set s3 [dict create \
                stype     INDSPILL                             \
                location  [dict get [ted entity NB1] refpoint] \
                coverage  1.0                                  \
                g         BLUE                                 \
                resolver  NONE                                 \
                inception 1                                    \
                rduration ""] 

    #-------------------------------------------------------------------
    # table
  
    test table-1.1 {Check return value} -body {
        ensit table
    } -result {ensits_t}

    #-------------------------------------------------------------------
    # mutate create

    test create-1.1 {Ensit is created} -setup {
        ted create NB1 BLUE
    } -body {
        ensit mutate create $s1
        ensit mutate create $s2

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           BLUE
location    100 100
inception   1
resolver    NONE
rduration   1
rdriver_id  0

s           2
kind        ::ensit
stype       COMMOUT
driver_id   -1
n           NB1
coverage    0.5
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           NONE
location    100 100
inception   0
resolver    BLUE
rduration   1
rdriver_id  0
    }
    

    test create-1.2 {Ensit is created, duration can be set} -setup {
        ted create NB1 BLUE
    } -body {
        ensit mutate create [dict merge $s1 [list rduration 20]]

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           BLUE
location    100 100
inception   1
resolver    NONE
rduration   20
rdriver_id  0
    }
    

    test create-2.1 {Undo deletes the entity} -setup {
        ted create NB1 BLUE
        set undo [ensit mutate create $s1]
    } -body {
        {*}$undo
        rdb query {SELECT s FROM ensits}
    } -cleanup {
        cleanup
    } -result {}


    #-------------------------------------------------------------------
    # mutate delete

    test delete-1.1 {Entity is deleted} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit mutate delete 1

        # Is 1 gone?
        rdb eval {SELECT s FROM ensits}
    } -cleanup {
        cleanup
    } -result {2}


    test delete-2.1 {Undo restores ensit} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        set undo [ensit mutate delete 1]
    } -body {
        {*}$undo
        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           BLUE
location    100 100
inception   1
resolver    NONE
rduration   1
rdriver_id  0
    }


    #-------------------------------------------------------------------
    # mutate update


    test update-1.1 {ensit is updated} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ensit mutate update {
            s         1 
            stype     BADFOOD
            location  {101 101} 
            coverage  0.5
            inception 0
            g         NONE
            resolver  BLUE
            rduration 10
        }

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADFOOD
driver_id   -1
n           NB1
coverage    0.5
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           NONE
location    101 101
inception   0
resolver    BLUE
rduration   10
rdriver_id  0
    }

    test update-1.2 {identical values are OK} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        ensit mutate update [concat {s 1} $s1]

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test update-1.3 {empty values are OK} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        ensit mutate update  {
            s         1
            stype     ""
            location  ""
            coverage  ""
            inception ""
            g         ""
            resolver  ""
            rduration ""
        }

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    test update-1.5 {n is updated} -setup {
        ted create NB1 NB2 BLUE
        set loc [dict get [ted entity NB2] refpoint]
        ensit mutate create $s1
    } -body {
        ensit mutate update [dict merge $s1 [list s 1 location $loc]]

        ted query {SELECT s,n FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s n   
- --- 
1 NB2 
    }


    test update-2.1 {undo undoes the change} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        set undo [ensit mutate update {
            s         1 
            stype     BADFOOD
            location  ""
            coverage  ""
            inception ""
            g         ""
            resolver  ""
            rduration ""
        }]

        {*}$undo

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # mutate resolve


    test resolve-1.1 {ensit is resolved by NONE} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        ensit mutate resolve {
            s         1 
            resolver  NONE
        }

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       ENDED
ts          1
tc          0
change      RESOLVED
flist       ALL
g           BLUE
location    100 100
inception   1
resolver    NONE
rduration   1
rdriver_id  0
    }


    test resolve-2.1 {undo undoes the change} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
    } -body {
        set a [ted query {SELECT * FROM ensits}]

        set undo [ensit mutate resolve {
            s        1
            resolver NONE
        }]

        {*}$undo

        set b [ted query {SELECT * FROM ensits}]

        expr {$a eq $b}
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # mutate reconcile

    # g set to NONE if g doesn't exist

    test reconcile-1.1 {g set to NONE if g doesn't exist} -setup {
        ted create NB1
        ensit mutate create [dict merge $s1 [list g NONESUCH]]
    } -body {
        ensit mutate reconcile

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           NONE
location    100 100
inception   1
resolver    NONE
rduration   1
rdriver_id  0
    }


    # resolver set to NONE if resolver doesn't exist

    test reconcile-2.1 {resolver set to NONE if resolver doesn't exist} -setup {
        ted create NB1
        ensit mutate create [dict merge $s1 [list g NONE]]
        ensit mutate resolve [list s 1 resolver BLUE]
    } -body {
        ensit mutate reconcile

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       ENDED
ts          1
tc          0
change      RESOLVED
flist       ALL
g           NONE
location    100 100
inception   1
resolver    NONE
rduration   1
rdriver_id  0
    }


    # n reset

    test reconcile-3.1 {n reset} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        nbhood mutate delete NB1
    } -body {
        ensit mutate reconcile

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           
coverage    1.0
state       INITIAL
ts          1
tc          0
change      NEW
flist       ALL
g           BLUE
location    100 100
inception   1
resolver    NONE
rduration   1
rdriver_id  0
    }


    # Undo restores everything

    test reconcile-4.1 {Undo restores everything} -setup {
        ted create NB1
        ensit mutate create $s1
        ensit mutate resolve [list s 1 resolver BRIT]
        nbhood mutate delete NB1

        set undo [ensit mutate reconcile]
    } -body {
        eval $undo

        ted querylist {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s           1
kind        ::ensit
stype       BADWATER
driver_id   -1
n           NB1
coverage    1.0
state       ENDED
ts          1
tc          0
change      RESOLVED
flist       ALL
g           BLUE
location    100 100
inception   1
resolver    BRIT
rduration   1
rdriver_id  0
    }


    #-------------------------------------------------------------------
    # get

    test get-1.1 {get -all} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        set sit [ensit get 1]
        $sit oneliner
    } -cleanup {
        cleanup
    } -result {BADWATER in NB1}


    test get-1.2 {get -live} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve { 
            s        1 
            resolver NONE
        }
    } -body {
        set sit [ensit get 1 -live]
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {no such live situation: "1"}


    #-------------------------------------------------------------------
    # existsInNbhood

    test existsInNbhood-1.1 {get list of live ensits} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit existsInNbhood NB1
    } -cleanup {
        cleanup
    } -result {BADWATER}


    test existsInNbhood-1.2 {Check existence of types} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        list \
            [ensit existsInNbhood NB1 BADWATER] \
            [ensit existsInNbhood NB1 COMMOUT]
    } -cleanup {
        cleanup
    } -result {1 0}


    #-------------------------------------------------------------------
    # absentFromNbhood

    test absentFromNbhood-1.1 {get list of absent ensits} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        # Only BADWATER should be missing.
        ensit absentFromNbhood NB1
    } -cleanup {
        cleanup
    } -result {BADFOOD COMMOUT CULSITE DISASTER DISEASE EPIDEMIC FOODSHRT FUELSHRT GARBAGE INDSPILL MINEFIELD NOWATER ORDNANCE PIPELINE POWEROUT REFINERY RELSITE SEWAGE}

    
    #-------------------------------------------------------------------
    # names/validate
    #
    # enum(n)-like subcommands for all ensits, live and ended.

    test names-1.1 {get list of ensit IDs} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit names
    } -cleanup {
        cleanup
    } -result {1 2}
    

    test names-1.2 {validate valid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit validate 2
    } -cleanup {
        cleanup
    } -result {2}
    

    test names-1.3 {validate invalid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
    } -body {
        ensit validate 3
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Invalid environmental situation ID: "3"}
    

    #-------------------------------------------------------------------
    # initial names/validate
    #
    # enum(n)-like subcommands for ensits in the INITIAL state

    test initial_names-1.1 {get list of ensit IDs} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit initial names
    } -cleanup {
        cleanup
    } -result {1}
    

    test initial_names-1.2 {validate valid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit initial validate 1
    } -cleanup {
        cleanup
    } -result {1}
    

    test initial_names-1.3 {validate ended ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit initial validate 2
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {not a "live" situation: "2"}
    

    test initial_names-1.4 {validate active ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        [ensit get 2] set state ACTIVE
    } -body {
        ensit initial validate 2
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {operation is invalid; time has passed.}

    #-------------------------------------------------------------------
    # live names/validate
    #
    # enum(n)-like subcommands for ensits that "live"

    test live_names-1.1 {get list of ensit IDs} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit live names
    } -cleanup {
        cleanup
    } -result {1}
    

    test live_names-1.2 {validate valid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit live validate 1
    } -cleanup {
        cleanup
    } -result {1}
    

    test live_names-1.3 {validate invalid ID} -setup {
        ted create NB1 BLUE
        ensit mutate create $s1
        ensit mutate create $s2
        ensit mutate resolve {
            s        2
            resolver NONE
        }
    } -body {
        ensit live validate 2
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {not a "live" situation: "2".}


    #-------------------------------------------------------------------
    # auto-resolve

    test auto-resolve-1.1 {Auto-Resolve is not yet scheduled on create} -setup {
        ted create NB1 BLUE SHIA
    } -body {
        ensit mutate create $s1
        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
    }


    test auto-resolve-1.2 {Auto-Resolve is scheduled on first assess} -setup {
        ted create NB1 BLUE SHIA
        ensit mutate create $s1
    } -body {
        ted lock
        ted order SIM:RUN weeks 1 block yes
        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
id t etype            s 
-- - ---------------- - 
1  2 ensitAutoResolve 1 
    }


    test auto-resolve-1.3 {auto-resolve is canceled on resolve} -setup {
        ted create NB1 BLUE SHIA
        ensit mutate create $s1
        ted lock
        ted order SIM:RUN weeks 1 block yes
    } -body {
        ensit mutate resolve {
            s        1
            resolver NONE
        }

        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
    }


    test auto-resolve-1.4 {undo restores scheduled auto-resolve} -setup {
        ted create NB1 BLUE SHIA
        ensit mutate create $s1
        ted lock
        ted order SIM:RUN weeks 1 block yes
        set undo [ensit mutate resolve {
            s        1
            resolver NONE
        }]
    } -body {
        {*}$undo

        ted query {SELECT * FROM eventq_queue_ensitAutoResolve}
    } -cleanup {
        cleanup
    } -result {
id t etype            s 
-- - ---------------- - 
2  2 ensitAutoResolve 1 
    }


    test auto-resolve-1.5 {Ensits auto-resolve at auto-resolve time} -setup {
        parm set demsit.disable yes
        parmdb set dam.ENI.active no
        ted create NB1 BLUE SHIA
        ensit mutate create [dict merge $s2 [list rduration 2]]
    } -body {
        ted lock
        ted order SIM:RUN weeks 4 block yes

        ted query {SELECT * FROM ensits}
    } -cleanup {
        cleanup
    } -result {
s kind    stype   driver_id n   coverage state ts tc change   flist g    location inception resolver rduration rdriver_id 
- ------- ------- --------- --- -------- ----- -- -- -------- ----- ---- -------- --------- -------- --------- ---------- 
1 ::ensit COMMOUT 1000      NB1 0.5      ENDED 1  3  RESOLVED ALL   NONE 100 100  0         BLUE     2         1001       
    }



    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
    parm set dam.UNEMP.active yes
}

namespace delete ::athena_test::tests::









