<<manpage {simlib(n) gram2(n)} "Generalized Regional Analysis Model">>

<<section SYNOPSIS>>

<pre>
package require simlib 2.0
namespace import ::simlib::*
</pre>

<<swallow {
# So we can get enum docs.
package require simlib 2.0
namespace import ::simlib::*
}>>

<<itemlist>>

<<section DESCRIPTION>>

<<xref gram2(n)>> is the Tcl API for V2.0 of the Generalized Regional
Analysis Model (GRAM).  (See <<xref gram(n)>> for V1.0.)  GRAM models
group satisfaction and inter-group cooperation; see the Mars Analyst's
Guide for full details.

<<section "DATABASE SCHEMA">>

gram2(n) stores almost all of its working data in an
<<xref sqldocument(n)>> "run-time database", or RDB.  
The names of all of the tables, views, indices, and so forth defined
by GRAM begin with the string "gram_".<p>

Other modules may query any of the tables as needed, but
should not alter them. Some relevant semantics:<p>

<ul>
  <li> All cooperation and satisfaction curves are stored in the
       <b>gram_curves</b> table, with ancillary data in the
       <b>gram_gc</b> and <b>gram_coop_fg</b> tables respectively.<p>

  <li> The <b>gram_sat</b> and <b>gram_coop</b> views are a convenient
       way to query the satisfaction and cooperation curves.<p>

  <li> The <b>gram_sat_contribs</b> and <b>gram_coop_contribs</b> views
       are a convenient way to query the history of contributions to
       the satisfaction and cooperation curves.<p>

  <li> The <b>gram_sat_effects</b> and <b>gram_coop_effects</b> views
       are a convenient way to query the level and slope effects
       generated for the drivers that affect
       satisfaction and cooperation.  Note that effects which have
       expired are not deleted from the <b>gram_effects</b> table in
       the database.  Instead, the <b>active</b> attribute is set to
       0.<p>

  <li> Neighborhood and group moods may be read from the
       <b>gram_n</b> and <b>gram_g</b> tables.
</ul><p>

gram2(n) registers the following schema definitions with
<<xref sqldocument(n)>>:<p>

<pre>
<<::simlib::gram sqlsection schema>>
</pre>

<<section "LOADING DATA">>

The client is reponsible for providing a <code>-loadcmd</code>, which
will load input data into GRAM using the <<iref load>> family of
commands.  Each of these commands accepts a list of one kind of GRAM
entity; they be called in the following order:<p>

<ul>
  <li> <<iref load nbhoods>>
  <li> <<iref load nbrel>>
  <li> <<iref load civg>>
  <li> <<iref load civrel>>
  <li> <<iref load concerns>>
  <li> <<iref load sat>>
  <li> <<iref load frcg>>
  <li> <<iref load frcrel>>
  <li> <<iref load coop>>
</ul>

Note that these commands may only be called from a <code>-loadcmd</code>.<p>

GRAM input data typically comes from RDB tables; hence, the
<<iref load>> commands are designed to accept the result of an RDB
query as input.  The <code>-loadcmd</code> code to load the 
neighborhood relationship data might look like this:<p>

<pre>
    proc MyLoadCommand {gram} {
        ...
        $gram load nbrel {*}[$rdb eval {
            SELECT m, n, proximity, effects_delay
            FROM db_mn
            ORDER BY m, n;
        }]
        ...
    }
</pre>

In previous versions of GRAM, the database was populated automatically
with default neighborhood relationships, initial satisfactions, group
relationships, and initial cooperations, and consequently, only
non-default entities needed to be passed to the related <<iref load>>
commands.  This capability was never used, and has been removed.  It
is now necessary for the client to provide the full set of information
for to each <<iref load>> command.<p>

<<section "CONFIGURATION PARAMETERS">>

gram2(n) is a <<xref parm(i)>>, and defines the following configuration
parameters.  The <<iref gram parm>> subcommand can be used to set and query
their values.<p>

<<ehtml expand [::simlib::gram parm manpage]>>

<<subsection "Effect Epsilon">>

The <b>gram.epsilon</b> parameter, a floating point
value nominally set to 0.1, determines when level and slope effect
magnitudes are "small".<p>

When scheduling level effects, effects with a <i>limit</i>
less than or equal to <b>gram.epsilon</b> are
treated as step changes taking one tick; the entire value is added to
satisfaction 
the first time the effect is processed.  Larger effects are scheduled
so that the remaining contribution at the scheduled end time is
exactly <b>gram.epsilon</b>.<p>

Slope effects are handled differently.  Any slope effect whose slope
is less than or equal to <b>gram.epsilon</b> is
treated as equivalent to 0.0.  This prevents insignificant
indirect effects in other neighborhoods from harming performance.<p>

<<subsection "Proximity Limit">>

When a slope or level effect is scheduled, it may have indirect
effects in the same neighborhood (<b>here</b>), in nearby
neighborhoods (<b>near</b>), and in faraway neighborhoods
(<b>far</b>), where neighborhood proximity is defined by the
<b>proximity</b> column of the <i>gram_mn</i> table.<p>
The proximity limit, <b>gram.proxlimit</b>, limits the distance at which
indirect effects will be felt.  It may take these values:<p>

<table border="0" cellspacing="2">

<tr align="top">
<td><b>none</b></td>
<td>
No indirect effects are allowed.
</td>
</tr>

<tr align="top">
<td><b>here</b></td>
<td>
Indirect effects may be scheduled in the same neighborhood.
</td>
</tr>

<tr align="top">
<td><b>near</b></td>
<td>
Indirect effects may be scheduled in the same neighborhood and
in nearby neighborhoods.
</td>
</tr>

<tr align="top">
<td><b>far</b></td>
<td>
<b>(Default)</b> Indirect effects may be scheduled here, in nearby
neighborhoods, and in faraway neighborhoods.
</td>
</tr>

</table><p>

By default, the proximity limit is <b>far</b>, meaning that all
indirect effects are allowed.<p>

If the proximity limit is reduced, no indirect effects that exceed
the limit will be scheduled, and existing indirect effects that exceed
the limit will be marked inactive at the next <<iref advance>>.<p>

<<section COMMANDS>>

This module defines the following command:<p>

<<deflist commands>>

<<defitem gram {gram <i>name ?options...?</i>}>>

Creates a new <<iref gram>> object named <i>name</i>. The object is
represented as a new Tcl command in the caller's scope;
<<iref gram>> returns the fully-qualified form of the
<i>name</i>.  The <code>-loadcmd</code> is called and the model
fully initialized, as if <<iref init>> had been called with the
<code>-reload</code> option.<p>

<<iref gram>> takes the following options:<p>

<<deflist gram options>>

<<defopt {-clock <i>clock</i>}>>

Specifies the name of a <<xref simclock(n)>> object which will
govern gram2(n)'s simulation time.<p>

This option must be set at creation time, and cannot be changed
thereafter.<p>

<<defopt {-rdb <i>name</i>}>>

Specifies the name of an <<xref sqldocument(n)>> object
which gram2(n) will use to store its data.
See <<xref "DATABASE SCHEMA">>.<p>

Multiple instances of gram2(n) must be created in distinct RDBs.<p>

This option must be set at creation time, and cannot be changed
thereafter.<p>

<<defopt {-loadcmd <i>cmd</i>}>>

Defines a command which will populate the GRAM tables with data.  The
command must take a single additional argument, the name of the
instance of <<xref gram2(n)>> in question.  See
<<xref "LOADING DATA">> for more details.<p>

<<defopt {-logger <i>name</i>}>>

The name of the <<xref logger(n)>> object to use to log GRAM
activity.  If no -logger is specified, no logging is done.  The
-logger may be changed at any time; set it to {} to disable logging by
this object.<p>

<<defopt {-logcomponent <i>name</i>}>>

The component name to pass to the <code>-logger</code> object when
logging messages; defaults to "gram".<p>

<</deflist gram options>>

<<defitem {gram parm} {gram parm <i>subcommand</i> ?<i>args..</i>?}>>

The <<iref gram parm>> subcommand gives access to the gram2(n) module's
configuration <<xref parmset(n)>>; see
<<xref "CONFIGURATION PARAMETERS">> for details.  The subcommands
of <<iref gram parm>> are exactly those of <<xref parmset(n)>>
instances.<p>

<<defitem {gram sqlsection} {gram sqlsection <i>subcommand</i>}>>

gram2(n) is an <<xref sqlsection(i)>>, as it defines
schema entities (see <<xref "DATABASE SCHEMA">>).
See <<xref sqlsection(i)>> for a description
of this method's subcommands.<p>

<</deflist commands>>

<<section "INSTANCE COMMAND">>

<<deflist instance>>

<<defitem cget {$obj cget <i>option</i>}>>

Returns the value of the specified <i>option</i>.<p>

<<defitem configure {$obj configure <i>option value</i>}>>

Sets the <i>value</i> of the specified <i>option</i> (if the option is
not read-only).<p>

<<defitem init {$obj init ?-reload?}>>

Resets gram2(n) to the initial satisfaction and cooperation levels,
restoring all variables to their initial values and deleting all
history.  The simulation time is reset to the
<code>-simclock</code>'s current time, which will be used as
the baseline for the next <<iref advance>>.<p>

If <code>-reload</code> is specified, the object's
<code>-loadcmd</code> will be called to reload all of the GRAM input
data from scratch; otherwise it will work from its cached (and
possibly modified) copy of that data.<p>

<<defitem initialized {$obj initialized}>>

Returns 1 if either <<iref init>> or <<iref restore>> has been called
such this instance's RDB tables are populated and it is capable of
advancing time, and 0 otherwise.<p>

<<defitem clear {$obj clear}>>

Returns the instance of gram2(n) to its state at creation: the RDB
tables are cleared, and the in-memory variables are returned to their
initial values.<p>

<<defitem load {$obj load <i>subcommand</i> ?<i>args...</i>?}>>

The <<iref load>> family of subcommands is used to load input data
into GRAM.  See <<xref "LOADING DATA">> for more information.  The
<code>-loadcmd</code> must call each of the <<iref load>> commands, in
the order shown here.<p>

<<deflist load>>

<<defitem "load nbhoods" {$obj load nbhoods <i>n</i> ?<i>n</i>...?}>>

Specifies the set of neighborhood names.  Requires at least one name.
The names should be pre-sorted in alphabetical order.<p>

<<defitem "load nbrel" {$obj load nbrel ?<i>m n proximity effects_delay</i>...?}>>

This command is used to specify the set of neighborhood
relationships.<p>

<<defitem "load civg" {$obj load civg <i>g n population</i> ?<i>g n population</i>...?}>>

Specifies the set of civilian groups, with their neighborhoods of
residence and their populations.  The groups
should be sorted by name.  There should be at least one group.<p>

<<defitem "load civrel" {$obj load civrel ?<i>f g rel</i>...?}>>

This command is used to specify the set of civilian relationship
data.<p>

<<defitem "load concerns" {$obj load concerns <i>name gtype</i> ?<i>name gtype</i>...?}>>

Specifies the set of satisfaction concerns, sorted by name.<p>

<<defitem "load sat" {$obj load sat ?<i>g c sat0 saliency</i>...?}>>

This command is used to specify the set of satisfaction
data.<p>

<<defitem "load frcg" {$obj load frcg <i>g</i> ?<i>g</i>...?}>>

Specifies the set of force groups, sorted by name.
There should be at least one group.<p>

<<defitem "load frcrel" {$obj load frcrel ?<i>f g rel</i>...?}>>

This command is used to specify the set of force group to force
group relationship data.<p>

<<defitem "load coop" {$obj load coop ?<i>f g coop0</i>...?}>>

This command is used to specify the set of initial
cooperation values for each civilian group/force group pair.<p>

<</deflist load>>

<<defitem update {$obj update <i>subcommand</i> ?<i>args...</i>?}>>

The <<iref update>> family of subcommands is used to update selected
scenario data after the initial load.<p>

<<deflist update>>

<<defitem "update population" {$obj update population ?<i>g population</i>...?}>>

This command updates the population of civilian groups
for the specified <i>g</i>, and <i>population</i> pairs
specified on the command line.<p>

<b>NOTE:</b>  This command is optimized for speed, and consequently
does little error checking.  The following constraints apply:<p>

<ul>
  <li> Only civilian groups are allowed.
  <li> Groups must not be assigned a population of zero.
</ul><p>

<</deflist update>>

<<defitem advance {$obj advance}>>
Advances the simulation time to the time returned by the
simulation <code>-clock</code>, and recomputes the current
satisfaction levels.  Any scheduled slope and level
effects will contribute an increment determined by the simulation
times before and after the advance.<p>

<<defitem time {$obj time}>>
Returns the current simulation time.  Note that simulation time is
expressed in ticks since T-zero.<p>

<<defitem civgroup {$obj civgroup <i>subcommand</i> ?<i>args...</i>?}>>

This family of subcommands is used to manipulate and query
civilian groups.<p>

<<deflist civgroup>>

<<defitem "civgroup alive" {$obj civgroup alive ?<i>n</i>?}>>

Returns a list of the names of all living civilian groups, i.e.,
those with non-zero population.  If <i>n</i> is given, it should be
the name of a neighborhood; the output will be limited to those
living groups resident in <i>n</i>.<p>

<<defitem "civgroup dead" {$obj civgroup dead ?<i>n</i>?}>>

Returns a list of the names of all dead civilian groups, i.e.,
those with zero population.  If <i>n</i> is given, it should be
the name of a neighborhood; the output will be limited to those
dead groups resident in <i>n</i>.<p>

<<defitem "civgroup get" {$obj civgroup get <i>g</i> ?<i>field</i>?}>>

Returns a dictionary of CIV group <i>g</i>'s data in the
<b>gram_g</b> table.  If <i>field</i> is given, returns the
value of the particular field.<p>

This command is useful when only one group is of interested; but use a
direct query on <b>gram_g</b> rather than using this command in a loop.<p>

<<defitem "civgroup move" {$obj civgroup move <i>g n</i>}>>

Moves group <i>g</i> to neighborhood <i>n</i>.  All pending level and
slope effects on <i>g</i> are terminated immediately.  It is up to the
client simulation to apply any relevant drivers to <i>g</i> in its new
home.<p>

<<defitem "civgroup names" {$obj civgroup names ?<i>n</i>?}>>

Returns a list of the names of all defined civilian groups, alive or
dead.  If <i>n</i> is given, it should be the name of a neighborhood;
the output will be limited to those groups resident in <i>n</i>.<p>

<<defitem "civgroup split" {$obj civgroup split <i>parent g n population</i>}>>

Creates new civilian group <i>g</i> as a child of group
<i>parent</i>.  Group <i>g</i> will be reside in neighborhood
<i>n</i>.  The specified <i>population</i> will be transferred from
<i>parent</i> to <i>g</i>; note that <i>parent</i> must have at
least <i>population</i> people before the split, but may have
zero after.<p>

Group <i>g</i> will have the same attitudes and relationships as its
<i>parent</i>.  It is up to the client simulation to apply any relevant
drivers to <i>g</i>.<p>

<<defitem "civgroup transfer" {$obj civgroup transfer <i>driver e f population</i>}>>

Transfers <i>population</i> people from civilian group <i>e</i> to
group <i>f</i>, which must have a common ancestor with <i>e</i>.
Group <i>e</i> must have at least <i>population</i>
people prior to the transfer, but may have zero after.<p>

Group <i>f</i>'s attitudes will be adjusted to reflect the attitudes of
the incoming population, based on the relative proportion of the
newcomers to the existing population.  The adjustments will be
attributed to the specified <i>driver</i>.<p>

It is up to the client simulation to apply any other relevant drivers
to <i>f</i>.<p>

<</deflist civgroup>>

<<defitem driver {$obj driver <i>subcommand</i> ?<i>args...</i>?}>>

This family of subcommands is used to create new driver IDs
and to set and query the data items associated with them.<p>

<<deflist driver>>

<<defitem "driver add" {$obj driver add ?<i>options...</i>?}>>

Creates and returns a new driver ID.  The following options
can be specified at this time:<p>

<<deflist driver opt>>

<<defopt {-name <i>name</i>}>>

A short name for the driver; defaults to the driver ID itself.<p>

<<defopt {-dtype <i>dtype</i>}>>

The driver type, typically the name of a rule set.<p>

<<defopt {-oneliner <i>text</i>}>>

A one-line description of the driver; defaults to
"unknown".<p>

<</deflist driver opt>>

<<defitem "driver configure" {$obj driver configure <i>driver</i> ?<i>options...</i>?}>>

Configures the values of any of the options listed under <<iref driver add>>.<p>

<<defitem "driver cget" {$obj driver cget <i>driver option</i>}>>

Queries the value of the any of the options listed under <<iref driver add>>.
It's more common, however, to access these values as part of a direct
database query.<p>

<<defitem "driver exists" {$obj driver exists <i>driver</i>}>>

Returns 1 if the <i>driver</i> exists, and 0 otherwise.<p>

<<defitem "driver validate" {$obj driver validate <i>driver</i> ?<i>prefix</i>?}>>

Validates the <i>driver</i>, throwing an error if it doesn't exist.
If <i>prefix</i> is given, it is used as a prefix on the error
message.<p>

<</deflist driver>>

<<defitem cancel {$obj cancel <i>driver</i> ?-delete?}>>

Cancels all level and slope inputs related to the <i>driver</i>.
Cancelling a driver causes its actual contributions to satisfaction
and cooperation to be deleted, almost but not quite as though the
driver had never occurred. (Drivers are not
independent; the existence of one affects the contributions of others
to the same curve.)<p>

By default, cancelled drivers are marked as "CANCELLED" and retained
in the RDB; this ensures that driver IDs are not reused.  If the
<code>-delete</code> flag is specified, cancelled drivers are deleted
from the RDB.  Note that new drivers are given an ID one more than
the highest driver ID in the RDB; thus, if the driver with the highest
ID is cancelled with <code>-delete</code>, its ID will be reused by
the next driver.  (This is convenient for "undoing" an action that
created a driver.)<p>

<<defitem terminate {$obj terminate <i>driver</i>}>>

Terminates all slope inputs related to the <i>driver</i>,
just as though a slope of 0.0 was explicitly scheduled for each.  This
command is thus a convenient way of terminating a situation's slope effects
when the situation ends or is disabled.<p>

<<defitem sat.gc {$obj sat.gc <i>g c</i>}>>

Returns group <i>g</i>'s satisfaction with respect to concern
<i>c</i>.<p>

<<defitem sat.n {$obj sat.n <i>n</i>}>>

Returns the mood (rolled-up satisfaction across groups and concerns)
of neighborhood <i>n</i>.<p>

<<defitem sat.g {$obj sat.g <i>g</i>}>>

Returns group <i>g</i>'s mood (its rolled-up satisfaction across
concerns).<p>

<<defitem coop.fg {$obj coop.fg <i>f g</i>}>>

Returns civilian group <i>f</i>'s cooperation with force group <i>g</i>.<p>

<<defitem sat {$obj sat <i>subcommand</i> ?<i>args..</i>?}>>

The subcommands of the <<iref sat>> command are used to adjust and
submit inputs for the satisfaction curves.<p>

<<deflist sat>>

<<defitem {sat adjust} {$obj sat adjust <i>driver g c mag</i>}>>

Adjusts civilian group <i>g</i>'s satisfaction with concern <i>c</i>
by <i>mag</i>.  Group <i>g</i> must be alive, i.e., have non-zero
population.  The adjustment is related to
the specified <i>driver</i>. The <i>g</i> argument is the name of a
CIV group; <i>c</i> is the name of a concern.  The <i>mag</i> is a
<<xref simtypes(n) qmag>> value.  The specified satisfaction curve is
then clamped to the range (-100.0, +100.0).<p>

The <i>g</i> and <i>c</i> arguments may also be passed a
wildcard, "*"; this means that the adjustment is to be made for all
entities of that type.<p>

After making the adjustments, GRAM recomputes all satisfaction
roll-ups.<p>

The command returns an <i>input</i>, a serial number that increments
with each input made for this <i>driver</i>.<p>

<<defitem {sat level} {$obj sat level <i>driver ts g c limit days</i> ?<i>options...</i>?}>>

Schedules a satisfaction level input.  The input is for
the specific <i>driver</i>, and begins to take effect at time <i>ts</i>,
which should be no earlier than the current simulation time.  It affects
CIV <i>g</i> and concern <i>c</i>.<p>

The input has a maximum satisfaction change of <i>limit</i>
(a <<xref simtypes(n) qmag>> value), and a
realization time of <i>days</i>
(a <<xref simtypes(n) qduration>> value).  If <i>days</i> is less than
one tick, it will be treated as thought it were one tick.<p>

The input is decomposed into its direct effect on group <i>g</i>
and its indirect effects on the other civilian groups.<p>

The command returns an <i>input</i>, a serial number that increments
with each input made for this <i>driver</i>.<p>

The options are as follows:<p>

<<deflist sat level options>>

<<defopt {-cause <i>cause</i>}>>

Specifies the <i>cause</i> of this input.  When multiple direct and
indirect effects with the same <i>cause</i> target a particular
<i>n</i>, <i>g</i>, and <i>c</i>, only the maximum
positive and maximum negative effects actually take effect.<p>

<<defopt {-s <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhood <i>n</i> itself.
Defaults to 1.0.<p>

<<defopt {-p <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>near</b> to neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-q <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>far</b> from neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-athresh <i>threshold</i>}>>

The ascending threshold, a real number between -100.0 and 100.0.
Defaults to 100.0.  Positive direct and indirect
effects of this input will be ignored if the current value of the affected
curve is greater than or equal to <i>threshold</i>.<p>

<<defopt {-dthresh <i>threshold</i>}>>

The descending threshold, a real number between -100.0 and 100.0.
Defaults to -100.0.  Negative direct and indirect
effects of this input will be ignored if the current value of the affected
curve is less than or equal to <i>threshold</i>.<p>

<<defopt {-allowdead}>>

Ordinarily, an input given to a dead civilian group (a group with
zero population) will cause gram2(n) to throw an error.  If this
option is specified, the input will be accepted and indirect effects
will be computed normally.  (There will be no direct effect on the
dead group itself.)

<</deflist sat level options>>

<<defitem {sat set} {$obj sat set <i>driver g c sat</i> ?-undo?}>>

Sets civilian group <i>g</i>'s satisfaction with concern <i>c</i>
to <i>sat</i>.  Group <i>g</i> must be alive, i.e., have non-zero
population.  The adjustment is related to
the specified <i>driver</i>.  The <i>sat</i> is a <<xref simtypes(n) qsat>>
value.<p>

The <i>g</i> and <i>c</i> arguments may also be passed a
wildcard, "*"; this means that the adjustment is to be made for all
entities of that type.<p>

After making the adjustments, GRAM recomputes all satisfaction
roll-ups.<p>

By default, the command returns an <i>input</i>, a serial number
that increments with each input made for this <i>driver</i>.  If the
<code>-undo</code> flag is given, the command decrements the
<i>esinput</i> counter, and returns the empty string.  <b>NOTE:</b>
the <code>-undo</code> flag is a stopgap measure to allow Athena to
use <<iref sat set>> to undo particular calls to <<iref sat adjust>>
and <<iref sat set>>.<p>

<<defitem {sat slope} {$obj sat slope <i>driver ts g c slope</i> ?<i>options...</i>?}>>

Schedules a satisfaction slope input.  The input is for
the specific <i>driver</i>, and begins to take effect at time <i>ts</i>,
which should be no earlier than the current simulation time.  It affects
CIV group <i>g</i> and concern <i>c</i>.<p>

The input has a nominal satisfaction change per day, the <i>slope</i>,
a <<xref simtypes(n) qmag>> value.<p>

The input is decomposed into its direct effect on group <i>g</i>
and its indirect effects on the other civilian groups.<p>


Once scheduled, a slope input remain active with the specified
<i>slope</i> until one of the following things happens:<p>

<ul>
  <li> A new input is entered for the same <i>driver</i>, 
       <i>g</i>, <i>c</i>, and <i>cause</i>; the new <i>slope</i> then
       replaces the old <i>slope</i>.  If the <i>slope</i> is 0.0,
       then the input and its effects are terminated.  (Note that
       <<iref terminate>> has the same effect.)<p>

  <li> The <i>driver</i> is cancelled.<p>
</ul>

The command returns an <i>input ID</i>, a serial number that increments
with each input made for this <i>driver</i>.<p>

The options are as follows:<p>

<<deflist sat slope options>>

<<defopt {-cause <i>cause</i>}>>

Specifies the <i>cause</i> of this input.  When multiple direct and
indirect effects with the same <i>cause</i> target a particular
<i>n</i>, <i>g</i>, and <i>c</i>, only the maximum
positive and maximum negative effects actually take effect.<p>

<<defopt {-s <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhood <i>n</i> itself.
Defaults to 1.0.<p>

<<defopt {-p <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>near</b> to neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-q <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>far</b> from neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-athresh <i>threshold</i>}>>

The ascending threshold, a real number between -100.0 and 100.0.
Defaults to 100.0.  Positive direct and indirect
effects of this input will be ignored if the current value of the affected
curve is greater than or equal to <i>threshold</i>.<p>

<<defopt {-dthresh <i>threshold</i>}>>

The descending threshold, a real number between -100.0 and 100.0.
Defaults to -100.0.  Negative direct and indirect
effects of this input will be ignored if the current value of the affected
curve is less than or equal to <i>threshold</i>.<p>

<<defopt {-allowdead}>>

Ordinarily, an input given to a dead civilian group (a group with
zero population) will cause gram2(n) to throw an error.  If this
option is specified, the input will be accepted and indirect effects
will be computed normally.  (There will be no direct effect on the
dead group itself.)

<</deflist sat slope options>>

<<defitem {sat drivers} {$obj sat drivers ?<i>option value...</i>?}>>

Aggregates the contribution of each driver to each satisfaction curve
over time, placing the results in the transient
<b>gram_sat_drivers</b> table, which has the following columns:
<b>driver</b>, <b>n</b>, <b>g</b>, <b>c</b>, and <b>acontrib</b>.  The
contents of the table persists until the next call to
<<iref sat drivers>>, or until the RDB is closed.<p>

By default, aggregates the total contribution of each driver to each
curve over all of the recorded history.  The following options can be
used to limit the scope of the results:<p>

<<deflist sat driver options>>

<<defopt {-nbhood <i>n</i>}>>

Limits the results to the neighborhood with name <i>n</i>, or all
neighborhoods if <i>n</i> is "*" (the default).<p>

<<defopt {-group <i>g</i>}>>

Limits the results to the group with name <i>g</i>, or all
groups if <i>g</i> is "*" (the default).<p>

<<defopt {-concern <i>c</i>}>>

Limits the results to the concern with name <i>c</i>, or all
concerns if <i>c</i> is "*" (the default).<p>

If <i>c</i> is the special value <b>mood</b>, then results will be
computed for all concerns, and then the contribution to mood will be
rolled-up for each driver, neighborhood, and group.  This contribution
will appear in the table with a value of <b>mood</b> in the <b>c</b>
column.<p>

<<defopt {-start <i>t0</i>}>>

Limits the results to the time period starting at <i>t0</i>.  Defaults
to the beginning of the recorded history.<p>

<<defopt {-end <i>t1</i>}>>

Limits the results to the time period ending at <i>t1</i>.  Defaults
to the end of the recorded history (i.e., the current time).<p>

<</deflist sat driver options>>

<</deflist sat>>

<<defitem coop {$obj coop <i>subcommand</i> ?<i>args..</i>?}>>

The subcommands of the <<iref coop>> command are used to adjust and
submit inputs for the cooperation curves.<p>

<<deflist coop>>

<<defitem {coop adjust} {$obj coop adjust <i>driver f g mag</i>}>>

Adjusts CIV group <i>f</i>'s cooperation with FRC group <i>g</i>
by <i>mag</i>.  Group <i>f</i> must be alive, i.e., have non-zero
population.  The adjustment is related to
the specific <i>driver</i>.  The <i>mag</i> is a
<<xref simtypes(n) qmag>> value.  The specified cooperation curve is
then clamped to the range 
(0.0, +100.0).<p>

The <i>f</i> and <i>g</i> arguments may also be passed a
wildcard, "*"; this means that the adjustment is to be made for all
entities of that type.<p>

After the adjustments are made, cooperation roll-ups are computed.<p>

The command returns an <i>input</i>, a serial number
that increments with each input made for this <i>driver</i>.<p>

<<defitem {coop level} {$obj coop level <i>driver ts f g limit days</i> ?<i>options...</i>?}>>

Schedules a cooperation level input.  The input is for
the specific <i>driver</i>, and begins to take effect at time <i>ts</i>,
which should be no earlier than the current simulation time.  It affects
CIV group <i>f</i> and FRC group <i>g</i>.<p>

The input has a maximum cooperation change of <i>limit</i>
(a <<xref simtypes(n) qmag>> value), and a
realization time of <i>days</i>
(a <<xref simtypes(n) qduration>> value).  If <i>days</i> is less than
one tick, it will be treated as thought it were one tick.<p>

The input is decomposed into its direct effect on <i>f</i>'s
cooperation with group <i>g</i>, and its indirect effects on
other CIV groups' cooperation with other FRC groups.<p>

The command returns an <i>input</i>, a serial number that increments
with each input made for this <i>driver</i>.<p>

The options are as follows:<p>

<<deflist coop level options>>

<<defopt {-cause <i>cause</i>}>>

Specifies the <i>cause</i> of this input.  When multiple direct and
indirect effects with the same <i>cause</i> target a particular
<i>n</i>, <i>f</i>, and <i>g</i>, only the maximum
positive and maximum negative effects actually take effect.<p>

<<defopt {-s <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhood <i>n</i> itself.
Defaults to 1.0.<p>

<<defopt {-p <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>near</b> to neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-q <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>far</b> from neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-athresh <i>threshold</i>}>>

The ascending threshold, a real number between 0.0 and 100.0.
Defaults to 100.0.  Positive direct and indirect
effects of this input will be ignored if the current value of the affected
curve is greater than or equal to <i>threshold</i>.<p>

<<defopt {-dthresh <i>threshold</i>}>>

The descending threshold, a real number between 0.0 and 100.0.
Defaults to 0.0.  Negative direct and indirect
effects of this input will be ignored if the current value of the affected
curve is less than or equal to <i>threshold</i>.<p>

<<defopt {-allowdead}>>

Ordinarily, an input given to a dead civilian group (a group with
zero population) will cause gram2(n) to throw an error.  If this
option is specified, the input will be accepted and indirect effects
will be computed normally.  (There will be no direct effect on the
dead group itself.)

<</deflist coop level options>>

<<defitem {coop set} {$obj coop set <i>driver f g coop</i> ?-undo?}>>

Sets CIV group <i>f</i>'s cooperation with FRC group <i>g</i>
to <i>coop</i>.  Group <i>f</i> must be alive, i.e., have non-zero
population.  The adjustment is related to
the specific <i>driver</i>.
The <i>coop</i> is a <<xref simtypes(n) qcooperation>> value.<p>

The <i>f</i> and <i>g</i> arguments may also be passed a
wildcard, "*"; this means that the adjustment is to be made for all
entities of that type.<p>

After the adjustments are made, cooperation roll-ups are computed.<p>

By default, the command returns an <i>input</i>, a serial number
that increments with each input made for this <i>driver</i>.  If the
<code>-undo</code> flag is given, the command decrements the
<i>esinput</i> counter, and returns the empty string.  <b>NOTE:</b>
the <code>-undo</code> flag is a stopgap measure to allow Athena to
use <<iref coop set>> to undo particular calls to <<iref coop adjust>>
and <<iref coop set>>.<p>


<<defitem {coop slope} {$obj coop slope <i>driver ts f g slope</i> ?<i>options...</i>?}>>

Schedules a cooperation slope input.  The input is for
the specific <i>driver</i>, and begins to take effect at time <i>ts</i>,
which should be no earlier than the current simulation time.  It affects
CIV group <i>f</i> and FRC group <i>g</i>.<p>

The input has a nominal cooperation change per day, the <i>slope</i>,
a <<xref simtypes(n) qmag>> value.<p>

The input is decomposed into its direct effect on <i>f</i>'s
cooperation with group <i>g</i>, and its indirect effects on
other civilian groups' cooperation with other FRC groups.<p>

<ul>
  <li> A new input is entered for the same <i>driver</i>, 
       <i>f</i>, <i>g</i>, and <i>cause</i>; the new <i>slope</i> then
       replaces the old <i>slope</i>.  If the <i>slope</i> is 0.0,
       then the input and its effects are terminated.  (Note that
       <<iref terminate>> has the same effect.)<p>

  <li> The <i>driver</i> is cancelled.<p>
</ul>

The command returns an <i>input ID</i>, a serial number that increments
with each input made for this <i>driver</i>.<p>

The options are as follows:<p>

<<deflist coop slope options>>

<<defopt {-cause <i>cause</i>}>>

Specifies the <i>cause</i> of this input.  When multiple direct and
indirect effects with the same <i>cause</i> target a particular
<i>n</i>, <i>f</i>, and <i>g</i>, only the maximum
positive and maximum negative effects actually take effect.<p>

<<defopt {-s <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhood <i>n</i> itself.
Defaults to 1.0.<p>

<<defopt {-p <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>near</b> to neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-q <i>factor</i>}>>

A multiplicative factor between 0.0 and 1.0 inclusive; it determines
the strength of indirect effects in neighborhoods which are
<b>far</b> from neighborhood <i>n</i>.  Defaults to 0.0.<p>

<<defopt {-athresh <i>threshold</i>}>>

The ascending threshold, a real number between 0.0 and 100.0.
Defaults to 100.0.  Positive direct and indirect
effects of this input will be ignored if the current value of the affected
curve is greater than or equal to <i>threshold</i>.<p>

<<defopt {-dthresh <i>threshold</i>}>>

The descending threshold, a real number between 0.0 and 100.0.
Defaults to 0.0.  Negative direct and indirect
effects of this input will be ignored if the current value of the affected
curve is less than or equal to <i>threshold</i>.<p>

<<defopt {-allowdead}>>

Ordinarily, an input given to a dead civilian group (a group with
zero population) will cause gram2(n) to throw an error.  If this
option is specified, the input will be accepted and indirect effects
will be computed normally.  (There will be no direct effect on the
dead group itself.)

<</deflist coop slope options>>

<</deflist coop>>

<<defitem checkpoint {$obj checkpoint ?-saved?}>>

Returns the current state of the object's in-memory data; the engine
can later be restored to this state using <<iref restore>>.  See
<<xref saveable(i)>> for details.<p>

Note that the RDB must also be checkpointed as well.<p>

<<defitem restore {$obj restore <i>checkpoint</i> ?-saved?}>>

Restores the engine to a <i>checkpoint</i> produced by a previous call to
<<iref checkpoint>>.  See <<xref saveable(i)>> for details.<p>
<p>
Note that the RDB must be restored as well.<p>

<<defitem changed {$obj changed}>>

Indicates whether the object's <<xref saveable(i)>> data has changed
or not.<p>

<<defitem dump {$obj dump <i>subcommand</i> ?<i>args..</i>?}>>

The subcommands of the <<iref dump>> command are used to dump various
collections of debugging data.<p>

<<deflist dump>>

<<defitem "dump sat.gc" {$obj dump sat.gc ?options...?}>>

Dumps the contents of the <b>gram_sat</b> view for all
groups and concerns.  The following
options tailor the output:<p>

<<deflist options>>

<<defopt {-nbhood <i>n</i>}>>

Includes only the neighborhood named <i>n</i>.<p>

<<defopt {-group <i>g</i>}>>

Includes only the group named <i>g</i>.<p>

<</deflist options>>

<<defitem {dump sat} {$obj dump sat <i>subcommand</i> ?<i>args..</i>?}>>

The subcommands of the <<iref dump sat>> command dump collections
of satisfaction direct and indirect effects.<p>

<<deflist dump sat>>

<<defitem "dump sat levels" {$obj dump sat levels ?<i>driver</i>?}>>

Dumps a list of all scheduled satisfaction direct and indirect level
effects, in tabular format.  If <i>driver</i> is specified, dumps only
the effects related to that driver.<p>

<<defitem "dump sat level" {$obj dump sat level <i>g c</i>}>>

Dumps a list of all direct and indirect level effects which
currently affect the satisfaction for group <i>g</i>
and concern <i>c</i>. The effects are grouped by cause, so
that it's easy to determine that multiple effects with the same cause
are handled properly.<p>

<<defitem "dump sat slopes" {$obj dump sat slopes ?<i>driver</i>?}>>

Dumps a list of all scheduled satisfaction slope effects.  If
<i>driver</i> is specified, dumps only the effects
related to that driver.<p>

As of Mars 1.27, it is up to the application to define any desired
long-term trends; driver 0 is still reserved for this purpose.
Because there may be many slope effects associated with driver 0,
they are not included in the <<iref dump sat slopes>> output
unless <i>driver</i> is explicitly passed a 0.<p>

<<defitem "dump sat slope" {$obj dump sat slope <i>g c</i>}>>

Dumps a list of all active direct and indirect slope effects which
currently affect the satisfaction for group
<i>g</i> and concern <i>c</i>. The effects are grouped by cause, so
that it's easy to determine that multiple effects with the same cause
are handled properly.<p>

<</deflist dump sat>>

<<defitem "dump coop.fg" {$obj dump coop.fg ?options...?}>>

Dumps the contents of the <b>gram_coop</b> view for all
CIV groups and FRC groups.  The following
options tailor the output:<p>

<<deflist options>>

<<defopt {-nbhood <i>n</i>}>>

Includes only the neighborhood named <i>n</i>.<p>

<<defopt {-civ <i>f</i>}>>

Includes only the CIV group named <i>f</i>.<p>

<<defopt {-frc <i>g</i>}>>

Includes only the FRC group named <i>g</i>.<p>

<<defopt {-ids}>>

Includes the <b>curve_id</b> and <b>fg_id</b> fields from
<b>gram_coop</b>.<p>

<</deflist options>>

<<defitem {dump coop} {$obj dump coop <i>subcommand</i> ?<i>args..</i>?}>>

The subcommands of the <<iref dump coop>> command dump collections
of cooperation direct and indirect effects.<p>

<<deflist dump coop>>

<<defitem "dump coop levels" {$obj dump coop levels ?<i>driver</i>?}>>

Dumps a list of all scheduled cooperation direct and indirect level
effects, in tabular format.  If <i>driver</i> is specified, dumps only
the effects related to that driver.<p>

<<defitem "dump coop level" {$obj dump coop level <i>f g</i>}>>

Dumps a list of all direct and indirect level effects which
currently affect the cooperation for CIV group
<i>f</i> and FRC group <i>g</i>. The effects are grouped by cause, so
that it's easy to determine that multiple effects with the same cause
are handled properly.<p>

<<defitem "dump coop slopes" {$obj dump coop slopes ?<i>driver</i>?}>>

Dumps a list of all scheduled cooperation slope effects.  If
<i>driver</i> is specified, dumps only the effects
related to that driver.<p>

<<defitem "dump coop slope" {$obj dump coop slope <i>f g</i>}>>

Dumps a list of all active direct and indirect slope effects which
currently affect the cooperation for CIV group
<i>f</i> and FRC group <i>g</i>. The effects are grouped by cause, so
that it's easy to determine that multiple effects with the same cause
are handled properly.<p>

<</deflist dump coop>>


<</deflist dump>>


<</deflist instance>>


<<section ENVIRONMENT>>

This package requires Tcl 8.5 or later.

To use the package in a Tcl script, the environment variable
<code>TCLLIBPATH</code> must include the parent of the package
directory.

<<section AUTHOR>>

Will Duquette<p>

<<section HISTORY>>

Original package.

<</manpage>>
