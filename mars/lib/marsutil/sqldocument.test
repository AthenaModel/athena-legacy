# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    sqldocument.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Tcltest test suite for marsutil(n) sqldocument.tcl
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n)

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2 
    eval ::tcltest::configure $argv
}
 
#-----------------------------------------------------------------------
# Load the package to be tested

package require sqlite3
package require marsutil 1.0

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::marsutil::test {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Import the code to be tested
    namespace import ::marsutil::*

    #-------------------------------------------------------------------
    # Test harness

    # bprint text
    #
    # text     A block of text
    #
    # Pretty prints the block of text, to make formatting tests easier.

    proc bprint {text} {
        set text [string map [list ( < ) >] $text]
        return "\n$text\n    "
    }

    # cleanup
    #
    # This command cleans up after each test, returning the system
    # to a known state: a clean registry and no database objects.
    # It needs to be called only if the test changes either of these
    # things.
    
    proc cleanup {} {
        # FIRST, reset the registry back to just sqldocument itself
        set ::marsutil::sqldocument::registry ::marsutil::sqldocument

        # NEXT, destroy all open database objects
        foreach instance [sqldocument info instances] {
            $instance destroy
        }
    }

    # testsection
    #
    # A test sqlsection(i) module

    snit::type ::marsutil::test::testsection {
        typevariable schema {
            CREATE TABLE perm(a,b,c);
        }

        typevariable tempschema {
            CREATE TEMP TABLE temp(d,e,f);
        }

        typemethod {sqlsection schema} {} {
            return [::marsutil::outdent $schema]
        }

        typemethod {sqlsection tempschema} {} {
            return [::marsutil::outdent $tempschema]
        }

        typemethod {sqlsection tempdata} {} {
            return {
                temp {
                    {d 1 e 2 f 3}
                    {d 4 e 5 f 6}
                }
            }
        }

        typemethod {sqlsection functions} {} {
            set functions [list]

            lappend functions concat [list ::concat]

            return $functions
        }
    }

    # badsection
    #
    # A test sqlsection(i) module with a bad schema

    snit::type ::marsutil::test::badsection {
        typevariable schema {
            CREATE TABLE (a b c);
        }

        typemethod {sqlsection schema} {} {
            return [::marsutil::outdent $schema]
        }

        typemethod {sqlsection tempschema} {} {
            return ""
        }

        typemethod {sqlsection functions} {} {
            return ""
        }
    }

    # By default, sqldocument's registry will include all sqlsection(i) 
    # modules in marsutil(n).  This means that its contents will change as
    # as new modules are declared.  For testing, consequently, we want
    # to start with a clean registry--then, we'll register things 
    # ourselves.  So call cleanup to kick things off.

    cleanup

    #-------------------------------------------------------------------
    # sqlsection schema

    test sqlsection_schema-1.1 {Base schema is defined} -body {
        bprint [sqldocument sqlsection schema]
    } -result {

    }

    #-------------------------------------------------------------------
    # sqlsection tempschema

    test sqlsection_tempschema-1.1 {Base schema is defined} -body {
        bprint [sqldocument sqlsection tempschema]
    } -result {

    }

    #-------------------------------------------------------------------
    # sqlsection functions

    test sqlsection_functions-1.1 {Standard functions are defined} -body {
        sqldocument sqlsection functions
    } -result {error ::error format ::format joinlist ::join nonempty ::marsutil::sqldocument::NonEmpty percent ::marsutil::percent wallclock {::clock seconds}}

    #-------------------------------------------------------------------
    # register

    test register-1.1 {Adds sqlsection to registry} -body {
        sqldocument register ::foo
        set ::marsutil::sqldocument::registry
    } -cleanup {
        cleanup
    } -result {::marsutil::sqldocument ::foo}

    test register-1.2 {Duplicate sections are ignored} -body {
        sqldocument register ::foo
        sqldocument register ::foo
        sqldocument register ::foo
        set ::marsutil::sqldocument::registry
    } -cleanup {
        cleanup
    } -result {::marsutil::sqldocument ::foo}

    #-------------------------------------------------------------------
    # sections

    test sections-1.1 {Base registry contains just sqldocument} -body {
        sqldocument sections
    } -cleanup {
        cleanup
    } -result {::marsutil::sqldocument}

    test sections-1.2 {All registered sections are included} -body {
        sqldocument register ::foo
        sqldocument sections
    } -cleanup {
        cleanup
    } -result {::marsutil::sqldocument ::foo}

    #-------------------------------------------------------------------
    # Constructor

    test constructor-1.1 {Object is initially closed} -body {
        sqldocument db
        db isopen
    } -cleanup {
        cleanup
    } -result {0}

    test constructor-1.2 {Object initially has no file} -body {
        sqldocument db
        db dbfile
    } -cleanup {
        cleanup
    } -result {}

    test constructor-2.1 {Database object is initially null} -body {
        sqldocument db
        db eval {foo}
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {database is not open}

    #-------------------------------------------------------------------
    # -clock

    test clock-1.1 {-clock functions defines} -setup {
        ::marsutil::simclock reset
    } -body {
        sqldocument db -clock ::marsutil::simclock
        db open :memory:
        db eval {SELECT now(), tozulu(0)}
    } -cleanup {
        cleanup
    } -result {0 010000ZJAN70}

    #-------------------------------------------------------------------
    # open

    test open-1.1 {PRAGMA synchronous=OFF} -body {
        sqldocument db
        db open :memory:
        db eval {PRAGMA synchronous}
    } -cleanup {
        cleanup
    } -result {0}

    test open-1.2 {PRAGMA temp_store=MEMORY} -body {
        sqldocument db
        db open :memory:
        db eval {PRAGMA temp_store}
    } -cleanup {
        cleanup
    } -result {2}

    test open-1.3 {dbfile is set} -body {
        sqldocument db
        db open :memory:
        db dbfile
    } -cleanup {
        cleanup
    } -result {:memory:}

    test open-1.4 {isopen is true} -body {
        sqldocument db
        db open :memory:
        db isopen
    } -cleanup {
        cleanup
    } -result {1}

    test open-1.5 {Error: database already open} -body {
        sqldocument db
        db open :memory:
        db open :memory:
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {database is already open}

    test open-1.6 {Error: no file specified} -body {
        sqldocument db
        db open
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {database file name not specified}

    test open-1.7 {Can reopen previous database} -body {
        sqldocument db
        db open :memory:
        db close

        db open

        # Make sure that we think it's open and that there's
        # really a database attached.
        list [db isopen] [db eval {SELECT 1}]
    } -cleanup {
        cleanup
    } -result {1 1}

    # open-2.x: verify that the standard functions are defined automatically
    # when the database is opened.
    test open-2.1 {Standard function: format} -body {
        sqldocument db
        db open :memory:
        db onecolumn {SELECT format('%04d', 15)}
    } -cleanup {
        cleanup
    } -result {0015}

    test open-2.2 {Standard function: joinlist} -body {
        sqldocument db
        db open :memory:
        db onecolumn {SELECT joinlist('a b c', '+')}
    } -cleanup {
        cleanup
    } -result {a+b+c}

    test open-2.3 {Standard function: wallclock} -body {
        sqldocument db
        db open :memory:
        set now [db onecolumn {SELECT wallclock()}]
        expr {$now > 0}
    } -cleanup {
        cleanup
    } -result {1}

    test open-2.4 {Standard function: percent } -body {
        sqldocument db
        db open :memory:
        db onecolumn {SELECT percent(0.5)}
    } -cleanup {
        cleanup
    } -result { 50%}

    # open-3.x: Temp Schema and Functions from other sections
    test open-3.1 {Temp schema defined} -body {
        # FIRST, register an sqlsection with a temp schema
        sqldocument register ::marsutil::test::testsection

        # NEXT, open a document
        sqldocument db
        db open :memory:

        db eval {SELECT type, name FROM sqlite_temp_master}
    } -cleanup {
        cleanup
    } -result {table temp}

    test open-3.2 {Functions defined} -body {
        # FIRST, register an additional sqlsection with functions
        sqldocument register ::marsutil::test::testsection

        # NEXT, open a document
        sqldocument db
        db open :memory:

        db onecolumn {SELECT concat('a b', 'c d')}
    } -cleanup {
        cleanup
    } -result {a b c d}

    test open-3.3 {Temp Data defined} -body {
        # FIRST, register an additional sqlsection with temp data
        sqldocument register ::marsutil::test::testsection

        # NEXT, open a document
        sqldocument db
        db open :memory:

        db eval {SELECT d,e,f FROM temp}
    } -cleanup {
        cleanup
    } -result {1 2 3 4 5 6}
    

    #-------------------------------------------------------------------
    # clear

    test clear-1.1 {Error: database is not open} -body {
        sqldocument db
        db clear
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {database is not open}

    test clear-1.2 {Error: database is locked} -body {
        sqldocument db1
        db1 open test.db

        sqldocument db2
        db2 open test.db

        db1 eval {BEGIN TRANSACTION}
        db2 clear
    } -returnCodes {
        error
    } -cleanup {
        db1 eval {COMMIT TRANSACTION}
        cleanup
        removeFile test.db
    } -result {database is locked}

    test clear-1.3 {Error: could not initialize database} -body {
        sqldocument register ::marsutil::test::badsection
        sqldocument db
        db open :memory:
        db clear
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {could not initialize database: near "(": syntax error}

    test clear-1.4 {Base schema is defined} -body {
        sqldocument db
        db open :memory:
        db clear

        db eval {SELECT name FROM sqlite_master}
    } -cleanup {
        cleanup
    } -result {}

    test clear-1.5 {Section schema is defined} -body {
        sqldocument register ::marsutil::test::testsection
        sqldocument db
        db open :memory:
        db clear

        db eval {SELECT name FROM sqlite_master}
    } -cleanup {
        cleanup
    } -result {perm}

    test clear-1.6 {Temp schema is still defined} -body {
        sqldocument register ::marsutil::test::testsection
        sqldocument db
        db open :memory:
        db clear

        db eval {SELECT name FROM sqlite_temp_master}
    } -cleanup {
        cleanup
    } -result {temp}

    test clear-1.8 {functions remain defined} -body {
        sqldocument db
        db open :memory:
        db clear

        db onecolumn {SELECT format('%04d', 15)}
    } -cleanup {
        cleanup
    } -result {0015}

    test clear-1.9 {Non-schema tables are dropped} -body {
        sqldocument db
        db open :memory:

        db eval {CREATE TABLE foo(a,b,c)}
        set a [db eval {SELECT name FROM sqlite_master}]

        db clear
        set b [db eval {SELECT name FROM sqlite_master}]
        

        list $a $b
    } -cleanup {
        cleanup
    } -result {foo {}}

    test clear-1.10 {Schema tables are emptied} -body {
        sqldocument register ::marsutil::test::testsection
        sqldocument db
        db open :memory:
        db clear

        db eval {INSERT INTO perm(a,b,c) VALUES(1,2,3)}

        set a [db eval {SELECT COUNT(a) FROM perm}]

        db clear
        set b [db eval {SELECT COUNT(a) FROM perm}]

        # Clearing should delete the 1 record, yielding 0
        list $a $b
    } -cleanup {
        cleanup
    } -result {1 0}

    #-------------------------------------------------------------------
    # commit

    test commit-1.1 {Error: database is not open} -body {
        sqldocument db
        db commit
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {database is not open}

    test commit-1.2 {No commit except on request} -body {
        sqldocument db
        db open test.db
        db clear

        db eval {CREATE TABLE fred(a,b,c)}
        set a [db tables]

        # Close without committing
        db destroy
        sqldocument db
        db open test.db

        set b [db tables]

        # Should only see fred before closing
        list $a $b
    } -cleanup {
        cleanup
        removeFile test.db
    } -result {fred {}}

    test commit-1.3 {commit on request} -body {
        sqldocument db
        db open test.db
        db clear

        db eval {CREATE TABLE fred(a,b,c)}
        set a [db tables]

        # Commit and destroy
        db commit
        db destroy

        sqldocument db
        db open test.db

        set b [db tables]

        list $a $b
    } -cleanup {
        cleanup
        removeFile test.db
    } -result {fred fred}


    #-------------------------------------------------------------------
    # close

    test close-1.1 {Error: database is not open} -body {
        sqldocument db
        db close
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {database is not open}

    test close-1.2 {Commit on close} -body {
        sqldocument db
        db open test.db
        db clear

        db eval {CREATE TABLE fred(a,b,c)}
        set a [db tables]

        db close

        db open

        set b [db tables]

        list $a $b
    } -cleanup {
        cleanup
        removeFile test.db
    } -result {fred fred}

    #-------------------------------------------------------------------
    # lock/unlock/islocked

    test lock-1.1 {tables are unlocked by default} -body {
        sqldocument db
        db open :memory:

        db eval { CREATE TABLE fred(a,b,c); }
        db islocked fred
    } -cleanup {
        cleanup
    } -result {0}

    test lock-1.2 {islocked is true for locked tables} -body {
        sqldocument db
        db open :memory:

        db eval { CREATE TABLE fred(a,b,c); }
        db lock fred
        db islocked fred
    } -cleanup {
        cleanup
    } -result {1}

    test lock-1.3 {islocked is false once unlocked} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }
        db lock fred
        set a [db islocked fred]
        db unlock fred
        set b [db islocked fred]

        list $a $b
    } -cleanup {
        cleanup
    } -result {1 0}

    test lock-1.4 {can lock multiple tables at once} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }
        db eval { CREATE TABLE george(d,e,f); }

        db lock {fred george}
        list [db islocked fred] [db islocked george]
    } -cleanup {
        cleanup
    } -result {1 1}

    test lock-1.5 {can unlock multiple tables at once} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }
        db eval { CREATE TABLE george(d,e,f); }

        db lock {fred george}
        set a [list [db islocked fred] [db islocked george]]

        db unlock {fred george}
        set b [list [db islocked fred] [db islocked george]]

        list $a $b
    } -cleanup {
        cleanup
    } -result {{1 1} {0 0}}

    test lock-1.6 {can safely lock locked tables} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }
        db lock fred
        db lock fred
        db islocked fred
    } -cleanup {
        cleanup
    } -result {1}

    test lock-1.7 {can safely unlock unlocked tables} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }
        db unlock fred
        db unlock fred
        db islocked fred
    } -cleanup {
        cleanup
    } -result {0}

    test lock-1.8 {can't insert into a locked table} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }
        db lock fred

        db eval { INSERT INTO fred(a) VALUES(1) }
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Table "fred" is read-only}

    test lock-1.9 {can't update a locked table} -body {
        sqldocument db
        db open :memory:

        db eval { CREATE TABLE fred(a,b,c); }
        db eval { INSERT INTO fred(a) VALUES(1) }
        db lock fred

        db eval { UPDATE fred SET b=2; }
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Table "fred" is read-only}

    test lock-1.10 {can't delete from a locked table} -body {
        sqldocument db
        db open :memory:

        db eval { CREATE TABLE fred(a,b,c); }
        db eval { INSERT INTO fred(a) VALUES(1) }
        db lock fred

        db eval { DELETE FROM fred; }
    } -returnCodes {
        error
    } -cleanup {
        cleanup
    } -result {Table "fred" is read-only}

    test lock-1.11 {*can* drop a locked table} -body {
        sqldocument db
        db open :memory:

        db eval { CREATE TABLE fred(a,b,c); }
        db eval { INSERT INTO fred(a) VALUES(1) }
        db lock fred

        db eval { DROP TABLE fred; }
        db tables
    } -cleanup {
        cleanup
    } -result {}

    test lock-1.12 {can insert/update/delete once unlocked} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TABLE fred(a,b,c); }

        db lock fred
        db unlock fred

        db eval { INSERT INTO fred(a) VALUES(1) }
        db eval { UPDATE fred SET b=2; }
        db eval { DELETE FROM fred; }
    } -cleanup {
        cleanup
    } -result {}

    test lock-1.13 {can lock and unlock temporary tables} -body {
        sqldocument db
        db open :memory:
        db eval { CREATE TEMP TABLE fred(a,b,c); }

        db lock fred 
        set a [db islocked fred]

        db unlock fred
        set b [db islocked fred]

        list $a $b
    } -cleanup {
        cleanup
    } -result {1 0}


    #-------------------------------------------------------------------
    # Delegated Methods
    #
    # There's no need to test the delegated methods in detail.  All we
    # really need to do is verify that we are delegating the methods we
    # think we are.

    test delegated-1.1 {Non-* delegation} -body {
        sqldocument db
        set methods [db info methods]

        set count 0
        foreach name {saveas query tables schema mat} {
            if {[lsearch -exact $methods $name] == -1} {
                incr count
            }
        }

        set count
    } -cleanup {
        cleanup
    } -result {0}

    test delegated-1.2 {* delegation} -body {
        sqldocument db
        db open :memory:

        # Use a method delegated to *, and verify that there's no error.
        db eval {SELECT 1}
    } -cleanup {
        cleanup
    } -result {1}

    #-------------------------------------------------------------------
    # Standard Functions

    # TBD: The existence and nominal operation of the standard functions
    # are tested above, in open-2.x.  We should really have a full
    # test for each; however, as all of them are based on functions
    # test elsewhere, this should be good enough for now.



    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::marsutil::test







