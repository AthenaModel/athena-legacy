# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    order.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Tcltest test suite for marsutil(n) order(n)
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n)

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2 
    eval ::tcltest::configure $argv
}
 
#-----------------------------------------------------------------------
# Load the package to be tested

package require marsutil 1.0

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::marsutil::test {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Import the code to be tested
    namespace import ::marsutil::*

    #-------------------------------------------------------------------
    # Test Harness

    # acc -- Accumulator array; stores lists.
    #
    # log    - Log entries
    # orders - Traced orders
    # events - notifier(n) events

    variable acc

    # Enum type

    ::marsutil::enum ::marsutil::test::goodness {
        GOOD Good
        BAD  Bad
    }

    # codecatch cmd....
    #
    # Catches result of calling the command, expecting an error,
    # and returns the error message prefixed with the errorcode.

    proc codecatch {args} {
        if {![catch $args result]} {
            error "Expected error, got ok"
        }

        return "$::errorCode $result"
    }

    # errcatch cmd....
    #
    # Catches result of calling the command, expecting an error,
    # and returns the error message.

    proc errcatch {args} {
        if {![catch $args result]} {
            error "Expected error, got ok"
        }

        return $result
    }

    # Setup ?options?
    #
    # -passthru flag - Defines PASS:THRU order
    #
    # Other options are passed to order init.
    #
    # Initializes the order module and prepares for tests.

    proc setup {args} {
        variable acc
        
        if {[optval args -clockflag no]} {
            set clock [namespace current]::clock
        } else {
            set clock ""
        }

        simclockType clock

        sqldocument rdb -clock [namespace current]::clock
        rdb register ::marsutil::eventq
        rdb open :memory:
        rdb clear

        eventq init [namespace current]::rdb

        rdb eval {
            CREATE TABLE test_table(x PRIMARY KEY, y, z);
            INSERT INTO test_table VALUES(1,2,3);
        }

        set passthru [optval args -passthru 0]

        order init \
            -rdb      ::marsutil::test::rdb                 \
            -clock    $clock                                \
            -logcmd   {::marsutil::test::Accumulate log}    \
            -ordercmd {::marsutil::test::Accumulate orders} \
            {*}$args

        if {$passthru} {
            order define PASS:THRU {
                parm a text a
                parm b text b
                parm c text c
            } {
                array get parms
            }
        }

        notifier trace \
            {::marsutil::test::Accumulate events}

        array unset acc
        array set acc {
            log    ""
            orders ""
            events ""
        }
    }

    # cleanup
    #
    # Reset the order(n) module.
    proc cleanup {} {
        variable acc

        eventq restart
        eventq destroy *

        clock destroy

        order reset
        array unset acc
        rdb destroy
    }

    # Accumulate which args
    #
    # Add entry to accumulator.
    proc Accumulate {which args} {
        variable acc
        
        lappend acc($which) $args
    }

    # getacc which
    #
    # Returns the pretty-printed data

    proc getacc {which} {
        variable acc

        bprintlist $acc($which)
    }

    # NarrativeCmd args
    #
    # Order narrative; just reflects arguments.
    proc NarrativeCmd {args} {
        return $args
    }

    # AddStars text
    #
    # text - A text string
    #
    # Returns the text string with stars around it.
    
    proc AddStars {text} {
        return "*$text*"
    }

    # LogErrorCmd name emessage einfo
    #
    # name     - The order name
    # emessage - The error message
    # einfo    - The errorInfo (stack trace)

    proc LogErrorCmd {name emessage einfo} {
        Accumulate log "$name <$emessage>"
    }

    # bprint text
    #
    # text - A block of text
    #
    # Pretty prints the block of text, to make formatting tests easier.

    proc bprint {text} {
        return "\n$text    "
    }

    # pdict dict
    #
    # dict - A dictionary
    #
    # Block-prints the dict, or "*NULL*" if the list is empty.

    proc pdict {dict} {
        set list [list]

        set keywid [expr {[lmaxlen [dict keys $dict]] + 1}]

        dict for {key value} $dict {
            lappend list [format "%-*s <%s>" $keywid $key: $value]
        }

        return [bprintlist $list]
    }

    # bprintlist list
    #
    # list - A list of items
    #
    # Block-prints the list, or "*NULL*" if the list is empty.

    proc bprintlist {list} {
        if {[llength $list] == 0} {
            return *NULL*
        }

        foreach item $list {
            append result "        $item\n"
        }

        return [bprint $result]
    }


    #-------------------------------------------------------------------
    # init

    # Default option values

    test init-1.1 {Default option values} -setup {
        setup
        order reset
    } -body {
        order init -rdb NONESUCH

        pdict [order cget]
    }  -cleanup {
        cleanup
    } -result {
        -cancelstates: <*>
        -clock:        <>
        -logcmd:       <>
        -ordercmd:     <>
        -rdb:          <NONESUCH>
        -subject:      <::marsutil::order>
        -usedtable:    <>
    }


    test init-1.2 {Options are saved} -setup {
        setup
        order reset
    } -body {
        order init \
            -cancelstates {}                                 \
            -clock        A                                  \
            -logcmd       {::marsutil::test::Accumulate log} \
            -ordercmd     C                                  \
            -rdb          D                                  \
            -subject      E                                  \
            -usedtable    F

        pdict [order cget]
    }  -cleanup {
        cleanup
    } -result {
        -cancelstates: <>
        -clock:        <A>
        -logcmd:       <::marsutil::test::Accumulate log>
        -ordercmd:     <C>
        -rdb:          <D>
        -subject:      <E>
        -usedtable:    <F>
    }

    test init-1.3 {-rdb must be set} -setup {
        setup
        order reset
    } -body {
        errcatch order init
    }  -cleanup {
        cleanup
    } -result {-rdb is ""}

    test init-1.4 {Orders can be predefined} -setup {
        setup
        order define MY:ORDER {} {}
    } -body {
        order init
        order names
    }  -cleanup {
        cleanup
    } -result {MY:ORDER}

    test init-1.5 {If -clock is given, scheduling is available} -setup {
        setup
        order reset
    } -body {
        order init \
            -rdb   ::marsutil::test::rdb   \
            -clock ::marsutil::test::clock
        order names
    }  -cleanup {
        cleanup
    } -result {ORDER:SCHEDULE ORDER:CANCEL}

    #-------------------------------------------------------------------
    # cget
    #
    # Note: that module options can be set and queried
    # is tested under "init".

    test cget-1.1 {Can't query unknown option} -setup {
        setup
    } -body {
        errcatch order cget -nonesuch
    }  -cleanup {
        cleanup
    } -result {Unknown option: "-nonesuch"}

    #-------------------------------------------------------------------
    # configure
    #
    # Note: that module options can be set and queried
    # is tested under "init".

    test configure-1.1 {Can't set unknown option} -setup {
        setup
    } -body {
        errcatch order configure -nonesuch nonesuch
    }  -cleanup {
        cleanup
    } -result {Unknown option: "-nonesuch"}

    test configure-1.2 {Option value is required} -setup {
        setup
    } -body {
        errcatch order configure -subject
    }  -cleanup {
        cleanup
    } -result {Option -subject: no value given}

    test configure-1.3 {Can't configure -clock} -setup {
        setup
    } -body {
        errcatch order configure -clock nonesuch
    }  -cleanup {
        cleanup
    } -result {Option -clock is readonly after initialization}

    test configure-1.4 {Can't configure -rdb} -setup {
        setup
    } -body {
        errcatch order configure -rdb nonesuch
    }  -cleanup {
        cleanup
    } -result {Option -rdb is readonly after initialization}

    #-------------------------------------------------------------------
    # interface

    test interface-1.1 {Retrieve interface names} -setup {
        setup
    } -body {
        lsort [order interface names]
    }  -cleanup {
        cleanup
    } -result {app gui}

    
    test interface-2.1 {Invalid -checkstate} -setup {
        setup
    } -body {
        errcatch order interface configure app -checkstate NONESUCH
    }  -cleanup {
        cleanup
    } -result {invalid boolean "NONESUCH", should be one of: 1, 0, true, false, yes, no, on, off}


    test interface-2.2 {Invalid -trace} -setup {
        setup
    } -body {
        errcatch order interface configure app -trace NONESUCH
    }  -cleanup {
        cleanup
    } -result {invalid boolean "NONESUCH", should be one of: 1, 0, true, false, yes, no, on, off}


    test interface-2.3 {Invalid -transaction} -setup {
        setup
    } -body {
        errcatch order interface configure app -transaction NONESUCH
    }  -cleanup {
        cleanup
    } -result {invalid boolean "NONESUCH", should be one of: 1, 0, true, false, yes, no, on, off}

    test interface-3.1 {Configure and get all options} -setup {
        setup
    } -body {
        order interface configure app \
            -checkstate  yes \
            -errorcmd    foo \
            -rejectcmd   bar \
            -trace       yes \
            -transaction no

        pdict [order interface cget app]
    }  -cleanup {
        cleanup
    } -result {
        -checkstate:  <yes>
        -errorcmd:    <foo>
        -rejectcmd:   <bar>
        -trace:       <yes>
        -transaction: <no>
    }

    test interface-3.2 {Get one option} -setup {
        setup
    } -body {
        order interface configure app \
            -checkstate  yes

        order interface cget app -checkstate
    }  -cleanup {
        cleanup
    } -result {yes}

    test interface-4.1 {Add new interface} -setup {
        setup
    } -body {
        order interface add cli

        lsort [order interface names]
    }  -cleanup {
        cleanup
    } -result {app cli gui}

    test interface-4.2 {Add new interface with options} -setup {
        setup
    } -body {
        order interface add cli \
            -checkstate  yes \
            -errorcmd    foo \
            -rejectcmd   bar \
            -trace       yes \
            -transaction no

        pdict [order interface cget cli]
    }  -cleanup {
        cleanup
    } -result {
        -checkstate:  <yes>
        -errorcmd:    <foo>
        -rejectcmd:   <bar>
        -trace:       <yes>
        -transaction: <no>
    }


    #-------------------------------------------------------------------
    # define
    #
    # This section tests all of the things that can go wrong while
    # defining an order.  Later sections will use "order define"
    # and verify that queries, order handlers, etc., are all working
    # properly.


    test define-1.1 {options: unknown option} -setup {
        setup
    } -body {
        errcatch order define MY:ORDER { 
            options -nonesuch foo
        } {}
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Unknown option: -nonesuch}

    
    test define-1.2 {options: invalid -monitor} -setup {
        setup
    } -body {
        errcatch order define MY:ORDER { 
            options -monitor NONESUCH
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
invalid boolean "NONESUCH", should be one of: 1, 0, true, false, yes, no, on, off}

    test define-2.1 {parm: invalid name} -setup {
        setup
    } -body {
        errcatch order define MY:ORDER { 
            parm "my parm" text "My Parm" 
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Parm "my parm" has an invalid name}

    test define-2.2 {parm: invalid field type} -setup {
        setup
    } -body {
        errcatch order define MY:ORDER { 
            parm myparm "bad type" "My Parm" 
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Parm "myparm" has invalid field type: "bad type"}

    test define-2.3 {parm: option with no value} -setup {
        setup
    } -body {
        errcatch order define MY:ORDER { 
            parm a text a -nonesuch 
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Parm "a", option -nonesuch has no value}

    test define-2.4 {parm: invalid option name} -setup {
        setup
    } -body {
        # E.g., the name doesn't have a hyphen.
        errcatch order define MY:ORDER { 
            parm a text a nonesuch foo
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Parm "a", invalid option: "nonesuch"}

    test define-2.5 {parm: invalid -schedwheninvalid} -setup {
        setup
    } -body {
        # E.g., the name doesn't have a hyphen.
        errcatch order define MY:ORDER { 
            parm a text a -schedwheninvalid nonesuch
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Parm "a", option -schedwheninvalid, invalid boolean "nonesuch", should be one of: 1, 0, true, false, yes, no, on, off}

    
    test define-2.6 {parm: invalid -context} -setup {
        setup
    } -body {
        # E.g., the name doesn't have a hyphen.
        errcatch order define MY:ORDER { 
            parm a text a -context nonesuch
        } { }
    } -cleanup {
        cleanup
    } -result {Metadata error for order MY:ORDER:
Parm "a", option -context, invalid boolean "nonesuch", should be one of: 1, 0, true, false, yes, no, on, off}

    #-------------------------------------------------------------------
    # names

    test names-1.1 {No orders defined} -setup {
        setup
    } -body {
        order names
    } -cleanup {
        cleanup
    } -result {}
    
    test names-1.2 {Orders defined} -setup {
        setup
    } -body {
        order define MY:FIRST  {} {}
        order define MY:SECOND {} {}
        lsort [order names]
    } -cleanup {
        cleanup
    } -result {MY:FIRST MY:SECOND}

    #-------------------------------------------------------------------
    # validate

    test validate-1.1 {No orders defined} -setup {
        setup
    } -body {
        codecatch order validate MY:ORDER
    } -cleanup {
        cleanup
    } -result {INVALID order does not exist: "MY:ORDER"}
    
    test validate-1.2 {Order validated} -setup {
        setup
    } -body {
        order define MY:ORDER {} {}
        order validate MY:ORDER
    } -cleanup {
        cleanup
    } -result {MY:ORDER}

    #-------------------------------------------------------------------
    # exists

    test exists-1.1 {No orders defined} -setup {
        setup
    } -body {
        order exists MY:ORDER
    } -cleanup {
        cleanup
    } -result {0}
    
    test exists-1.2 {Order exists} -setup {
        setup
    } -body {
        order define MY:ORDER {} {}
        order define MY:OTHER:ORDER {} {}
        order exists MY:ORDER
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # title

    test title-1.1 {Unknown order} -setup {
        setup
    } -body {
        errcatch order title MY:ORDER
    } -cleanup {
        cleanup
    } -result {Order is undefined: "MY:ORDER"}


    test title-2.1 {Title defaults to order name} -setup {
        setup
    } -body {
        order define MY:ORDER {} {}

        order title MY:ORDER
    } -cleanup {
        cleanup
    } -result {MY:ORDER}

    test title-2.2 {Title can be set} -setup {
        setup
    } -body {
        order define MY:ORDER {
            title "My Order"
        } {}

        order title MY:ORDER
    } -cleanup {
        cleanup
    } -result {My Order}
    

    #-------------------------------------------------------------------
    # options
    #
    # Retrieves order options

    test options-1.1 {Unknown order} -setup {
        setup
    } -body {
        errcatch order options ORD
    } -cleanup {
        cleanup
    } -result {Order is undefined: "ORD"}


    test options-1.2 {Unknown option} -setup {
        setup
        order define ORD {} {}
    } -body {
        errcatch order options ORD -nonesuch
    } -cleanup {
        cleanup
    } -result {key "-nonesuch" not known in dictionary}


    test options-2.1 {Default options} -setup {
        setup
    } -body {
        order define ORD {} {}

        pdict [order options ORD]
    } -cleanup {
        cleanup
    } -result {
        -layout:         <>
        -narrativecmd:   <>
        -refreshcmd:     <>
        -sendstates:     <*>
        -schedulestates: <>
        -monitor:        <1>
    }


    test options-2.2 {Options can be set} -setup {
        setup
    } -body {
        order define ORD {
            options \
                -monitor        no      \
                -narrativecmd   ncmd    \
                -refreshcmd     rcmd    \
                -schedulestates "A B C" \
                -sendstates     "A B"
        } {}

        pdict [order options ORD]
    } -cleanup {
        cleanup
    } -result {
        -layout:         <>
        -narrativecmd:   <ncmd>
        -refreshcmd:     <rcmd>
        -sendstates:     <A B>
        -schedulestates: <A B C>
        -monitor:        <no>
    }

    test options-2.3 {Can retrieve single options} -setup {
        setup
    } -body {
        order define ORD {} {}
        order options ORD -monitor
    } -cleanup {
        cleanup
    } -result {1}

    #-------------------------------------------------------------------
    # layout

    test layout-1.1 {Layout defaults to ""} -setup {
        setup
    } -body {
        order define MY:ORDER {} {}

        order options MY:ORDER -layout
    } -cleanup {
        cleanup
    } -result {}

    test layout-1.2 {Layout can be set} -setup {
        setup
    } -body {
        order define MY:ORDER {
            layout "bogus layout"
        } {}

        order options MY:ORDER -layout
    } -cleanup {
        cleanup
    } -result {bogus layout}
    
    #-------------------------------------------------------------------
    # narrative

    test narrative-1.1 {Unknown order} -setup {
        setup
    } -body {
        errcatch order narrative MY:ORDER {}
    } -cleanup {
        cleanup
    } -result {Order is undefined: "MY:ORDER"}


    test narrative-2.1 {Narrative defaults to order title} -setup {
        setup
    } -body {
        order define MY:ORDER { title "My Order"} {}

        order narrative MY:ORDER {}
    } -cleanup {
        cleanup
    } -result {My Order}

    test narrative-2.2 {-narrativecmd can be used} -setup {
        setup
    } -body {
        order define MY:ORDER {
            options -narrativecmd ::marsutil::test::NarrativeCmd
        } {}

        order narrative MY:ORDER {a 1 b 2 c 3}
        
        # Test command just reflects arguments
    } -cleanup {
        cleanup
    } -result {MY:ORDER {a 1 b 2 c 3}}


    #-------------------------------------------------------------------
    # parms

    test parms-1.1 {Order not defined} -setup {
        setup
    } -body {
        errcatch order parms MY:ORDER
    } -cleanup {
        cleanup
    } -result {Order is undefined: "MY:ORDER"}
    
    test parms-2.1 {Order exists} -setup {
        setup
    } -body {
        order define MY:ORDER {
            parm a text a
            parm b text b
            parm c text c
        } {}

        order parms MY:ORDER
    } -cleanup {
        cleanup
    } -result {a b c}


    #-------------------------------------------------------------------
    # parm

    test parm-1.1 {Order not defined} -setup {
        setup
    } -body {
        errcatch order parm MY:ORDER a
    } -cleanup {
        cleanup
    } -result {Order is undefined: "MY:ORDER"}
    
    test parm-1.2 {Parm not defined} -setup {
        setup
        order define MY:ORDER {} {}
    } -body {
        errcatch order parm MY:ORDER a
    } -cleanup {
        cleanup
    } -result {Parm is undefined: "a"}

    test parm-1.3 {Parm option not defined} -setup {
        setup
        order define MY:ORDER { parm a text a } {}
    } -body {
        errcatch order parm MY:ORDER a -nonesuch
    } -cleanup {
        cleanup
    } -result {key "-nonesuch" not known in dictionary}

    test parm-2.1 {Can retrieve one option} -setup {
        setup
    } -body {
        order define MY:ORDER {
            parm a enum a -type atype
        } {}

        order parm MY:ORDER a -type
    } -cleanup {
        cleanup
    } -result {atype}

    test parm-2.2 {Can retrieve all options} -setup {
        setup
    } -body {
        order define MY:ORDER {
            parm a enum a -type atype
        } {}

        pdict [order parm MY:ORDER a]
    } -cleanup {
        cleanup
    } -result {
        -fieldtype:        <enum>
        -label:            <a>
        -context:          <0>
        -defval:           <>
        -schedwheninvalid: <0>
        -tags:             <>
        -type:             <atype>
    }

    #-------------------------------------------------------------------
    # state

    test state-1.1 {Default state is empty} -setup {
        setup
    } -body {
        order state
    } -cleanup {
        cleanup
    } -result {}


    test state-1.2 {Can set and return state} -setup {
        setup
    } -body {
        order state MYSTATE
    } -cleanup {
        cleanup
    } -result {MYSTATE}


    test state-1.3 {Can set and query state} -setup {
        setup
    } -body {
        order state MYSTATE
        order state
    } -cleanup {
        cleanup
    } -result {MYSTATE}


    test state-1.4 {Sends notification} -setup {
        setup
    } -body {
        order state MYSTATE
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <State> MYSTATE {}
    }

    #-------------------------------------------------------------------
    # cansend

    test cansend-1.1 {-sendstates *} -setup {
        setup
        order define MY:ORDER { options -sendstates * } {}
    } -body {
        order state MYSTATE
        order cansend MY:ORDER
    } -cleanup {
        cleanup
    } -result {1}
    
    test cansend-1.2 {-sendstates ""} -setup {
        setup
        order define MY:ORDER { options -sendstates {}} {}
    } -body {
        order state MYSTATE
        order cansend MY:ORDER
    } -cleanup {
        cleanup
    } -result {0}

    test cansend-1.3 {-sendstates set, state doesn't match} -setup {
        setup
        order define MY:ORDER { options -sendstates {A B C}} {}
    } -body {
        order state MYSTATE
        order cansend MY:ORDER
    } -cleanup {
        cleanup
    } -result {0}

    test cansend-1.4 {-sendstates set, state matches} -setup {
        setup
        order define MY:ORDER { options -sendstates {A B C}} {}
    } -body {
        order state B
        order cansend MY:ORDER
    } -cleanup {
        cleanup
    } -result {1}

    #-------------------------------------------------------------------
    # canschedule

    # TBD: wait on scheduling scrub

    #-------------------------------------------------------------------
    # isvalid

    # TBD: wait on scheduling scrub


    #-------------------------------------------------------------------
    # send

    test send-1.1 {interface unknown} -setup {
        setup
    } -body {
        errcatch order send nonesuch NONESUCH a b c d
    } -cleanup {
        cleanup
    } -result {Interface is undefined: "nonesuch"}


    test send-1.2 {order unknown} -setup {
        setup
    } -body {
        errcatch order send app NONESUCH a b c d
    } -cleanup {
        cleanup
    } -result {Order is undefined: "NONESUCH"}


    test send-1.3 {unknown parameter} -setup {
        setup
        order define MY:ORDER {} {}
    } -body {
        codecatch order send app MY:ORDER d 1 e 2
    } -cleanup {
        cleanup
    } -result {REJECT * {Unknown parameter: "d"}}

    test send-2.1 {parms passed through: syntax 1} -setup {
        setup -passthru yes
    } -body {
        order send app PASS:THRU a 1 b 2 c 3
    } -cleanup {
        cleanup
    } -result {a 1 b 2 _order PASS:THRU c 3}


    test send-2.2 {parms passed through: syntax 2} -setup {
        setup -passthru yes
    } -body {
        order send app PASS:THRU [list a 1 b 2 c 3]
    } -cleanup {
        cleanup
    } -result {a 1 b 2 _order PASS:THRU c 3}

    # send-3.*: Rejections

    test send-3.1 {REJECT error, no -rejectcmd} -setup {
        setup 
        order define MY:ORDER {} {
            return -code error -errorcode REJECT "Simulated Rejection"
        }
    } -body {
        codecatch order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {REJECT Simulated Rejection}


    test send-3.2 {REJECT error, -rejectcmd} -setup {
        setup 
        order define MY:ORDER {} {
            return -code error -errorcode REJECT "Simulated Rejection"
        }
        
        order interface configure app \
            -rejectcmd ::marsutil::test::AddStars
    } -body {
        codecatch order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {REJECT *Simulated Rejection*}

    # send-4.*: Cancellations

    test send-4.1 {CANCEL error} -setup {
        setup
        order define MY:ORDER {} {
            return -code error -errorcode CANCEL "Simulated Cancellation"
        }
    } -body {
        order send app MY:ORDER
        getacc log
    } -cleanup {
        cleanup
    } -result {
        detail order {define MY:ORDER}
        normal order {MY:ORDER from 'app': {}}
        warning order {Simulated Cancellation}
    }

    # send-5.*: Unexpected Errors

    test send-5.1 {Unexpected error, no -errorcmd} -setup {
        setup
        order define MY:ORDER {} {
            return -code error "Simulated Error"
        }
    } -body {
        codecatch order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {NONE Unexpected error in MY:ORDER:
Simulated Error}

    test send-5.2 {Unexpected error, -errorcmd} -setup {
        setup
        order define MY:ORDER {} {
            return -code error "Simulated Error"
        }
        order interface configure app \
            -errorcmd ::marsutil::test::LogErrorCmd
    } -body {
        # Error not propagated when -errorcmd is defined
        order send app MY:ORDER
        getacc log
    } -cleanup {
        cleanup
    } -result {
        detail order {define MY:ORDER}
        normal order {MY:ORDER from 'app': {}}
        {MY:ORDER <Simulated Error>}
    }

    # send-6.*: Effects of -checkstate

    test send-6.1 {interface -checkstate no: state doesn't matter} -setup {
        setup
        order define MY:ORDER { options -sendstates FOO} {
            return OK
        }
        order state BAR
        order interface configure app -checkstate no
    } -body {
        order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {OK}

    test send-6.2 {interface -checkstate: can't send in this state} -setup {
        setup
        order define MY:ORDER { options -sendstates FOO} {}
        order state BAR
        order interface configure app -checkstate yes
    } -body {
        codecatch order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {REJECT * {Order state is BAR, but order is valid only in these states: FOO}}

    test send-6.3 {interface -checkstate: can send in this state} -setup {
        setup
        order define MY:ORDER { options -sendstates FOO} {
            return OK
        }
        order state FOO
        order interface configure app -checkstate yes
    } -body {
        order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {OK}

    # send-7.*: Effects of -trace

    test send-7.1 {interface -trace: no trace} -setup {
        setup
        order define MY:ORDER { } {
            return OK
        }
        order interface configure app -trace no
    } -body {
        order send app MY:ORDER
        getacc orders
    } -cleanup {
        cleanup
    } -result {*NULL*}

    test send-7.2 {interface -trace: trace} -setup {
        setup
        order define MY:ORDER {
            parm a text a
            parm b text b
        } {
            return OK
        }
        order interface configure app -trace yes
    } -body {
        order send app MY:ORDER a 1 b 2
        getacc orders
    } -cleanup {
        cleanup
    } -result {
        app MY:ORDER {a 1 b 2} {}
    }

    test send-7.3 {interface -trace: no trace on error} -setup {
        setup
        order define MY:ORDER {} {
            return -code error -errorcode REJECT \
                "Simulated Rejection"
        }
        order interface configure app -trace yes
    } -body {
        codecatch order send app MY:ORDER a 1 b 2
        getacc orders
    } -cleanup {
        cleanup
    } -result {*NULL*}

    # send-8.*: interface -transaction

    test send-8.1 {interface -transaction: rollback on error} -setup {
        setup
        order define MY:ORDER {} {
            rdb eval {
                UPDATE test_table
                SET y=5;
            }
            error "Simulated Error"
        }
        order interface configure app -transaction yes
    } -body {
        codecatch order send app MY:ORDER
        rdb eval {SELECT * FROM test_table}
    } -cleanup {
        cleanup
    } -result {1 2 3}

    test send-8.2 {interface -transaction no: no rollback on error} -setup {
        setup
        order define MY:ORDER {} {
            ::marsutil::test::rdb eval {
                UPDATE test_table
                SET y=5;
            }

            error "Simulated Error"
        }
        order interface configure app -transaction no
    } -body {
        codecatch order send app MY:ORDER
        rdb eval {SELECT * FROM test_table}
    } -cleanup {
        cleanup
    } -result {1 5 3}

    # send-9.*: options -monitor

    test send-9.1 {options -monitor: RDB changes are monitored} -setup {
        setup
        order define MY:ORDER {
            options -monitor yes
        } {
            ::marsutil::test::rdb eval {
                UPDATE test_table
                SET y=5;
            }
        }

        rdb monitor add test_table x
    } -body {
        order send app MY:ORDER
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::test::rdb <test_table> {update 1} {}
        ::marsutil::test::rdb <Monitor> {} {}
        ::marsutil::order <Accepted> {MY:ORDER {}} {}
    }

    test send-9.2 {options -monitor no: no monitoring} -setup {
        setup
        order define MY:ORDER {
            options -monitor no
        } {
            ::marsutil::test::rdb eval {
                UPDATE test_table
                SET y=5;
            }
        }

        rdb monitor add test_table x
    } -body {
        order send app MY:ORDER
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <Accepted> {MY:ORDER {}} {}
    }

    #===================================================================
    # Commands for use in order bodies

    #-------------------------------------------------------------------
    # sender

    test sender-1.1 {Sender passed through} -setup {
        setup
        order define MY:ORDER {} {
            sender
        }
    } -body {
        order send app MY:ORDER
    } -cleanup {
        cleanup
    } -result {app}

    #-------------------------------------------------------------------
    # prepare

    test prepare-1.1 {Adds missing parameter to parms array} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a
        }
    } -body {
        order send app MY:ORDER
        order lastparms
    } -cleanup {
        cleanup
    } -result {a {} _order MY:ORDER}

    test prepare-1.2 {Value is trimmed} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a
        }
    } -body {
        order send app MY:ORDER a " my  value "
        order lastparms
    } -cleanup {
        cleanup
    } -result {a {my  value} _order MY:ORDER}

    test prepare-1.3 {prepare: unknown option} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -nonesuch
        }
    } -body {
        errcatch order send app MY:ORDER a "my value"
    } -cleanup {
        cleanup
    } -result {Unexpected error in MY:ORDER:
unknown option: "-nonesuch"}

    test prepare-2.1 {prepare -toupper} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -toupper
        }
    } -body {
        order send app MY:ORDER a value
        order lastparms
    } -cleanup {
        cleanup
    } -result {a VALUE _order MY:ORDER}

    test prepare-3.1 {prepare -tolower} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -tolower
        }
    } -body {
        order send app MY:ORDER a VALUE
        order lastparms
    } -cleanup {
        cleanup
    } -result {a value _order MY:ORDER}

    test prepare-4.1 {prepare -normalize} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -normalize
        }
    } -body {
        order send app MY:ORDER a "  my   value  "
        order lastparms
    } -cleanup {
        cleanup
    } -result {a {my value} _order MY:ORDER}

    test prepare-5.1 {prepare -required, absent} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -required
            returnOnError
        }
    } -body {
        codecatch order send app MY:ORDER
    } -cleanup {
        cleanup
    } -cleanup {
        cleanup
    } -result {REJECT a {required value}}

    test prepare-5.2 {prepare -required, present} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -required
            returnOnError

            return OK
        }
    } -body {
        order send app MY:ORDER a value
    } -cleanup {
        cleanup
    } -result {OK}


    test prepare-6.1 {prepare -oldvalue, match} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -oldvalue "my value"
        }
    } -body {
        order send app MY:ORDER a "my value"
        order lastparms
    } -cleanup {
        cleanup
    } -result {a {} _order MY:ORDER}

    test prepare-6.2 {prepare -oldvalue, no match} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -oldvalue "my value"
        }
    } -body {
        order send app MY:ORDER a "my new value"
        order lastparms
    } -cleanup {
        cleanup
    } -result {a {my new value} _order MY:ORDER}

    test prepare-7.1 {prepare -oldnum, no match} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -oldnum 8
        }
    } -body {
        order send app MY:ORDER a 8
        order lastparms
    } -cleanup {
        cleanup
    } -result {a {} _order MY:ORDER}

    test prepare-7.2 {prepare -oldnum, no match} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -oldnum 8
        }
    } -body {
        order send app MY:ORDER a 10
        order lastparms
    } -cleanup {
        cleanup
    } -result {a 10 _order MY:ORDER}

    test prepare-8.1 {prepare -unused, no -unusedtable} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -unused
        }
    } -body {
        errcatch order send app MY:ORDER a FOO
    } -cleanup {
        cleanup
    } -result {Unexpected error in MY:ORDER:
No -usedtable specified.}

    test prepare-8.2 {prepare -unused, used} -setup {
        setup
        rdb eval {
            CREATE VIEW used_table AS
            SELECT 'THIS' AS id
            UNION
            SELECT 'THAT' AS id;
        }

        order configure -usedtable used_table

        order define MY:ORDER {parm a text a} {
            prepare a -unused
            returnOnError
        }
    } -body {
        codecatch order send app MY:ORDER a THIS
    } -cleanup {
        cleanup
    } -result {REJECT a {An entity with this ID already exists}}

    test prepare-8.3 {prepare -unused, unused} -setup {
        setup
        rdb eval {
            CREATE VIEW used_table AS
            SELECT 'THIS' AS id
            UNION
            SELECT 'THAT' AS id;
        }

        order configure -usedtable used_table

        order define MY:ORDER {parm a text a} {
            prepare a -unused
            returnOnError

            return OK
        }
    } -body {
        order send app MY:ORDER a THEOTHER
    } -cleanup {
        cleanup
    } -result {OK}

    test prepare-9.1 {prepare -type, valid} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -type ::marsutil::test::goodness
            returnOnError
            return OK
        }
    } -body {
        order send app MY:ORDER a GOOD
    } -cleanup {
        cleanup
    } -result {OK}

    test prepare-9.2 {prepare -type, invalid} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -type ::marsutil::test::goodness
            returnOnError
            return OK
        }
    } -body {
        codecatch order send app MY:ORDER a UGLY
    } -cleanup {
        cleanup
    } -result {REJECT a {invalid value "UGLY", should be one of: GOOD, BAD}}

    test prepare-10.1 {prepare -listof, valid} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -listof ::marsutil::test::goodness
            returnOnError
            return OK
        }
    } -body {
        order send app MY:ORDER a {GOOD BAD GOOD}
    } -cleanup {
        cleanup
    } -result {OK}

    test prepare-10.2 {prepare -listof, invalid} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -listof ::marsutil::test::goodness
            returnOnError
            return OK
        }
    } -body {
        codecatch order send app MY:ORDER a {GOOD BAD UGLY}
    } -cleanup {
        cleanup
    } -result {REJECT a {invalid value "UGLY", should be one of: GOOD, BAD}}

    test prepare-11.1 {prepare -xform} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            prepare a -xform {string toupper}
        }
    } -body {
        order send app MY:ORDER a value
        order lastparms
    } -cleanup {
        cleanup
    } -result {a VALUE _order MY:ORDER}

    #-------------------------------------------------------------------
    # reject

    test reject-1.1 {Reject adds to messages} -setup {
        setup
        order define MY:ORDER {
            parm a text a
            parm b text b
        } {
            reject a "Bad A"
            reject b "Worse B"
            returnOnError
        }
    } -body {
        codecatch order send app MY:ORDER a 1 b 2
    } -cleanup {
        cleanup
    } -result {REJECT a {Bad A} b {Worse B}}


    #-------------------------------------------------------------------
    # cancel

    test cancel-1.1 {Cancel ends order} -setup {
        setup
        order define MY:ORDER {} {
            cancel
        }
    } -body {
        order send app MY:ORDER
        getacc log
    } -cleanup {
        cleanup
    } -result {
        detail order {define MY:ORDER}
        normal order {MY:ORDER from 'app': {}}
        warning order {The order was cancelled by the user.}
    }

    #-------------------------------------------------------------------
    # valid

    test valid-1.1 {Valid if not rejected and not ""} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            valid a
        }
    } -body {
        order send app MY:ORDER a 1
    } -cleanup {
        cleanup
    } -result {1}
    
    test valid-1.2 {Invalid if ""} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            valid a
        }
    } -body {
        order send app MY:ORDER a ""
    } -cleanup {
        cleanup
    } -result {0}
    
    test valid-1.3 {Invalid if rejected} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            reject a "Simulated Error"
            valid a
        }
    } -body {
        order send app MY:ORDER a 1
    } -cleanup {
        cleanup
    } -result {0}
    

    #-------------------------------------------------------------------
    # validate

    test validate-1.1 {Rejected if script throws INVALID} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            validate a {
                return -code error -errorcode INVALID "Invalid a"
            }

            returnOnError

            return
        }
    } -body {
        codecatch order send app MY:ORDER a 1
    } -cleanup {
        cleanup
    } -result {REJECT a {Invalid a}}

    test validate-1.2 {Rejected if script rejects} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            validate a {
                reject a "Rejected a"
            }

            returnOnError

            return
        }
    } -body {
        codecatch order send app MY:ORDER a 1
    } -cleanup {
        cleanup
    } -result {REJECT a {Rejected a}}

    test validate-1.3 {Unexpected error if throws anything else} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            validate a {
                return -code error "Simulated Error"
            }

            returnOnError

            return
        }
    } -body {
        codecatch order send app MY:ORDER a 1
    } -cleanup {
        cleanup
    } -result {NONE Unexpected error in MY:ORDER:
Simulated Error}

    test validate-1.4 {Otherwise, valid} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            validate a {
                # Nothing
            }

            returnOnError

            valid a
        }
    } -body {
        order send app MY:ORDER a 1
    } -cleanup {
        cleanup
    } -result {1}


    #-------------------------------------------------------------------
    # returnOnError
    #
    # This command is tested by the other tests.

    #-------------------------------------------------------------------
    # setundo

    test setundo-1.1 {undo script is passed to -ordercmd} -setup {
        setup
        order define MY:ORDER {} {
            setundo "undo order"
        }
        order interface configure app -trace yes
    } -body {
        order send app MY:ORDER
        getacc orders
    } -cleanup {
        cleanup
    } -result {
        app MY:ORDER {} {undo order}
    }


    #-------------------------------------------------------------------
    # check

    test check-1.1 {order is unknown} -setup {
        setup
    } -body {
        errcatch order check MY:ORDER a NONESUCH
    } -cleanup {
        cleanup
    } -result {Undefined order: MY:ORDER}


    test check-1.2 {order is invalid} -setup {
        setup
        order define MY:ORDER {} {
            reject * "Simulated rejection"
            returnOnError -final
            
            error "Shouldn't have gotten here"
        }
    } -body {
        codecatch order check MY:ORDER
    } -cleanup {
        cleanup
    } -result {REJECT * {Simulated rejection}}

    test check-1.3 {order is valid} -setup {
        setup
        order define MY:ORDER {} {
            returnOnError -final

            error "Shouldn't have gotten here"
        }
    } -body {
        order check MY:ORDER
    } -cleanup {
        cleanup
    } -result {}


    #-------------------------------------------------------------------
    # nullmode

    test nullmode-1.1 {null mode works} -setup {
        setup
        order define MY:ORDER {parm a text a} {
            error "Shouldn't have gotten here"
        }
    } -body {
        order nullmode yes
        order send app MY:ORDER a NONESUCH
        order lastparms
    } -cleanup {
        cleanup
    } -result {a NONESUCH _order MY:ORDER}

    #-------------------------------------------------------------------
    # schedule

    test schedule-1.1 {Can't schedule without -clock} -setup {
        setup
    } -body {
        errcatch order schedule gui T0 MY:ORDER {}
    } -cleanup {
        cleanup
    } -result {Order scheduling is disabled}


    test schedule-1.2 {Can't schedule without -schedulestates} -setup {
        setup -clockflag yes
        order define MY:ORDER {} {}
    } -body {
        errcatch order schedule gui T0 MY:ORDER {}
    } -cleanup {
        cleanup
    } -result {Scheduling is disabled for MY:ORDER}


    test schedule-1.3 {Can't schedule in bad state} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates {A B}
        } {}
        order state C
    } -body {
        errcatch order schedule gui T0 MY:ORDER {}
    } -cleanup {
        cleanup
    } -result {Cannot schedule MY:ORDER in state "C"}

    test schedule-1.4 {Can't schedule when order is rejected} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            reject a "Bogus rejection"
            returnOnError -final
        }
    } -body {
        codecatch order schedule gui T0 MY:ORDER {a 1}
    } -cleanup {
        cleanup
    } -result {REJECT a {Bogus rejection}}

    test schedule-2.1 {Orders can be scheduled} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
        }
    } -body {
        order schedule gui T0 MY:ORDER {a 1}
        bprint [rdb query {SELECT * FROM eventq_queue_order_execute}]
    } -cleanup {
        cleanup
    } -result {
id t etype         name     narrative parmdict 
-- - ------------- -------- --------- -------- 
1  0 order_execute MY:ORDER MY:ORDER  a 1      
    }

    test schedule-2.2 {<Queue> sent} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
        }
    } -body {
        order schedule gui T0 MY:ORDER {a 1}
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <Queue> {} {}
        ::marsutil::order <Accepted> {ORDER:SCHEDULE {timespec T0 name MY:ORDER parmdict {a 1}}} {}
    }

    test schedule-2.3 {-schedwheninvalid yes} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a -schedwheninvalid yes
        } {
            reject a "Bogus rejection"
            returnOnError -final
        }
    } -body {
        order schedule gui T0 MY:ORDER {a 1}
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <Queue> {} {}
        ::marsutil::order <Accepted> {ORDER:SCHEDULE {timespec T0 name MY:ORDER parmdict {a 1}}} {}
    }

    test schedule-2.4 {Undo script} -setup {
        setup -clockflag yes
        order interface configure gui -trace yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
        }
    } -body {
        order schedule gui T0 MY:ORDER {a 1}
        getacc orders
    } -cleanup {
        cleanup
    } -result {
        gui ORDER:SCHEDULE {timespec T0 name MY:ORDER parmdict {a 1}} {order UndoSchedule}
    }

    test schedule-2.5 {Can undo script} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
        }
    } -body {
        order schedule gui T0 MY:ORDER {a 1}
        order UndoSchedule
        rdb query {SELECT * FROM eventq_queue_order_execute}
    } -cleanup {
        cleanup
    } -result {}

    test schedule-3.1 {Scheduled orders execute} -setup {
        proc ::bgerror {msg} {
            puts "msg: $msg\n$::errorInfo"
        }

        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
            ::marsutil::notifier send ::app <Executed> $parms(a)
        }
    } -body {
        order schedule gui T0 MY:ORDER {a "Hello, world"}
        eventq advance 1
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <Queue> {} {}
        ::marsutil::order <Accepted> {ORDER:SCHEDULE {timespec T0 name MY:ORDER parmdict {a "Hello, world"}}} {}
        ::app <Executed> {{Hello, world}} {}
        ::marsutil::order <Accepted> {MY:ORDER {a "Hello, world"}} {}
    }

    test schedule-3.2 {Event sent on rejection of scheduled order} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a -schedwheninvalid yes
        } {
            reject a "Bogus rejection"
            returnOnError -final
            ::marsutil::notifier send ::app <Executed> $parms(a)
        }
    } -body {
        order schedule gui T0 MY:ORDER {a "Hello, world"}
        eventq advance 1
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <Queue> {} {}
        ::marsutil::order <Accepted> {ORDER:SCHEDULE {timespec T0 name MY:ORDER parmdict {a "Hello, world"}}} {}
        ::marsutil::order <EventRejected> {MY:ORDER {a "Hello, world"} {a {Bogus rejection}}} {}
    }

    #-------------------------------------------------------------------
    # scheduled names

    test scheduled_names-1.1 {No names initially} -setup {
        setup -clockflag yes
    } -body {
        order scheduled names
    } -cleanup {
        cleanup
    } -result {}

    test scheduled_names-1.2 {IDs of scheduled orders} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
        } {
            returnOnError -final
        }
        order schedule gui T0 MY:ORDER {}
        order schedule gui T0+1 MY:ORDER {}
    } -body {
        order scheduled names
    } -cleanup {
        cleanup
    } -result {1 2}

    #-------------------------------------------------------------------
    # scheduled validate

    test scheduled_validate-1.1 {Invalid ID} -setup {
        setup -clockflag yes
    } -body {
        codecatch order scheduled validate NONESUCH
    } -cleanup {
        cleanup
    } -result {INVALID order not scheduled: "NONESUCH"}

    test scheduled_validate-1.2 {Valid ID} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
        } {
            returnOnError -final
        }
        order schedule gui T0 MY:ORDER {}
        order schedule gui T0+1 MY:ORDER {}
    } -body {
        order scheduled validate 2
    } -cleanup {
        cleanup
    } -result {2}

    #-------------------------------------------------------------------
    # order_cancel

    test order_cancel-1.1 {Can't cancel without -clock} -setup {
        setup
    } -body {
        errcatch order cancel gui 1
    } -cleanup {
        cleanup
    } -result {Order scheduling is disabled}

    test order_cancel-1.2 {Can't cancel in bad order state} -setup {
        setup -clockflag yes -cancelstates {A B}
        order state C
    } -body {
        errcatch order cancel gui 1
    } -cleanup {
        cleanup
    } -result {Cannot cancel orders in state "C"}

    test order_cancel-1.3 {Can't cancel invalid ID} -setup {
        setup -clockflag yes
    } -body {
        errcatch order cancel gui 1
    } -cleanup {
        cleanup
    } -result {order not scheduled: "1"}

    test order_cancel-2.1 {Orders can be canceled} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
        }
        order schedule gui T0 MY:ORDER {a 1}
    } -body {
        order cancel gui [lindex [order scheduled names] 0]
        rdb query {SELECT * FROM eventq_queue_order_execute}
    } -cleanup {
        cleanup
    } -result {}

    test order_cancel-2.2 {<Queue> sent} -setup {
        setup -clockflag yes
        order define MY:ORDER {
            options -schedulestates *
            parm a text a
        } {
            prepare a
            returnOnError -final
        }
        order schedule gui T0 MY:ORDER {a 1}
    } -body {
        order cancel gui [lindex [order scheduled names] 0]
        getacc events
    } -cleanup {
        cleanup
    } -result {
        ::marsutil::order <Queue> {} {}
        ::marsutil::order <Accepted> {ORDER:SCHEDULE {timespec T0 name MY:ORDER parmdict {a 1}}} {}
        ::marsutil::order <Queue> {} {}
        ::marsutil::order <Accepted> {ORDER:CANCEL {id 1}} {}
    }


    #-------------------------------------------------------------------
    # order_lastparms
    #
    # This routine is checked in use by the other tests.

    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::marsutil::test







