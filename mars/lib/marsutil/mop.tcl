#-----------------------------------------------------------------------
# FILE: mop.tcl
#
#   Mars Order Processor
#
# PACKAGE:
#   marsutil(n): Mars Utility API
#
# PROJECT:
#   Mars Simulation Infrastructure Library
#
# AUTHOR:
#    Will Duquette
#
#-------------------------------------------------------------------
 
namespace eval ::marsutil:: {
    namespace export mop
}

#-----------------------------------------------------------------------
# Module: mop
#
# Mars Order Processor
#
# mop(n) defines the notion of an "order", a command, usually 
# generated by the user, that changes the application's state and
# can potentially be undone.  An order has a name and a parameter
# dictionary.
#
# Insofar as possible, input validation and error-handling are
# automated, so that's trivially easy to make all orders work the
# same way.
#
# Error Handling:
#
# mop(n) throws three kinds of errors when processing an order.
#
# If the -errorcode is REJECT, the order was rejected due to errors
# in the order parameters.  The error return is a dictionary of
# parameter names and error messages; global error messages have a 
# key of "*".
#
# If the -errorcode is CANCEL, the order was cancelled via the
# <cancel> command.
#
# Otherwise, the error is unexpected, i.e, the order handler, or
# code called by it, threw an error unrelated to validation of the
# order parms.  This usually indicates a bug in the code.
#
#-----------------------------------------------------------------------

snit::type ::marsutil::mop {
    # Make it an ensemble
    pragma -hastypedestroy 0 -hasinstances 0

    #-------------------------------------------------------------------
    # Group: Type Variables

    # Type Variable: info
    #
    # An array of miscellaneous data.  The keys are as follows.
    #
    # nullMode    - 0 or 1.  While in null mode, the orders don't 
    #               actually get executed; "order send" returns after 
    #               saving the parms.
    # logcmd      - Value of -logcmd, a logger(n) object
    # ordercmd    - Value of -ordercmd, a command called when an
    #               order is accepted.

    typevariable info -array {
        nullMode    0
        logcmd      {}
        ordercmd    {}
    }

    # Type Variable: handler
    #
    # Array, name of order handlers by order name.

    typevariable handler -array { }

    # Type Variable: parmNames
    #
    # Array, list of order parameter names by order name.

    typevariable parmNames -array { }

    #-------------------------------------------------------------------
    # Group: Transient Variables
    #
    # The following variables are used while processing an order, and
    # are cleared before every new order.

    # Type Variable: trans
    #
    # Array of transient data.
    #
    #   interface - The interface by which this order was sent.
    #   errors    - Dictionary of parameter names and error messages
    #   level     - Error level: NONE or REJECT
    #   undo      - Undo script for this order
    #   checking  - 1 if in "order check" and 0 otherwise.

    typevariable trans -array {}

    # Type Variable: parms
    #
    # Array of order parameter values, by parameter name.
    # This array is aliased into every order handler.

    typevariable parms

    #-------------------------------------------------------------------
    # Group: Configuration

    # Type Method: reset
    #
    # Resets the entire module back to its initial state, with no
    # orders defined and options at their default values.
    # Note that the order handlers are still in place in their
    # various namespaces; but mop(n) no longer knows about them.
    #
    # This command exists primarily for the benefit of the test suite.

    typemethod reset {} {
        array unset handler
        array unset parmNames
        array set info {
            nullMode 0
            logcmd   {}
            ordercmd {}
        }
    }

    # Type Method: configure
    #
    # Sets/queries mop(n) configuration options.
    #
    # Syntax:
    #   configure _option_
    #
    #   configure _option value ?option value...?_
    #
    #   -logcmd   - A log command prefix; usually, an instance of logger(n).
    #   -ordercmd - A command prefix to be called for each accepted order.
    #               Four additional arguments will be appended: the
    #               interface, the order name, the parameter dictionary,
    #               and the undo script.

    typemethod configure {option args} {
        # FIRST, query an option.
        if {[llength $args] == 0} {
            switch -exact -- $option {
                -logcmd   { return $info(logcmd)                }
                -ordercmd { return $info(ordercmd)              }
                default   { error "Unknown option: \"$option\"" }
            }
        }

        # NEXT, set the option values.
        set args [linsert $args 0 $option]

        while {[llength $args] > 0} {
            set option [lshift args]
            
            switch -exact -- $option {
                -logcmd   { set info(logcmd) [lshift args]      }
                -ordercmd { set info(ordercmd) [lshift args]    }
                default   { error "Unknown option: \"$option\"" }
            }
        }

        return
    }


    #-------------------------------------------------------------------
    # Group: Order Definition

    # Type Method: define
    #
    # Defines a handler for the order called _name_ as part of the 
    # snit::type called _module_.  It works by defining a proc
    # within that module's ${module}::orders namespace in which all
    # type variables appear.  This allows orders to be defined 
    # outside the order.tcl file.
    #
    # Syntax:
    #   define _module name parmlist body_
    #
    #   module   - The name of a module (a snit::type)
    #   name     - The name of the order
    #   parmlist - List of order parameter names
    #   body     - The body of the order handler

    typemethod define {module name parmlist body} {
        # FIRST, get the module's type variables, if any.
        if {[catch {
            set modVarList [$module info typevars]
        } result]} {
            error "Module is not a snit::type with -hasinfo: \"$module\""
        }

        if {[llength $modVarList] > 0} {
            set modvars [list namespace upvar $module]

            foreach tv [$module info typevars] {
                lappend modvars $tv [namespace tail $tv]
            }
        } else {
            set modvars [list]
        }

        # NEXT, define the handler namespace and set up the namespace 
        # path so that order handlers can call procs in the ::order:: 
        # namespace and in their own namespace.

        namespace eval ${module}::orders:: \
            [list namespace path [list ${module} ::marsutil::mop::]]

        # NEXT, save the handler name
        set handler($name) ${module}::orders::$name

        # NEXT, save the parm names
        set parmNames($name) $parmlist

        # NEXT, define the handler
        proc $handler($name) {} [tsubst {
        |<--
            namespace upvar $type ${type}::parms parms
            $modvars
            set type $module

            $body
        }]
    }

    #-------------------------------------------------------------------
    # Group: Order Queries
    #
    # These commands are used to query the existing orders.

    # Type Method: names
    #
    # Returns the names of the currently defined orders
    
    typemethod names {} {
        return [array names handler]
    }

    # Type Method: validate
    #
    # Validates the _name_ as an order name
    #
    # Syntax:
    #   validate _name_
    #
    #   name - An order name

    typemethod validate {name} {
        if {![$type exists $name]} {
            return -code error -errorcode INVALID \
                "order does not exist: \"$name\""
        }

        return $name
    }


    # Type Method: exists
    #
    # Returns 1 if there's an order with this name, and 0 otherwise
    #
    # Syntax:
    #   exists _name_
    #
    #   name - An order name

    typemethod exists {name} {
        return [info exists handler($name)]
    }

    # Type Method: parms
    #
    # Returns the list of parameter names for the specified order.
    #
    # Syntax:
    #   parms _name_
    #
    #   name - An order name

    typemethod parms {name} {
        $type validate $name
        return $parmNames($name)
    }

    #-------------------------------------------------------------------
    # Group: Sending Orders

    # Type Method: send
    #
    # Processes the order, handling it in the appropriate way given
    # the interface.
    #
    # Syntax:
    #   send _interface name parmdict_
    #
    #   send _interface name parm value ?parm value...?_
    #
    #   interface     - Application-specific value
    #   name          - The order's name
    #   parmdict      - The order's parameter dictionary
    #   parm,value... - The parameter dictionary passed as separate args.

    typemethod send {interface name args} {
        # FIRST, get the parmdict.
        if {[llength $args] > 1} {
            set parmdict $args
        } else {
            set parmdict [lindex $args 0]
        }

        # NEXT, log the order
        Log normal [list $name from '$interface': $parmdict]

        # NEXT, do we have an order handler?
        require {[info exists handler($name)]} "Undefined order: $name"

        # NEXT, save the interface.
        set trans(interface) $interface

        # NEXT, we're not just checking.
        set trans(checking) 0

        # NEXT, save the order parameters in the parms array, saving
        # the order name.
        set validParms [mop parms $name]

        array unset parms

        dict for {parm value} $parmdict {
            require {$parm in $validParms} "Unknown parameter: \"$parm\""
            
            set parms($parm) $value
        }

        set parms(_order) $name

        # NEXT, in null mode we're done.
        if {$info(nullMode)} {
            return
        }

        # NEXT, set up the error messages and call the order handler,
        # rolling back the database automatically on error.
        set trans(errors) [dict create]
        set trans(level)  NONE
        set trans(undo)   {}

        # NEXT, call the handler
        if {[catch {
            $handler($name)
        } result opts]} {
            # FIRST, get the error info
            set einfo [dict get $opts -errorinfo]
            set ecode [dict get $opts -errorcode]

            # NEXT, handle the result 

            # Rejection / Cancellation
            if {$ecode eq "REJECT" || $ecode eq "CANCEL"} {
                Log warning $result                    
                return {*}$opts $result
            }

            # Unexpected error.
            error \
                "Unexpected error in $name:\n$result" $einfo
        }

        # NEXT, Notify the application that an order has been accepted.
        callwith $info(ordercmd) $interface $name $parmdict $trans(undo)

        # NEXT, return the result, if any.
        return $result
    }

    # Type Method: formatRejection
    #
    # Formats the rejection error dictionary for display at a console.
    #
    # Syntax:
    #   formatRejection _errdict_
    #
    #   errdict - A REJECT error dictionary
    
    typemethod formatRejection {errdict} {
        if {[dict exists $errdict *]} {
            lappend out [dict get $errdict *]
        }

        dict for {parm msg} $errdict {
            if {$parm ne "*"} {
                lappend out "$parm: $msg"
            }
        }

        return [join $out \n]
    }

    # Type Method: check
    #
    # Checks the order, throwing a REJECT error if invalid.
    #
    # Syntax:
    #   check _name parmdict_
    #   check _name parm value ?parm value...?_
    #
    #   name          - The order's name
    #   parmdict      - The order's parameter dictionary
    #   parm,value... - The parameter dictionary passed as separate args.

    typemethod check {name args} {
        # FIRST, get the parmdict.
        if {[llength $args] > 1} {
            set parmdict $args
        } else {
            set parmdict [lindex $args 0]
        }

        # NEXT, do we have an order handler?
        require {[info exists handler($name)]} "Undefined order: $name"

        # NEXT, save the interface.
        set trans(interface) code

        # NEXT, we're checking.
        set trans(checking) 1

        # NEXT, save the order parameters in the parms array, saving
        # the order name.
        set validParms [mop parms $name]

        array unset parms

        dict for {parm value} $parmdict {
            require {$parm in $validParms} "Unknown parameter: \"$parm\""
            
            set parms($parm) $value
        }
        
        set parms(_order) $name

        # NEXT, set up the error messages and call the order handler,
        set trans(errors) [dict create]
        set trans(level)  NONE
        set trans(undo)   {}

        # NEXT, call the handler
        set code [catch { $handler($name) } result opts]

        if {$code == 0} {
            return -code error \
                "order $name responds improperly on validity check"
        } else {
            set ecode [dict get $opts -errorcode]

            if {$ecode ne "CHECKED"} {
                return {*}$opts $result
            }
        }

        return
    }


    # Type Method: nullmode
    #
    # Turns nullmode on and off.  This is used for testing commands
    # that send orders.
    #
    # Syntax:
    #   nullmode _flag_
    #
    #   flag - A boolean flag

    typemethod nullmode {flag} {
        set info(nullMode) $flag
    }


    # Type Method: lastparms
    #
    # Returns a dictionary of the most recent order parms, with one
    # additional parm, "_order".

    typemethod lastparms {} {
        array get parms
    }


    #-------------------------------------------------------------------
    # Group: Order Handler Procs
    #
    # The following commands are for use in order handlers.

    # Proc: interface
    #
    # Returns the name of the current interface

    proc interface {} {
        return $trans(interface)
    }

    # Proc: prepare
    #
    # Prepares the parameter for processing, as determined by the
    # options.  See the mop(n) man page for a list of the options.
    #
    # Syntax:
    #   prepare _parm options..._

    proc prepare {parm args} {
        # FIRST, make sure that the parameter exists.
        if {![info exists parms($parm)]} {
            set parms($parm) ""
        }

        # NEXT, trim the data.
        set parms($parm) [string trim $parms($parm)]


        # NEXT, process the options, so long as there's no explicit
        # error.

        while {![dict exists $trans(errors) $parm] && [llength $args] > 0} {
            set opt [lshift args]

            switch -exact -- $opt {
                -toupper {
                    set parms($parm) [string toupper $parms($parm)]
                }
                -tolower {
                    set parms($parm) [string tolower $parms($parm)]
                }
                -normalize {
                    set parms($parm) [normalize $parms($parm)]
                }
                -required { 
                    if {$parms($parm) eq ""} {
                        reject $parm "required value"
                    }
                }
                -oldvalue {
                    set oldvalue [lshift args]

                    if {$parms($parm) eq $oldvalue} {
                        set parms($parm) ""
                    }
                }
                -oldnum {
                    set oldvalue [lshift args]

                    if {$parms($parm) == $oldvalue} {
                        set parms($parm) ""
                    }
                }
                -type {
                    set parmtype [lshift args]

                    validate $parm { 
                        set parms($parm) [{*}$parmtype validate $parms($parm)]
                    }
                }
                -listof {
                    set parmtype [lshift args]

                    validate $parm {
                        set newvalue [list]

                        foreach val $parms($parm) {
                            lappend newvalue [{*}$parmtype validate $val]
                        }

                        set parms($parm) $newvalue
                    }
                }
                -xform {
                    set cmd [lshift args]

                    validate $parm {
                        set parms($parm) [{*}$cmd $parms($parm)]
                    }
                }
                default { 
                    error "unknown option: \"$opt\"" 
                }
            }
        }

    }

    # Proc: reject
    #
    # There's an out-and-out error in the order.  Add the message to
    # the error dictionary, and set the trans(level) to REJECT.
    #
    # Syntax:
    #   reject _parm msg_
    #
    #   parm - A parameter name, or "*"
    #   msg  - An error message

    proc reject {parm msg} {
        dict set trans(errors) $parm [normalize $msg]
        set trans(level) REJECT
    }

    # Proc: valid
    #
    # Returns 1 if _parm_'s value is not known to be invalid, and
    # 0 otherwise.  A _parm_'s value is invalid if it's the 
    # empty string (a missing value) or if it's been explicitly
    # flagged as invalid.
    #
    # Syntax:
    #   valid _parm_
    #
    #   parm - Parameter name

    proc valid {parm} {
        if {$parms($parm) eq "" || [dict exists $trans(errors) $parm]} {
            return 0
        }

        return 1
    }

    # Proc: validate
    #
    # Executes a validation script for the named _parm_.  The script is 
    # skipped if the _parm_ is already known to be invalid, or is
    # the empty string (i.e., a missing optional parameter). Otherwise,
    # executes the script in the caller's context.  If the script
    # throws an error, and the error code is INVALID, the _parm_
    # is rejected with the accompanying error message.  Any other error 
    # is rethrown as an unexpected error.
    #
    # Syntax:
    #   validate _parm script_
    #
    # parm   - A parameter to validate
    # script - A script to validate it.

    proc validate {parm script} {
        if {![valid $parm]} {
            return
        }

        if {[catch {
            uplevel 1 $script
        } result opts]} {
            if {[lindex [dict get $opts -errorcode] 0] eq "INVALID"} {
                reject $parm $result
            } else {
                return {*}$opts $result
            }
        }
    }

    # Proc: returnOnError
    #
    # Causes the order handler to throw a REJECTED error if there are
    # any accumulated parameter errors, thus terminating order handling.
    # Ideally, the order handler should do as much error checking as 
    # possible before calling this routine.
    #
    # Every order handler should include at least one call to this
    # routine.  The final call should include the *-final* option,
    # which causes the order handler to throw a CHECKED error when
    # called from <check>.  Otherwise, <check> will executed valid
    # orders, which isn't the desired outcome.
    #
    # Syntax:
    #   returnOnError ?-final?

    proc returnOnError {{flag ""}} {
        # FIRST, Were there any errors?
        if {[dict size $trans(errors)] == 0} {
            # If this is the -final check, and we're just checking,
            # escape out of the order.
            if {$flag eq "-final" && $trans(checking)} {
                return -code error -errorcode CHECKED
            } else {
                # Just return normally.
                return
            }
        }

        # FINALLY, throw the accumulated errors at the specified
        # error level; this will terminate order processing.
        
        return -code error -errorcode $trans(level) $trans(errors)
    }

    # Proc: cancel
    #
    # Use this in the rare case where the user can interactively 
    # cancel an order that's in progress.

    proc cancel {} {
        return -code error -errorcode CANCEL \
            "The order was cancelled."
    }

    # Proc: setundo
    #
    # Sets the undo _script_ for the current order.  If the _script_ is
    # the empty string, or setundo is not called, then the order is not
    # undoable.
    #
    # Syntax:
    #   setundo script
    #
    #   script - An undo script

    proc setundo {script} {
        set trans(undo) $script
        return
    }

    #-------------------------------------------------------------------
    # Group: Utility Commands

    # Proc: Log
    #
    # Logs an entry to the debugging log.
    #
    # Syntax:
    #    Log _level message_
    #
    #    level   - The logger(n) verbosity level
    #    message - The message to log

    proc Log {level message} {
        callwith $info(logcmd) $level mop $message
    }

}