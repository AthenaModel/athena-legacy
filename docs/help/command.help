# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    command.help
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Athena Help Documentation: Executive Commands
#
#    This file is included into athena.help.
#
#    Command pages have paths like /command/{name}.  If the command's 
#    name has multiple tokens, they are connected by "/", as in 
#    "/command/parm/set".
#
#-----------------------------------------------------------------------

page / command "Executive Commands" {
    <<title>>
    Athena provides a command-line interface (CLI) at the bottom on
    the main window.  The CLI is primarily used during testing and
    development, as most user tasks are done via 
    <<cref /order "order dialogs">> and other GUI interactions.  However,
    there are a small number of tasks that the user can do by typing
    <i>executive commands</i> at the CLI.  Most of these are low-level
    tasks, such as calibrating the Athena models by setting model
    parameters.<p>

    This page lists the available commands.<p>

    <<childlinks>>
}

# command name text
#
# name     The name of the command, e.g., "parm set"
#
# Defines a command page, defining the parent/child links properly.

proc command {name text} {
    set parent [join [linsert [lrange $name 0 end-1] 0 /command] /]
    set slug   [lindex $name end]

    page $parent $slug $name $text
}


# syntax args
#
# args      The command's argument spec
#
# Formats the header for the command, including a link to the parent
# commands, if any.

macro syntax {args} {
    set fullname [pageinfo title]
    set prefix [lrange $fullname 0 end-1]
    set name   [lindex $fullname end]

    set ancestor "/command"
    set nametext ""

    foreach token $prefix {
        append ancestor /$token
        append nametext "[cref $ancestor $token] "
    }

    append nametext $name
    set toplink "<a href=\"/command\">Executive Command</a>"
} {
    |<--
    [mktitle small $toplink "$nametext [join $args { }]" ""]
}

# cli text
#
# text    A CLI script
#
# Formats a CLI dialog properly.

macro cli {text} {
    set text [string map {& &amp; < &lt; > &gt;} $text]
} {
    |<--
    <pre>[outdent $text]</pre><p>
}

# caution.debugging

macro caution.debugging {} {
    |<--
    <b>Caution:</b>  This command is intended for use by the Athena
    developers while debugging the simulation.  Careless use can
    corrupt the application.<p>
}

#=======================================================================
# = command

command "=" {
    <<syntax <i>expression...</i> >>

    Computes the value of an arithmetic expression:<p>

    <<cli {
        > = 1 + 1
        2
        >
    }>>

    Variables can be defined with <<command set>> and retrieved using
    "$" notation:<p>

    <<cli {
        > set num 5
        5
        > = $num * 2
        10
        >
    }>>
}

#=======================================================================
# advance command

command "advance" {
    <<syntax <i>days</i> >>

    Advances simulation time by the specified number of integer <i>days</i>,
    <<cref /command/lock>>ing the scenario first if necessary.
}

#=======================================================================
# call command

command "call" {
    <<syntax <i>script</i> ?<i>args...</i>? >>

    Calls the named <i>script</i>, which is assumed to be in the current
    working directory unless an absolute path is specified. The ".tcl"
    extension may be omitted; <b>call</b> will add it automatically.<p>

    An executive script is a Tcl script containing <<cref /command>>.  A
    number of standard Tcl commands may also be used.<p>

    When the script is executed, a list containing the optional
    arguments will be assigned to the variable <i>argv</i>.  If the 
    script takes arguments, and uses <<cref /command/call>> to call
    any other scripts, it should make a copy of its arguments
    beforehand, as using <<cref /command/call>> will overwrite 
    <i>argv</i>'s value.<p>
}

#=======================================================================
# clear command

command "clear" {
    <<syntax>>

    Clears the contents of the CLI's scrollback buffer.
}



#=======================================================================
# debug command

command "debug" {
    <<syntax>>
    <<caution.debugging>>
    Invokes a debugger window. The debugger is simply a Tcl interpreter
    with full access to the application's code and data; it's intended
    for developer use only. 
}

#=======================================================================
# dump commands

command "dump" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>

    This command is used to dump debugging information to the CLI, 
    particularly data that is not available on the various browser
    tabs.  It has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------
# dump coop

command "dump coop" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>
    
    This command allows dumps information related to GRAM's 
    cooperation model.  It has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------
# dump coop levels

command "dump coop levels" {
    <<syntax ?<i>driver</i>?>>
    
    Dumps a list of all active and future direct and indirect cooperation 
    level effects, in tabular format.  If <i>driver</i> is specified
    it must be a GRAM driver ID; the command will then dump only the
    effects related to that driver.
}

#-----------------------------------------------------------------------
# dump coop level

command "dump coop level" {
    <<syntax <i>f g</i> >>
    
    Dumps a list of all direct and indirect cooperation 
    level effects that currently affect the cooperation of 
    civilian group <i>f</i> with force group <i>g</i>.  The effects
    are grouped by <<term cause>>, so that it is  
    easy to determine that multiple effects with the same cause
    are handled properly.
}

#-----------------------------------------------------------------------
# dump coop slopes

command "dump coop slopes" {
    <<syntax ?<i>driver</i>?>>
    
    Dumps a list of all active and future direct and indirect cooperation 
    slope effects, in tabular format.  If <i>driver</i> is specified
    it must be a GRAM driver ID; the command will then dump only the
    effects related to that driver.
}

#-----------------------------------------------------------------------
# dump coop slope

command "dump coop slope" {
    <<syntax <i>f g</i> >>
    
    Dumps a list of all direct and indirect cooperation 
    slope effects that currently affect the cooperation of 
    civilian group <i>f</i> with force group <i>g</i>.  
    The effects are grouped by <<term cause>>, so that it is
    easy to determine that multiple effects with the same cause
    are handled properly.
}

#-----------------------------------------------------------------------
# dump econ

command "dump econ" {
    <<syntax ?<i>page</i>?>>
    
    Dumps the Economic model's cell values and formulas.  By default,
    <i>page</i> defaults to <b>Out</b>, the model's output page.  
    To see all pages, enter<p>

    <pre>
        dump econ all
    </pre>

    You can also request any particular page, e.g., <b>null</b>, <b>In</i>, 
    <b>Out</b>.
}

#-----------------------------------------------------------------------
# dump sat

command "dump sat" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>
    
    This command allows dumps information related to GRAM's 
    satisfaction model.  It has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------
# dump sat levels

command "dump sat levels" {
    <<syntax ?<i>driver</i>?>>
    
    Dumps a list of all active and future direct and indirect satisfaction 
    level effects, in tabular format.  If <i>driver</i> is specified
    it must be a GRAM driver ID; the command will then dump only the
    effects related to that driver.
}

#-----------------------------------------------------------------------
# dump sat level

command "dump sat level" {
    <<syntax <i>g c</i> >>
    
    Dumps a list of all direct and indirect satisfaction 
    level effects that currently affect the satisfaction of 
    group <i>g</i> with concern <i>c</i>.  
    The effects are grouped by <<term cause>>, so that it is
    easy to determine that multiple effects with the same cause
    are handled properly.
}

#-----------------------------------------------------------------------
# dump sat slopes

command "dump sat slopes" {
    <<syntax ?<i>driver</i>?>>
    
    Dumps a list of all active and future direct and indirect satisfaction 
    slope effects, in tabular format.  If <i>driver</i> is specified
    it must be a GRAM driver ID; the command will then dump only the
    effects related to that driver.
}

#-----------------------------------------------------------------------
# dump sat slope

command "dump sat slope" {
    <<syntax <i>g c</i> >>
    
    Dumps a list of all direct and indirect satisfaction 
    slope effects that currently affect the satisfaction of 
    group <i>g</i> with concern <i>c</i>.  The effects are grouped by
    <<term cause>>, so that it is
    easy to determine that multiple effects with the same cause
    are handled properly.
}

#=======================================================================
# ensit

command "ensit" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>
    
    This command queries information about environmental situations.
    It has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------
# ensit id

command "ensit id" {
    <<syntax <i>n stype</i> >>
    
    Returns the situation ID of the environmental situation of type
    <i>stype</i> in neighborhood <i>n</i>, if any, and the empty string
    otherwise.
}

command "ensit last" {
    <<syntax>>
    
    Returns the situation ID of the most recently created 
    environmental situation, or the empty string if none.
}

#=======================================================================
# errtrace command

command "errtrace" {
    <<syntax>>
    Returns the stack trace associated with the last command which
    returned an error, and also saves it to the debugging log.
    This command is a debugging aid, and has no
    effect on the execution of the program.
}

#=======================================================================
# export command

command "export" {
    <<syntax <i>scriptFile</i>>>
    Exports the orders shown on <<tab orders/sent>> to a script file
    that can be executed to reproduce the current scenario at the
    current simulation time.  Execute the script in a new, empty 
    scenario using the <<command call>> command.<p>

    The script file will be saved in the current working directory.<p>
}

#=======================================================================
# help command

command "help" {
    <<syntax ?-info? ?<i>command...</i>? >>

    This command accesses the on-line help for Athena's
    <<cref /command>>.  To display a list of all commands, enter this
    command with no arguments:<p>

    <<cli {
        > help
        >
    }>>

    To request help for a particular command, enter it on the command
    line.  For example, to see the help page for the 
    <<command parm set>> command, enter the following:<p>

    <<cli {
        > help parm set
        >
    }>>

    The <b>-info</b> option is for use in debugging the Athena
    Executive; if specified, the <b>help</b> command will dump
    implementation info to the CLI.
}

#=======================================================================
# last_mad command

command "last_mad" {
    <<syntax>>

    Returns the ID of the most recently created Magic Attitude
    Driver (MAD).  A script can create a MAD by 
    <<cref /command/send>>ing the <<cref /order/mad/create>> order,
    and then retrieve the ID of the new MAD using this command, for use
    when sending or scheduling other <<cref /order/mad>> orders.
}

#=======================================================================
# load command

command "load" {
    <<syntax <i>filename</i> >>

    Loads the scenario data (including simulation results, if any)
    from the given <i>filename</i>, overwriting any existing scenario.
    If the requested scenario cannot be loaded, the application will be
    left with an empty scenario.
}

#=======================================================================
# lock command

command "lock" {
    <<syntax>>

    <b>Scenario Preparation only.</b> Locks the scenario so that 
    simulation time can advance.  Does a sanity check of the scenario
    data; the lock will fail if the scenario is incomplete.<p>

    The scenario can later be unlocked using the 
    <<cref /command/unlock>> command.<p>
}

#=======================================================================
# log command

command "log" {
    <<syntax <i>message</i> >>

    Writes the <i>message</i> to the debugging log with severity
    "normal", as component "script".  Contrast this command with
    <<cref /command/sigevent>>, which writes a message to the
    significant events log.<p>
}

#=======================================================================
# nbfill command

command "nbfill" {
    <<syntax <i>varname</i> >>

    This command directs the <<tab map>> tab to fill neighborhood
    polygons with a color based on the value of a particular 
    <<cref /var/n "Neighborhood Variable">>.  See the link for a list
    of the available variables.
}

#=======================================================================
# new command

command "new" {
    <<syntax>>

    Creates a new, empty scenario, throwing away any loaded scenario
    data (including simulation results).
}


#=======================================================================
# parm commands

command "parm" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>

    This command is used to set and query Athena's 
    <<cref /parmdb "model parameters">>.  It has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

command "parm defaults" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>
    
    This command allows the user to manage his own customized set of
    default <<cref /parmdb "model parameters">>, and share them among 
    different Athena scenarios.  Saved defaults are used for all new
    scenarios; also, a scenario's parameter settings can be reset to
    the user's default using the <<command parm reset>> command.
    It has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

command "parm defaults clear" {
    <<syntax>>
    
    This command deletes the user's own default settings for the 
    Athena <<cref /parmdb "model parameters">>.  New scenarios will
    then use the installation defaults rather than the user's.<p>
}

#-----------------------------------------------------------------------

command "parm defaults save" {
    <<syntax>>
    
    This command saves the current <<cref /parmdb "model parameter">> 
    settings as the user's defaults for new scenarios.
}

#-----------------------------------------------------------------------

command "parm export" {
    <<syntax <i>filename</i> >>
    
    Exports the current <<cref /parmdb "model parameter">> settings
    to a disk file; if the named file already exists, it is copied
    to "<i>filename</i>.bak".
}

#-----------------------------------------------------------------------

command "parm get" {
    <<syntax <i>parm</i> >>
    
    Retrieves the value of the named <<cref /parmdb "model parameter">>.
}

#-----------------------------------------------------------------------

command "parm import" {
    <<syntax <i>filename</i> >>
    
    Imports new <<cref /parmdb "model parameter">> values from
    the named file.  Note that some parameters are 
    <<cref /parmdb/locked "locked">> once time advances, and cannot be
    changed.<p>

    This command works by sending the <<cref /order/parm/import>> order.
}

#-----------------------------------------------------------------------

command "parm list" {
    <<syntax ?<i>pattern</i>?>>

    When called with no argument, this command lists the names and
    values of all parameters.  If given, <i>pattern</i> is a wild-card
    pattern; only matching parameters are included.  For example, the
    following command will list all parameters related to the FUELSHRT
    rule set:<p>

    <<cli {
        > parm list dam.FUELSHRT.*
        dam.FUELSHRT.active     yes
        dam.FUELSHRT.cause      FUELSHRT
        dam.FUELSHRT.nearFactor 0.0
        dam.FUELSHRT.farFactor  0.0

        >}>>
</pre>
}

#-----------------------------------------------------------------------

command "parm names" {
    <<syntax ?<i>pattern</i>?>>

    When called with no argument, this command lists the names of all
    parameters.  If given, <i>pattern</i> is a wild-card
    pattern; only matching parameters are included.  For example, the
    following command will list the names of all parameters related to 
    the FUELSHRT rule set:<p>

    <<cli {
        > parm names dam.FUELSHRT.*
        dam.FUELSHRT.active dam.FUELSHRT.cause dam.FUELSHRT.nearFactor dam.FUELSHRT.farFactor
        >}>>
</pre>
}


#-----------------------------------------------------------------------

command "parm reset" {
    <<syntax>>
    
    Resets all <<cref /parmdb "model parameters">> to their default
    values.  If the user has saved their own default settings using
    the <<command parm defaults>> command, these will be used;
    otherwise the installation defaults will be used.<p>

    Note that some parameters are 
    <<cref /parmdb/locked "locked">> once time advances past the
    <<term prep>> state, and cannot be changed.  Unlocked
    parameters will be reset; locked parameters will not.<p>

    This command works by sending the <<cref /order/parm/reset>> order.
}


#-----------------------------------------------------------------------

command "parm set" {
    <<syntax <i>parm value</i> >>
    
    Sets the named <<cref /parmdb "model parameter">> to the specified
    <i>value</i>.  Updated
    parameter values are saved automatically with the scenario; there
    is no need to <<cref /command/parm/export export>> the parameter
    settings in order to save them.<p>

    Note that some parameters are 
    <<cref /parmdb/locked "locked">> once time advances past the
    <<term prep>> state, and cannot be changed.<p>

    This command works by sending the <<cref /order/parm/set>> order.
}

#=======================================================================
# prefs commands

command "prefs" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>

    The <b>prefs</b> command sets and queries <<cref /prefs>>.
    Preference parameters are distinct from the <<cref /parmdb>> edited
    using the <<command parm>> command in that they apply to the application
    rather than to individual scenarios. Therefore,<p>

    <ul>
    <li> They are not saved in scenario files.
    <li> They do not affect the outcome of simulation runs. 
    </ul>

    This command has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

command "prefs get" {
    <<syntax <i>parm</i> >>
    
    Retrieves the value of the named preference parameter.
}

#-----------------------------------------------------------------------

command "prefs help" {
    <<syntax <i>parm</i> >>
    
    Displays the help string for the named preference parameter.
}

#-----------------------------------------------------------------------

command "prefs list" {
    <<syntax ?<i>pattern</i>?>>

    When called with no argument, this command lists the names and
    values of all preference parameters.  If given, <i>pattern</i> is
    a wild-card pattern; only matching parameters are included.
}

#-----------------------------------------------------------------------

command "prefs names" {
    <<syntax ?<i>pattern</i>?>>

    When called with no argument, this command lists the names of all
    preference parameters.  If given, <i>pattern</i> is a wild-card
    pattern; only matching parameters are included.
}


#-----------------------------------------------------------------------

command "prefs reset" {
    <<syntax>>
    
    Resets all preference parameters to their default
    settings.
}


#-----------------------------------------------------------------------

command "prefs set" {
    <<syntax <i>parm value</i> >>
    
    Sets the named preference parameter to the specified
    <i>value</i>.
}

#=======================================================================
# rdb commands

command "rdb" {
    <<syntax <i>subcommand</i> ?<i>args...</i>?>>

    Athena stores almost all of its working data in its run-time
    database, or RDB.  This command allows the user to query 
    the RDB directly; however, it cannot be used to modify the
    contents of the RDB.  Note that the <<command select>> command
    is often more convenient.<p>

    RDB queries are done using the SQL language, as implemented by
    SQLite3.  A discussion of SQL is beyond the scope of this
    document; see the documentation at 
    <tt>http://sqlite.org</tt> for more information.<p>

    This command has the following subcommands:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

command "rdb eval" {
    <<syntax <i>sql</i> >>

    Executes the <i>sql</i> query (usually a SELECT statement)
    and returns the result as an unformatted list
    of values.  This command can be useful in scripts; for interactive
    use, the <<command rdb query>> or <<command select>> command
    is almost always more appropriate.
}

#-----------------------------------------------------------------------

command "rdb query" {
    <<syntax <i>sql</i> >>

    Executes the <i>sql</i> query (usually a SELECT statement)
    and returns the result as a formatted table.  This command
    is appropriate for long, complex queries that are spread over
    multiple lines; for short queries, use <<command select>>
    instead.<p>

    For example,<p>

    <<cli {
        > rdb query {select g,forcetype from frcgroups}
        g       forcetype 
        ------- --------- 
        TALIBAN IRREGULAR 
        PAR     REGULAR   
        AQ      IRREGULAR 
        POLI    POLICE    
        TRIBMIL IRREGULAR 
        >}>>
}

#-----------------------------------------------------------------------

command "rdb schema" {
    <<syntax ?<i>table</i>?>>

    By default, this command returns the complete SQL schema for the
    RDB.  If a <i>table</i> or view name is given, it returns only the schema
    for that table or view.
}

#-------------------------------------------------------------------

command "rdb tables" {
    <<syntax>>

    Returns a list of the names of the tables defined in the 
    RDB's schema.  (Views are not included.)
}

#=======================================================================
# reset command

command "reset" {
    <<syntax>>

    Resets the executive interpreter.  Any user-defined variables or 
    Tcl procedures are deleted.
}


#=======================================================================
# save command

command "save" {
    <<syntax <i>filename</i> >>

    Saves the current scenario to disk, including simulation
    results if the scenario is <<cref /command/lock>>ed,
    using the given <i>filename</i>.  The saved scenario 
    can be loaded again using the <<cref /command/load>> command.<p>
}

#=======================================================================
# sched command

command "sched" {
    <<syntax <i>t order</i> ?<i>option value...</i>? >>

    Schedules the named <i>order</i> to be executed at time <i>t</i>,
    given the set of options and values.  The <<term timespec>>
    <i>t</i> must be no earlier than <b>NOW+1</b>.
    The option names are simply the parameter
    names as documented on the relevant <<cref /order>> page,
    <b>prefixed with a hyphen (-)</b>.  The order parameters are
    validated at the time the order is scheduled; if any are invalid,
    the order is rejected.
}

#=======================================================================
# select command

command "select" {
    <<syntax <i>sql...</i> >>

    The <b>select</b> command is a simplified version of 
    <<command rdb query>>, intended for interactive use with short,
    simple SQL queries.  The command has the form of a single SQL
    "SELECT" statement.  For example,<p>

    <<cli {
        > select g,forcetype from frcgroups
        g       forcetype 
        ------- --------- 
        TALIBAN IRREGULAR 
        PAR     REGULAR   
        AQ      IRREGULAR 
        POLI    POLICE    
        TRIBMIL IRREGULAR 
        >}>>

    If the query is longer than one line, consider using
    <<command rdb query>> instead.<p.
 
}

#=======================================================================
# send command

command "send" {
    <<syntax <i>order</i> ?<i>option value...</i>? >>

    Sends the named <i>order</i> to the simulation given the set of
    options and values.  The option names are simply the parameter
    names as documented on the relevant <<cref /order>> page,
    <b>prefixed with a hyphen (-)</b>.  If the order is rejected, the 
    error message is pretty-printed.
}


#=======================================================================
# show command

command "show" {
    <<syntax <i>url</i> >>

    Displays the requested URL in the <<tab detail>>.
}

#=======================================================================
# set command

command "set" {
    <<syntax <i>variable value</i> >>
    Assigns a value to a named variable.  By itself, this will have no
    effect on the execution of the simulation; however, variables can
    be used with other commands, such as the <<command =>> command.
}

#=======================================================================
# sigevent command

command "sigevent" {
    <<syntax <i>message</i> ?<i>tags...</i>? >>

    Writes the <i>message</i> to the significant events log
    as component "script".  Contrast this command with
    <<cref /command/log>>, which writes a message to the
    debugging log log.<p>

    The <i>tags</i>, if any, are used to tag the message with 
    group, actor, or neighborhood names, so that the message will show
    up in the Detail Browser in the context of the tagged entities.
    For example, the following message involves actor USA in
    neighborhood N1:<p>

    <<cli {
        > sigevent "USA has take action in N1" USA N1
        >
    }>>

    The message will then appear on actor USA's page and on
    neighborhood N1's page.
    
}

 
#=======================================================================
# super command

command "super" {
    <<syntax <i>args...</i> >>
    <<caution.debugging>>
    Concatenates its arguments into a single command, and executes
    that command in the context of the application rather than in the
    Athena Executive.
}


#=======================================================================
# unlock command

command "unlock" {
    <<syntax>>

    <b>Simulation only.</b> Unlocks the current scenario so that 
    the base scenario data can be changed, throwing away any existing
    simulation results.<p>

    The scenario can be locked again using the 
    <<cref /command/lock>> command.<p>
}


#=======================================================================
# usermode command

command "usermode" {
    <<syntax ?<i>mode</i>? >>
    <<caution.debugging>>
    Sets and queries the user mode.<p>

    Athena's executive runs in two modes, <b>normal</b> and
    <b>super</b>. In normal mode, user command entry is prevented from
    affecting application internals, i.e., the user can't kill or
    corrupt the application by mis-typing. Caution: In super mode, the
    CLI is attached directly to the application. Anything is possible,
    including damage to the user's scenario. <p>

    The <b>super</b> mode is intended primarily for use by the Athena
    developers; other users should consider using the <<command super>>
    command in the rare case that evading the normal protections is
    required.<p>

    <b>Note:</b> in <b>super</b> mode, the CLI's command prompt
    changes, as shown:<p>

    <<cli {
        > usermode super
        super> usermode normal
        >
    }>>
}


