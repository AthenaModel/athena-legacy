# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    athena.help
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Main Athena help(5) file
#
#-----------------------------------------------------------------------

#=======================================================================
# Images

image athena "Sculpture of the Goddess Athena" athena.png


#=======================================================================
# Macros

macro title {} {
    <font size=7>[pageinfo title]</font><p>
}

macro order {} {
    |<--
    <font size=7>[pageinfo title]</font><br>
    (<tt>[pageinfo name]</tt>)<p>
}

macro parm.identifier {entity example} {
    |<--
    The ID for the new $entity.  It may
    contain letters and digits, and must begin with a letter.  It may
    not be the same as the ID or long name of any existing
    neighborhood, group, etc.  It should usually be short, between 2
    and 8 characters in length, e.g., <b>$example</b>.
}

macro parm.longname {entity example} {
    |<--
    A short human-readable name for the
    $entity, e.g., "$example".  The long name must not be the
    same as the ID or long name of any existing
    neighborhood, group, etc.
}


#-----------------------------------------------------------------------

page home "Athena Help" {} {
    <img src="athena" align="right">

    This is the on-line help for <b>V<<version>></b> of the
    Athena Stability & Recovery Operations Simulation.<p>

    <ul>
    <li> <<cref changelog>>
    <li> <<cref about>>
    <li> <<cref release>>
    <li> <<cref using>>
         <<childlinks using>>
    <li> Athena Reference
         <ul>
         <li> <<cref menus>>
         <li> <<cref tabs>>
         <li> <<cref orders>>
         <li> <<cref reports>>
         <li> <<cref commands>>
         </ul>
    </ul><p>

    <hr>
    <i>Help compiled <<clock format [clock seconds]>>
}


#-----------------------------------------------------------------------

page about "About Athena" home {
    <img src="athena" align="right">

    <font size=7>Athena V<<version>></font><br>
    Stability and Recovery Operations Simulation<p>

    (C) 2009, California Institute of
    Technology. ALL RIGHTS RESERVED. U.S. Government sponsorship
    acknowledged. Any commercial use must be negotiated with the
    Office of Technology Transfer at the California Institute of
    Technology.<p>

    This software is subject to U. S. export control laws and
    regulations (22 C.F.R. 120-130 and 15 C.F.R. 730-774). To the
    extent that the software is subject to U.S. export control laws
    and regulations, the recipient has the responsibility to obtain
    export licenses or other export authority as may be required
    before exporting such information to foreign countries or
    providing access to foreign nationals.<p>
}

#-----------------------------------------------------------------------

page release "Release Notes" home {
    <font size=7>Athena V<<version>> Release notes</font><p>

    TBD.  These release notes should be filled in prior to delivery.<p>
}


#-----------------------------------------------------------------------

page changelog "Change Log" home {
    <<title>>
    <<changelog>>
    <<change 7/6/2009 New whd>>
    Initial draft.
    <</change>>
    <</changelog>>
}

#======================================================================
# Using Athena

page using "Using Athena" {} {
    <<title>>

    <<childlinks>>
}

#-----------------------------------------------------------------------

page using.prep "Scenario Preparation" using {
    <<title>>
    TBD:  This page will describe the "Scenario Prep" state, and how
    to prepare an Athena scenario.
}

#======================================================================

page orders "Orders" {} {
    <<title>>
    The analyst communicates with Athena by means of <i>orders</i>.
    Most orders are sent by means of an order dialog; some are sent
    implicitly.  For example, dragging a unit from one place to
    another on the map implicitly sends the <<cref UNIT:MOVE>> 
    order.  Order dialogs can be invoked in a number of ways, e.g., by
    selecting an order from the <<cref menu:orders>>.<p>

    Orders are grouped in the following categories:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

page ATTRIT: "Attrition Orders" orders {
    <<title>>

    Athena assesses attrition due to conflict between groups
    periodically; the period is nominally one week.  In addition,
    the analyst can cause magic attrition to unit personnel and to the 
    civilian population at any time.<p>

    <b>Note:</b> magic attrition takes effect immediately; however, the
    attitude effects resulting from magic attrition are assessed as
    part of the regular weekly attrition assessment.<p>

    <<childlinks>>
}

macro ATTRIT.responsible {} {
    |<--
    [parm g1 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]

    [parm g2 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]
}

macro ATTRIT.attitude {} {
    |<--
    <b>Attitude Implications:</b>  Civilian and organization
    casualties affect the satisfaction of the relevant groups.  If
    responsible force groups are specified, then civilian casualties
    will affect the cooperation of the civilian group with the
    responsible groups.<p>
}


#-----------------------------------------------------------------------

page ATTRIT:GROUP "Magic Attrit Group" ATTRIT: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm f "To Group">>
    <b>Required.</b>  The name of an existing civilian, force, or
    organization group to receive the casualites.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected group in
    a selected neighborhood.  The effect depends on the kind of
    group.<p>

    <b>Force and Organization Groups:</b>  The group's units are
    attrited by the specified number of casualties.  Athena assumes
    that units doing more important activities will be reinforced from
    units doing less important activities; therefore, units are
    attrited in priority order based on their activities, from lowest
    priority to greatest priority.  For example, a unit with activity
    <b>NONE</b> is attrited before one with activity <b>PATROL</b>.
    The priority order is <<cref Activity_Priorities>>.<p>

    <b>Civilian Groups:</b>  The group's units and implicit
    population are attrited proportionally to their size.<p>

    If the requested number of casualties exceeds the group's population in
    the neighborhood, then all of the group's units in the
    neighborhood will drop to zero personnel, and the group's implicit
    population will drop to one person.  (A group's implicit
    population may not be zero.)<p>

    If the group does not reside in the neighborhood, this order has
    no effect; therefore, civilian units outside their neighborhood of
    origin are never attrited by this order.<p>

    <<ATTRIT.attitude>>
}

#-----------------------------------------------------------------------

page ATTRIT:NBHOOD "Magic Attrit Neighborhood" ATTRIT: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    Attrits all civilians in the neighborhood by the specified number
    of casualties.  All civilian units and implicit populations are
    attrited proportionally to their size.  <b>Note:</b> unlike
    the <<cref ATTRIT:GROUP>> order, this order attrits civilian units
    from other neighborhoods along with those from this
    neighborhood.<p>

    If the neighborhood's total population is less than the requested
    number of casualties, then all of the civilian units in the
    neighborhood will be reduced to zero personnel and the implicit
    population of each neighborhood group will drop to one person.  (A
    neighborhood group's implicit population may not be zero.)<p>

    <<ATTRIT.attitude>>
}

#-----------------------------------------------------------------------

page ATTRIT:UNIT "Magic Attrit Unit" ATTRIT: {
    <<order>>
    <<parmlist>>

    <<parm u "Unit">>
    <b>Required.</b>  The name of an existing unit.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected unit.  The
    casualties are presumed to be dead, and are deducted from the
    unit's personnel.<p>

    <ul>
    <li> Unit attrition, and particularly civilian casualties, can
         affect civilian attitudes.
         
    <li> To change the number of personnel in the unit for reasons
         other than attrition, use the <<cref UNIT:PERSONNEL>> order.
    </ul><p>

    <<ATTRIT.attitude>>
}

#=======================================================================
# Cooperation Orders

page COOPERATION: "Cooperation Orders" orders {
    <<title>>

    Athena models the cooperation of neighborhood
    civilian groups with force groups, where cooperation is defined as
    in the TRAC HUMINT methodology: the likelihood that a member of
    the civilian group will give intelligence to a member of the force
    group.  This family of orders are used to manipulate the
    cooperation levels between various groups.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

page COOPERATION:UPDATE "Update Cooperation" COOPERATION: {
    <<order>>

    <<parmlist>>
    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of a neighborhood.
    <</parm>>

    <<parm f "Of Group">>
    <b>Required.</b>  The name of a civilian group resident in
    neighborhood <i>n</i>.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  The name of a force group.
    <</parm>>

    <<parm coop0 "Cooperation">>
    <b>Required.</b>  The initial cooperation level of group <i>f</i>
    with group <i>g</i> in neighborhood <i>n</i>.  Cooperation levels
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order updates the initial
    cooperation level of one group with another; this can only be done
    during the Scenario Preparation phase.  TBD: At present, there is
    no way to adjust the current cooperation level once time has
    advanced.
}

#=======================================================================
# Group Orders

page GROUP: "Group Orders" orders {
    <<title>>

    Athena models collections of people as <i>groups</i>.  There are
    three kinds of groups: <i>force groups</i>, which exist to apply
    and use force; <i>organization groups</i>, such as the Red Cross,
    USAID, and Haliburton; and <i>civilian groups</i>, such as
    Pashtuns and Punjabis. Civilian groups reside in neighborhoods,
    thereby forming <i>neighborhood groups</i>.  Most information
    about civilians in the playbox is entered for the individual
    neighborhood groups.<p> 

    Each kind of group has its own set of orders:<p>

    <<childlinks>>
}

macro GROUP.g {flavor} {
    |<--
    The ID of an existing $flavor group.
}

macro GROUP.color {} {
    |<--
    The group's color, used when displaying the group's units
    on the map viewer.  In general, group colors will be selected
    using the color selection dialog; if a color is entered as a
    string, it must be specified as a hex color string, of
    one of the following forms<p>

    #<i>rrggbb</i><br>
    #<i>rrrgggbbb</i><br>
    #<i>rrrrggggbbbb</i><p>

    where <i>r</i>, <i>g</i> and <i>b</i> are hexadecimal digits 
    expressing a shade of red, green, or blue.  Thus, "#000000" is
    black, and "#FFFFFF" is white.<p>
}

macro GROUP.shape {} {
    |<--
    According to MIL-STD-2525a, friendly, neutral, and enemy units
    are drawn differently by the map viewer.  This parameter
    determines whether the group's units are drawn as friendly,
    neutral, or enemy.  The possible values are as follows:<p>

    [enumdoc ::projectlib::eunitshape]
}

macro GROUP.demeanor {} {
    |<--
    The demeanor of the group, i.e., its propensity for
    violence. The possible values are as follows:<p>

    [enumdoc ::projectlib::edemeanor]
}

macro GROUP.rollup_weight {} {
    |<--
    The weight given to this group when rolling up satisfaction levels
    across groups to get neighborhood moods or playbox satisfaction
    levels.  It must be a non-negative real value, nominally 1.0.
    Reasonable values range from 0.5 to 2.0.
}

macro GROUP.effects_factor {} {
    |<--
    A factor used to scale the indirect effects on other
    groups of satisfaction effects on this group.
    across groups to get neighborhood moods or playbox satisfaction
    levels.  It must be a non-negative real value, nominally 1.0.
    Reasonable values range from 0.5 to 2.0.
}

#=======================================================================
# Civilian Group Orders

page GROUP:CIVILIAN: "Civilian Group Orders" GROUP: {
    <<title>>

    Athena uses civilian groups to model identifiable collections of
    people who reside in multiple neighborhoods, e.g., Pashtuns and
    Punjabis who reside in various parts of Pakistan.  Thus, defining
    a population of Pashtuns resident in Peshawar requires first
    defining Pashtuns in general. That's what this set of orders is for:<p>

    <<childlinks>>

    Then, the <<cref GROUP:NBHOOD:>> can be used to make the Pashtuns
    actually reside in Peshawar:

    <<childlinks GROUP:NBHOOD:>>
}

#-----------------------------------------------------------------------

page GROUP:CIVILIAN:CREATE "Create Civilian Group" GROUP:CIVILIAN: {
    <<order>>

    <<parmlist>>
    <<parm g "ID">>
    <b>Required.</b>  <<parm.identifier group PASH>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Required.</b> <<parm.longname group "Urban Pashtuns">>
    <</parm>>

    <<parm color "Color">>
    <b>Required.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Required.</b> <<GROUP.shape>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new civilian group.  The <<cref GROUP:NBHOOD:CREATE>> order can
    then be used to add the new group to neighborhoods.<p>
}


#-----------------------------------------------------------------------

page GROUP:CIVILIAN:DELETE "Delete Civilian Group" GROUP:CIVILIAN: {
    <<order>>
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    civilian group, along with all entities (e.g., neighborhood groups)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

page GROUP:CIVILIAN:UPDATE "Update Civilian Group" GROUP:CIVILIAN: {
    <<order>>

    <<parmlist>>
    <<parm g "ID">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "Urban Pashtuns">>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing civilian group.<p>
}


#=======================================================================
# Neighborhood Group Orders

page GROUP:NBHOOD: "Neighborhood Group Orders" GROUP: {
    <<title>>

    Athena uses civilian groups to model identifiable collections of
    people who reside in multiple neighborhoods, e.g., Pashtuns and
    Punjabis residing in various parts of Pakistan.  Defining a
    population of Pashtuns resident in Peshawar requires first
    defining Pashtuns in general, using the <<cref GROUP:CIVILIAN:>>.
    Then, this set of orders can be used to make the Pashtuns 
    actually reside in Peshawar.<p>

    <<childlinks>>
}

macro GROUP:NBHOOD.local_name {} {
    |<--
    A short, human-readable name the neighborhood group, e.g., 
    the name of a tribe, clan, etc.
}

macro GROUP:NBHOOD.basepop {} {
    |<--
    The initial population of the neighborhood group.  This population
    can be reduced by displacement to other neighborhoods, and by
    attrition.  An integer number no less than 1.
}


#-----------------------------------------------------------------------

page GROUP:NBHOOD:CREATE "Create Nbhood Group" GROUP:NBHOOD: {
    <<order>>

    <<parmlist>>
    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm g "Civ Group">>
    <b>Required.</b>  <<GROUP.g civilian>>  There must not already be
    a neighborhood group for this <b>n</b> and <b>g</b>.
    <</parm>>

    <<parm local_name "Local Name">>
    <b>Optional.</b> <<GROUP:NBHOOD.local_name>>  If no local name is
    given, the civilian group's long name will be used.
    <</parm>>

    <<parm basepop "Base Population">>
    <b>Required.</b> <<GROUP:NBHOOD.basepop>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Required.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm rollup_weight "Rollup Weight">>
    <b>Required.</b> <<GROUP.rollup_weight>>
    <</parm>>

    <<parm effects_factor "Effects Factor">>
    <b>Required.</b> <<GROUP.effects_factor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new neighborhood group, i.e., a civilian group resident in a
    neighborhood.  The <<cref GROUP:CIVILIAN:CREATE>> order can
    then be used to create civilian groups which can then be added to
    neighborhoods.<p>
}


#-----------------------------------------------------------------------

page GROUP:NBHOOD:DELETE "Delete Nbhood Group" GROUP:NBHOOD: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm g "Civ Group">>
    <b>Required.</b>  <<GROUP.g civilian>>  There must be
    a neighborhood group for this <b>n</b> and <b>g</b>.
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    neighborhood group, along with all entities (e.g., civilian units,
    satisfaction levels) that depend upon it.<p>
}

#-----------------------------------------------------------------------

page GROUP:NBHOOD:UPDATE "Update Civilian Group" GROUP:NBHOOD: {
    <<order>>

    <<parmlist>>
    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm g "Civ Group">>
    <b>Required.</b>  <<GROUP.g civilian>>   There must be
    a neighborhood group for this <b>n</b> and <b>g</b>.
    <</parm>>

    <<parm local_name "Local Name">>
    <b>Optional.</b> <<GROUP:NBHOOD.local_name>>
    <</parm>>

    <<parm basepop "Base Population">>
    <b>Optional.</b> <<GROUP:NBHOOD.basepop>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm rollup_weight "Rollup Weight">>
    <b>Optional.</b> <<GROUP.rollup_weight>>
    <</parm>>

    <<parm effects_factor "Effects Factor">>
    <b>Optional.</b> <<GROUP.effects_factor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing neighborhood group.<p>
}


#=======================================================================
# Force Group Orders

page GROUP:FORCE: "Force Group Orders" GROUP: {
    <<title>>

    Athena uses force groups to model groups and organizations that 
    exist to apply force, from the regular army to organized crime.
    The Force Group Orders are used to define these groups.

    <<childlinks>>

    Then, the <<cref UNIT:>> can be used to create units belonging
    to these groups.

    <<childlinks UNIT:>>
}

macro GROUP:FORCE.forcetype {} {
    |<--
    The force type: regular military, paramilitary (e.g., national
    police), police, irregular military (e.g., militias), or
    organized crime.

    [enumdoc ::projectlib::eforcetype]
}

macro GROUP:FORCE.uniformed {} {
    |<--
    Boolean flag (e.g., "Yes" or "No").  Indicates whether or not the
    group's personnel wear recognizeable uniforms.  This affects the
    offensive and defensive tactics used by the group.
}


macro GROUP:FORCE.local {} {
    |<--
    Boolean flag (e.g., "Yes" or "No").  Indicates whether or not the
    group is perceived as being local to the playbox.
}


macro GROUP:FORCE.coalition {} {
    |<--
    Boolean flag (e.g., "Yes" or "No").  Indicates whether or not the
    group is perceived as belonging to the U.S.-led coalition.<p>

    <b>NOTE:</b> This flag was inherited from JNEM; it is not
    currently used for anything, and might be deleted.
}

#-----------------------------------------------------------------------

page GROUP:FORCE:CREATE "Create Force Group" GROUP:FORCE: {
    <<order>>

    <<parmlist>>
    <<parm g "ID">>
    <b>Required.</b>  <<parm.identifier group BLUE>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Required.</b> <<parm.longname group "US Army">>
    <</parm>>

    <<parm color "Color">>
    <b>Required.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Required.</b> <<GROUP.shape>>
    <</parm>>

    <<parm forcetype "Force Type">>
    <b>Required.</b> <<GROUP:FORCE.forcetype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Required.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm uniformed "Uniformed?">>
    <b>Required.</b>  <<GROUP:FORCE.uniformed>>
    <</parm>>

    <<parm local "Local Group?">>
    <b>Required.</b>  <<GROUP:FORCE.local>>
    <</parm>>

    <<parm coalition "Coalition Member?">>
    <b>Required.</b>  <<GROUP:FORCE.coalition>>
    <</parm>>


    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new force group.
}


#-----------------------------------------------------------------------

page GROUP:FORCE:DELETE "Delete Force Group" GROUP:FORCE: {
    <<order>>
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    force group, along with all entities (e.g., units)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

page GROUP:FORCE:UPDATE "Update Force Group" GROUP:FORCE: {
    <<order>>

    <<parmlist>>
    <<parm g "ID">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "U.S. Army">>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm forcetype "Force Type">>
    <b>Optional.</b> <<GROUP:FORCE.forcetype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm uniformed "Uniformed?">>
    <b>Optional.</b>  <<GROUP:FORCE.uniformed>>
    <</parm>>

    <<parm local "Local Group?">>
    <b>Optional.</b>  <<GROUP:FORCE.local>>
    <</parm>>

    <<parm coalition "Coalition Member?">>
    <b>Optional.</b>  <<GROUP:FORCE.coalition>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing force group.<p>
}


#=======================================================================
# Organization Group Orders

page GROUP:ORGANIZATION: "Organization Group Orders" GROUP: {
    <<title>>

    Athena uses organization groups to model organizations that are
    active in the playbox and have a significant affect on civilian
    attitudes.  Such groups might include the Red Cross, Doctors Without
    Borders, US AID, and Haliburton.  The Organization Group Orders
    are used to define these groups.

    <<childlinks>>

    Then, the <<cref UNIT:>> can be used to create units belonging
    to these groups.

    <<childlinks UNIT:>>
}

macro GROUP:ORGANIZATION.orgtype {} {
    |<--
    The organization type.

    [enumdoc ::projectlib::eorgtype]
}


#-----------------------------------------------------------------------

page GROUP:ORGANIZATION:CREATE "Create Organization Group" GROUP:ORGANIZATION: {
    <<order>>

    <<parmlist>>
    <<parm g "ID">>
    <b>Required.</b>  <<parm.identifier group RC>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Required.</b> <<parm.longname group "Red Cross">>
    <</parm>>

    <<parm color "Color">>
    <b>Required.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Required.</b> <<GROUP.shape>>
    <</parm>>

    <<parm orgtype "Organization Type">>
    <b>Required.</b> <<GROUP:ORGANIZATION.orgtype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Required.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm rollup_weight "Rollup Weight">>
    <b>Required.</b> <<GROUP.rollup_weight>>
    <</parm>>

    <<parm effects_factor "Effects Factor">>
    <b>Required.</b> <<GROUP.effects_factor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new organization group.
}


#-----------------------------------------------------------------------

page GROUP:ORGANIZATION:DELETE "Delete Organization Group" GROUP:ORGANIZATION: {
    <<order>>
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    organization group, along with all entities (e.g., units)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

page GROUP:ORGANIZATION:UPDATE "Update Organization Group" GROUP:ORGANIZATION: {
    <<order>>

    <<parmlist>>
    <<parm g "ID">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "Red Cross">>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm orgtype "Organization Type">>
    <b>Optional.</b> <<GROUP:ORGANIZATION.orgtype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm rollup_weight "Rollup Weight">>
    <b>Optional.</b> <<GROUP.rollup_weight>>
    <</parm>>

    <<parm effects_factor "Effects Factor">>
    <b>Optional.</b> <<GROUP.effects_factor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing organization group.<p>
}




#=======================================================================
# Neighborhood Orders

page NBHOOD: "Neighborhood Orders" orders {
    <<title>>

    The Athena playbox, or region of interest, is divided into 
    neighborhoods.  A neighborhood is a polygonal area on the map
    containing civilian groups, units of various kinds, environmental
    situations, and so forth.<p>

    Neighborhoods can be stacked one on another; the upper
    neighborhood covers any lower neighborhoods.  Although Athena does
    not require it, it's customary to stack neighborhoods so that they
    nest.  The one restriction on nesting is that a neighborhood
    cannot cover another neighborhood's reference point.<p>

    Neighborhoods can only be created, updated, and deleted during 
    <<cref using.prep>>.<p>

    <<childlinks>>
}

macro NBHOOD.n {} {
    |<--
    The ID of an existing neighborhood.
}

macro NBHOOD.urbanization {} {
    |<--
    The neighborhood's urbanization level:
    [enumdoc ::projectlib::eurbanization]
}

macro NBHOOD.vtygain {} {
    |<--
    The neighborhood's volatility gain, a real
    number no less than zero; it is used to dial up and down the
    effect of neighborhood volatility on neighborhood security.
    See [cref Neighborhood_Security] for more information.
}

macro NBHOOD.refpoint {} {
    |<--
    The neighborhood's reference point, expressed as
    a [cref mapref "map reference string"].  The reference point is
    a location within the neighborhood that is guaranteed not to be
    obscured by an overlapping or nested neighborhood.
}

macro NBHOOD.polygon {} {
    |<--
    The neighborhood's boundary polygon, expressed as
    a list of [cref mapref "map reference strings"].
}

#-----------------------------------------------------------------------

page NBHOOD:CREATE "Create Neighborhood" NBHOOD: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<parm.identifier neighborhood N1>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Required.</b>  <<parm.longname neighborhood "Peshawar">>
    <</parm>>

    <<parm urbanization "Urbanization">>
    <b>Required.</b>  <<NBHOOD.urbanization>>
    <</parm>>

    <<parm vtygain "Volatility Gain">>
    <b>Required.</b>  <<NBHOOD.vtygain>>
    <</parm>>

    <<parm refpoint "Reference Point">>
    <b>Required.</b>  <<NBHOOD.refpoint>>
    <</parm>>

    <<parm polygon "Polygon">>
    <b>Required.</b> <<NBHOOD.polygon>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new neighborhood.
}

#-----------------------------------------------------------------------

page NBHOOD:DELETE "Delete Neighborhood" NBHOOD: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    neighborhood, along with all entities (e.g., neighborhood groups)
    that depend upon it.<p>
}


#-----------------------------------------------------------------------

page NBHOOD:LOWER "Lower Neighborhood" NBHOOD: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Lowers a neighborhood
    to the bottom of the stacking order, so that all overlapping
    neighborhoods are stacked upon this one, and then determines
    whether this neighborhood is obscured by any of those above it.
    (One neighborhood obscures another if it covers the other
    neighborhood's reference point.)
}


#-----------------------------------------------------------------------

page NBHOOD:RAISE "Raise Neighborhood" NBHOOD: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Raises a neighborhood
    to the top of the stacking order, so that all overlapping
    neighborhoods are underneath it, and then determines
    whether this neighborhood obscures any of those below it.
    (One neighborhood obscures another if it covers the other
    neighborhood's reference point.)
}


#-----------------------------------------------------------------------

page NBHOOD:UPDATE "Update Neighborhood" NBHOOD: {
    <<order>>
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b>  <<parm.longname neighborhood "Peshawar">>
    <</parm>>

    <<parm urbanization "Urbanization">>
    <b>Optional.</b>  <<NBHOOD.urbanization>>
    <</parm>>

    <<parm vtygain "Volatility Gain">>
    <b>Optional.</b>  <<NBHOOD.vtygain>>
    <</parm>>

    <<parm refpoint "Reference Point">>
    <b>Optional.</b>  <<NBHOOD.refpoint>>
    <</parm>>

    <<parm polygon "Polygon">>
    <b>Optional.</b> <<NBHOOD.polygon>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies
    the definition of an existing neighborhood.
}


#=======================================================================
# Neighborhood Orders

page NBHOOD:RELATIONSHIP: "Neighborhood Relationship Orders" orders {
    <<title>>

    The Athena playbox, or region of interest, is divided into 
    <<cref NBHOOD: neighborhoods>>.  Neighborhoods are related
    to each other in two ways: by proximity, and by the time it takes
    attitude effects to spread.  The neighborhood relationship orders
    are used to edit these relationships.<p>

    Neighborhood relationships are created automatically for every
    pair of neighborhoods, and are deleted as necessary when
    neighborhoods are deleted.<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

page NBHOOD:RELATIONSHIP:UPDATE "Update Neighborhood Relationship" NBHOOD:RELATIONSHIP: {
    <<order>>

    <<parmlist>>
    <<parm m "Of Neighborhood">> 
    <b>Required.</b>  A neighborhood name.
    <</parm>>

    <<parm n "With Neighborhood">> 
    <b>Required.</b>  Another neighborhood name.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <<parm effects_delay "Effects Delay">> 
    <b>Optional.</b> Decimal days.  The attitude effects of events and
    situations in neighborhood <i>n</i> are felt in neighborhood
    <i>m</i> only after this number of days.
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies existing
    neighborhood relationships.<p>

    <b>TBD:</b>  At present, Athena allows the user to enter non-zero
    effects delays within a single neighborhood; however, GRAM
    presumes that there are no effects delays within a neighborhood 
    regardless of what the input data says.  This needs to be resolved.
}


#======================================================================

page reports "Reports" {} {
    <<title>>
    As it runs, Athena produces a variety of text reports; in addition,
    the user may request a variety of reports.  This section describes
    the available reports.<p>

    Orders are grouped in the following categories:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

page REPORT:DRIVER "Attitude Driver Report" reports {
    <<order>>
    <<parmlist>>

    <<parm state "Driver State">>
    <b>Required.</b>  The set of drivers to include in the report:<p>

    <ul>
    <li> <b>all</b>: All drivers
    <li> <b>active</b>:  All active drivers: those which are currently
    contributing to attitude change.
    <li> <b>inactive</b>: All inactive drivers: those which have
    contributed, or which are scheduled to do so in the future,
    but are not currently doing so.
    <li> <b>empty</b>: All drivers whose set of attitude inputs is
    empty.
    </ul>
    <</parm>>

    <</parmlist>>

    An attitude driver is an event or situation that drives attitude
    change.  Usually the set of active drivers is of the most
    interest; after a long run, the set of inactive drivers might be
    quite large.<p>

    Some few drivers will be "empty", having had no effect at all.
    For example, the effect of force group presence depends on the
    relationship between the neighborhood groups and the force group;
    if the relationships are all zero, the PRESENCE rules will fire
    but all of the attitude inputs will be 0.0, and hence will be
    ignored.<p>

    The following information is listed for each driver:<p>

    <<topiclist Column Description>>
    <<topic ID>>
    The driver ID.  Driver IDs are assigned in numerical order 
    to drivers as they are created.  Because newer drivers have higher
    IDs, the drivers are listed by ID in descending order.
    <</topic>>

    <<topic Type>>
    The driver type.  Usually, this will be the name of one of the
    Driver Assessment Model's rule sets.
    <</topic>>

    <<topic Name>>
    The driver's name.  For example, situations will have names like
    "Sit 34" where "34" is the situation ID.
    <</topic>>

    <<topic Description>>
    A brief description of the driver.
    <</topic>>

    <<topic State>>
    The driver's state: active, inactive, or empty, as described
    above.
    <</topic>>

    <<topic "Start Time">>
    The time at which the driver first started (or will first start)
    to change attitudes in the playbox.
    <</topic>>

    <<topic "End Time">>
    The time at which the driver stopped (or will stop) changing
    attitudes in the playbox.  For on-going situations, this column will
    contain the word "On-going" instead of a Zulu time.
    <</topic>>

    <</topiclist>>

}


#===================================================================
# Concepts

page concepts "Athena Concepts" {} {
    <<title>>
    This page describes a number of general concepts used by the
    Athena models and software.<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

page Activity_Priorities "Activity Priorities" concepts {
    <<title>>

    TBD: This page will list the unit activities in priority order.
}

#-------------------------------------------------------------------

page mapref "Map Reference Strings" concepts {
    <<title>>
    A map reference string is a six-character string that represents
    a point on the scenario's map.  It has the form
    <b><i>AnnAnn</i></b> where <i>A</i> is a letter from "A" to "K"
    (excluding "I") and <i>n</i> is a digit, "0" to "9".<p>

    <h2>Background</h2>

    Athena is designed to use any map image the analyst may have on
    hand, from a high-quality scan of a printed map to a snapshot of a
    map hand-drawn on a piece of paper.  Consequently, Athena cannot
    use geographic coordinates, as it cannot assume that maps are
    properly geo-referenced.<p>

    Instead, Athena uses X,Y coordinates in the range 0 to 999 for
    both axes.  The origin is at the upper left; positive X runs from
    left to right and positive Y from top to bottom.<p>

    These numeric X,Y coordinates are used internally; for input and
    output they are converted to the form shown above.  For example,
    the location (123,456) has reference string "B23E56".<p>

    Note that X and Y coordinates are scaled identically.  The lower
    right corner of a map 1000 pixels wide by 500 pixels high would
    have numeric map coordinates (999,499) and map reference string
    "K99E99".
}

#-------------------------------------------------------------------

page Neighborhood_Security "Neighborhood Security" concepts {
    <<title>>

    TBD: This page will describe the neighborhood security model.
}



