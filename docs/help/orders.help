# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    orders.help
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Athena Help Documentation: Orders
#
#    This file is included into athena.help.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------

page orders "Orders" {} {
    <<title>>
    The analyst communicates with Athena by means of <i>orders</i>.
    Most orders are sent by means of an order dialog; some are sent
    implicitly.  For example, dragging a unit from one place to
    another on the map implicitly sends the <<cref UNIT:MOVE>> 
    order.  Order dialogs can be invoked in a number of ways, e.g., by
    selecting an order from the <<cref menu/Orders>>.<p>

    Orders are grouped in the following categories:<p>

    <<childlinks>>
}

# order name title text
#
# name     The order's name (but see below)
# title    The order's title (e.g., menu item text)
# text     The documentation of the order.
#
# Defines a help page for one order.  The order hierarchy is determined
# automatically using the ":"'s in the order name.
#
# Sometimes a colon shouldn't add a new level to the order hierarchy,
# e.g., orders FOO:UPDATE and FOO:UPDATE:MULTI are at the same level.
# In this case, enter the latter as "FOO:UPDATE+MULTI".

proc order {name title text} {
    set tokens [split $name :]
    set parent [join [lrange $tokens 0 end-1] :]:
    set name [string map {+ :} $name]
    
    set text "<<order.header>>\n\n$text"
    page $name $title $parent $text
}

# Formats the title for an order page
macro order.header {} {
    |<--
    [mktitle normal "" [pageinfo title] "(<tt>[pageinfo name]</tt>)"]
}

macro parm.identifier {entity example} {
    |<--
    The ID for the new $entity.  It may
    contain letters and digits, and must begin with a letter.  It may
    not be the same as the ID or long name of any existing
    neighborhood, group, etc.  It should usually be short, between 2
    and 8 characters in length, e.g., <b>$example</b>.
}

macro parm.longname {entity example} {
    |<--
    A short human-readable name for the
    $entity, e.g., "$example".  If left empty on creation, the long 
    name defaults to the ${entity} ID.
}

macro parm.ids {entity} {
    |<--
    The IDs of two or more $entity entities, as selected in the GUI.
}

#-----------------------------------------------------------------------

page ACTIVITY: "Activity Scheduling Orders" orders {
    <<title>>

    The analyst assigns activities to personnel according to a schedule;
    each day, units are staffed to do the activities from the available 
    personnel.  These orders are used to schedule activities and
    manipulate the schedule.<p>

    These orders <b>do not</b> check whether sufficient personnel
    are available, as the number of personnel available can change
    dynamically as the simulation runs forward.  However, each
    scheduled activity has a priority, and activities are staffed in
    priority order.<p>

    <<childlinks>>
}


macro ACTIVITY.personnel {tag} {
    |<--
    [parm personnel "Personnel"]
    <b>$tag.</b> The number of personnel assigned to the
    activity.  Note that the activity will only be fully-staffed on
    any given day if sufficient personnel remain after all
    higher-priority activities are staffed.
    [/parm]
}

macro ACTIVITY.start {tag} {
    |<--
    [parm start "Start"]
    <b>$tag.</b> The first day on which the activity is scheduled,
    as a [term timespec].  While in [cref using.prep], the
    activity may be scheduled at time 0 ("<b>NOW</b>" or "<b>T0</b>");
    while in the <b>Paused</b> state, the earliest the activity can be
    scheduled is day following the current day ("<b>NOW+1</b>").
    [/parm]
}

macro ACTIVITY.finish {tag} {
    |<--
    [parm finish "Finish"]
    <b>$tag.</b> The last day on which the activity is scheduled,
    as a [term timespec], or <b>NEVER</b>, indicating that the
    activity is scheduled for the indefinite future.
    [/parm]
}

macro ACTIVITY.pattern {tag} {
    |<--
    [parm pattern "Schedule"]
    <b>$tag.</b> A [term calpattern] that determines the days (from
    <i>start</i> to <i>finish</i>) on which the activity is actually
    scheduled, e.g., e.g., daily or on particular days of the week.
    [/parm]
}



#-----------------------------------------------------------------------

order ACTIVITY:SCHEDULE "Schedule Activity" {
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  The name of an existing civilian, force, or
    organization group that will do the activity.
    <</parm>>

    <<parm n "From Nbhood">>
    <b>Required.</b>  The neighborhood from which the scheduled 
    personnel will be drawn.  For civilian groups, this must be the 
    group's neighborhood of residence; for force and organization groups, it
    is the neighborhood in which the personnel are stationed (see
    the <<cref PERSONNEL:>>).
    <</parm>>

    <<parm a "Activity">>
    <b>Required.</b>  The name of the activity to be scheduled.  It
    must be appropriate for group <i>g</i>.
    <</parm>>

    <<parm tn "In Nbhood">>
    <b>Required.</b>  The neighborhood in which the activity will be 
    conducted; defaults to neighborhood <i>n</i>.
    <</parm>>

    <<ACTIVITY.personnel "Required">>
    <<ACTIVITY.start     "Required">>
    <<ACTIVITY.finish    "Optional">>
    <<ACTIVITY.pattern   "Required">>

    <<parm priority "Priority">>
    <b>Optional.</b> Indicates the initial priority of this calendar
    item.  If <b>top</b>, the item will have priority over all other
    activities scheduled for group <i>g</i> from neighborhood
    <i>n</i> on a given day; if <b>bottom</b>, it will the lowest
    priority.  The priority can be changed using the
    <<cref ACTIVITY:PRIORITY>> order.
    <</parm>>

    <</parmlist>>

    Schedules a new activity <i>a</i> for group <i>g</i> in neighborhood
    <i>tn</i>, drawing the specified number of <i>personnel</i> from
    neighborhood <i>n</i>.  The activity is scheduled from day
    <i>start</i> to day <i>finish</i>, as indicated by the calendar
    <i>pattern</i>.  It will have the given <i>priority</i> with respect to
    other activities previously scheduled for group <i>g</i> and
    neighborhood <i>n</i>.<p>

    Note that the analyst can create two calendar items for the same
    group, activity, and pair of neighborhoods; if both are scheduled
    on the same day, and there is sufficient personnel, both will be
    staffed.
}

order ACTIVITY:UPDATE "Update Scheduled Activity" {
    <<parmlist>>

    <<parm cid "Item ID">>
    <b>Required.</b> The calendar item ID of the scheduled activity.
    <</parm>>

    <<parm g "Group">>
    <b>Display only.</b>  The name of the civilian, force, or
    organization group that will do the activity.
    <</parm>>

    <<parm n "From Nbhood">>
    <b>Display only.</b>  The neighborhood from which the scheduled 
    personnel are drawn.  For civilian groups, this is the 
    group's neighborhood of residence; for force and organization groups, it
    is the neighborhood in which the personnel are stationed (see
    the <<cref PERSONNEL:>>).
    <</parm>>

    <<parm a "Activity">>
    <b>Display only.</b>  The name of the scheduled activity.
    <</parm>>

    <<parm tn "In Nbhood">>
    <b>Display only.</b>  The neighborhood in which the activity is
    scheduled to be conducted.
    <</parm>>

    <<ACTIVITY.personnel "Required">>
    <<ACTIVITY.start     "Required">>
    <<ACTIVITY.finish    "Optional">>
    <<ACTIVITY.pattern   "Required">>
    
    <</parmlist>>

    Allows the analyst to modify a scheduled activity.  The group,
    activity, and neighborhoods are shown as a convenience, but once
    an activity is scheduled they are fixed and cannot be changed; if
    they are incorrect, use <<cref ACTIVITY:CANCEL>> to cancel the
    activity and schedule a new one.<p>

    Note that when editing an activity that started at some point in
    the past, the <i>start</i> parameter must be updated to no earlier
    than <b>NOW+1</b>.<p>
}

order ACTIVITY:CANCEL "Cancel Scheduled Activity" {
    <<parmlist>>

    <<parm cid "Item ID">>
    <b>Required.</b> The calendar item ID of the scheduled activity.
    <</parm>>

    <<parm g "Group">>
    <b>Display only.</b>  The name of the civilian, force, or
    organization group that will do the activity.
    <</parm>>

    <<parm n "From Nbhood">>
    <b>Display only.</b>  The neighborhood from which the scheduled 
    personnel are drawn.  For civilian groups, this is the 
    group's neighborhood of residence; for force and organization groups, it
    is the neighborhood in which the personnel are stationed (see
    the <<cref PERSONNEL:>>).
    <</parm>>

    <<parm a "Activity">>
    <b>Display only.</b>  The name of the scheduled activity.
    <</parm>>

    <<parm tn "In Nbhood">>
    <b>Display only.</b>  The neighborhood in which the activity is
    scheduled to be conducted.
    <</parm>>

    <<parm personnel "Personnel">>
    <b>Display only.</b> The number of personnel assigned to the
    activity.
    <</parm>>

    <<parm narrative "Schedule">>
    <b>Display only.</b> An English sentence summarizing the time
    interval and <<term calpattern>> for which the activity is scheduled.
    <</parmlist>>

    Allows the analyst to cancel a scheduled activity.
}

order ACTIVITY:PRIORITY "Prioritize Scheduled Activity" {
    <<parmlist>>

    <<parm cid "Item ID">>
    <b>Required.</b> The calendar item ID of the scheduled activity.
    <</parm>>

    <<parm priority "Priority">>
    <b>Required.</b>  The item's new priority with respect to
    other activities having the same group and neighborhood of origin.
    Possible values are <b>top</b>, <b>bottom</b>, <b>raise</b>, and
    <b>lower</b>.  The values <b>top</b> and <b>bottom</b> give the
    item the highest or lowest priority among the scheduled
    activities; the values <b>raise</b> and <b>lower</b> move the item
    up or down one step.
    <</parm>>

    <</parmlist>>

    Allows the analyst to change the priority of a scheduled activity.
}

#=======================================================================
# Actor Orders

macro ACTOR.a {} {
    |<--
    The ID of an existing actor.
}

macro ACTOR.budget {} {
    |<--
    The actor's budget, in dollars per year.  This limits the
    actor's tactics.<p>

    This parameter is temporary, and will go away once the economic 
    model is providing the budgets to each actor. 
}

page ACTOR: "Actor Orders" orders {
    <<title>>

    Athena uses actors to model political actors of various kinds:
    political leaders, important parties, foreign countries, and so forth.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ACTOR:CREATE "Create Actor" {
    <<parmlist>>
    <<parm a "Actor">>
    <b>Required.</b>  <<parm.identifier actor USA>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname actor "United States">>
    <</parm>>

    <<parm budget "Budget $/Yr">>
    <b>Optional.</b> <<ACTOR.budget>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new actor.
}


#-----------------------------------------------------------------------

order ACTOR:DELETE "Delete Actor" {
    <<parmlist>>

    <<parm a "Actor">>
    <b>Required.</b>  <<ACTOR.a>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    actor, along with all entities (e.g., beliefs)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

order ACTOR:UPDATE "Update Actor" {
    <<parmlist>>
    <<parm a "Select Actor">>
    <b>Required.</b>  <<ACTOR.a>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname actor "United States">>
    <</parm>>

    <<parm budget "Budget $/Yr">>
    <b>Optional.</b> <<ACTOR.budget>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing actor.<p>
}

#-----------------------------------------------------------------------

page ATTRIT: "Attrition Orders" orders {
    <<title>>

    Athena assesses attrition due to conflict between groups
    periodically; the period is nominally one week.  In addition,
    the analyst can cause magic attrition to unit personnel and to the 
    civilian population at any time.<p>

    <b>Note:</b> Magic attrition takes effect immediately; however, the
    attitude effects resulting from magic attrition are assessed as
    part of the regular weekly attrition assessment.<p>

    <<childlinks>>
}

macro ATTRIT.responsible {} {
    |<--
    [parm g1 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]

    [parm g2 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]
}

macro ATTRIT.general {} {
    |<--
    <b>Staffing Pools:</b>  Every unit is staffed from a staffing
    pool.  For civilian units, the staffing pool is the base
    population of the group in its neighborhood of residence; for force
    and organization units, the staffing pool is the number of
    personnel stationed in the unit's neighborhood of origin.
    
    Attrition reduces not only the number of personnel in the affected
    units, but also the number of personnel available in the group's
    staffing pool.<p>

    <b>Attitude Implications:</b>  Civilian and organization
    casualties affect the satisfaction of the relevant groups.  If
    responsible force groups are specified, then civilian casualties
    will affect the cooperation of the civilian group with the
    responsible groups.<p>
}


#-----------------------------------------------------------------------

order ATTRIT:GROUP "Magic Attrit Group" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm f "To Group">>
    <b>Required.</b>  The name of an existing civilian, force, or
    organization group to receive the casualites.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected group's
    units in a selected neighborhood.  The group's units are attrited
    proportional to their size, i.e., a unit twice as big as another
    will take twice the casualties.  Additional effects depend on
    the kind of group.<p>

    <<ATTRIT.general>>
}

#-----------------------------------------------------------------------

order ATTRIT:NBHOOD "Magic Attrit Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    Attrits all civilian units in the neighborhood by the specified number
    of casualties.  Units are attrited proportionally to their size,
    i.e., a unit twice as big as another will take twice the
    casualties.<p>

    <<ATTRIT.general>>
}

#-----------------------------------------------------------------------

order ATTRIT:UNIT "Magic Attrit Unit" {
    <<parmlist>>

    <<parm u "Unit">>
    <b>Required.</b>  The name of an existing unit.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected unit.  The
    casualties are presumed to be dead, and are deducted from the
    unit's personnel.<p>

    <<ATTRIT.general>>
}

#=======================================================================
# Condition Orders

page CONDITION: "Condition Orders" orders {
    <<title>>

    A <<term condition>> is a Boolean predicate that can be
    attached to a <<term tactic>> or <<term goal>>.
    There are many different types of condition, each of
    which has its own "CREATE" and "UPDATE" orders; other orders are
    shared by all condition types.<p>

    The general condition orders and condition types are as follows:<p>

    <<childlinks>>
} 

macro CONDITION.ctactic {} {
    |<--
    [parm tactic_id "Tactic ID"]
    <b>Required.</b>  The ID of the tactic to which this condition
    is attached.
    [/parm]
}

macro CONDITION.utactic {} {
    |<--
    [parm tactic_id "Tactic ID"]
    <b>Display Only.</b>  The ID of the tactic to which this condition
    belongs. This parameter is displayed in the order dialog as an aid 
    to the user.
    [/parm]
}

macro CONDITION.id {} {
    |<--
    [parm condition_id "Condition ID"]
    <b>Required.</b> The ID of the condition to be updated.
    [/parm]
}

order CONDITION:DELETE "Delete Condition" {
    <<parmlist>>

    <<parm condition_id "Condition ID">>
    <b>Required.</b>  The ID of an existing condition.
    <</parm>>

    <<parm condition_type "Condition Type">>
    <b>Display Only.</b>  The condition's type.  
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>

    <<CONDITION.utactic>>
    
    <</parmlist>>

    Deletes the condition.
}

order CONDITION:STATE "Set Condition State" {
    <<parmlist>>

    <<parm condition_id "Condition ID">>
    <b>Required.</b>  The ID of an existing condition.
    <</parm>>

    <<parm state "State">>
    <b>Required.</b>  The condition's new state, one of: <b>normal</b>,
    <b>disabled</b>, or <b>invalid</b>.
    <</parm>>

    <</parmlist>>

    Sets the condition's state.  Note that this order is for internal use
    by the application; there is no associated order dialog.
}


#-----------------------------------------------------------------------
# Condition: CASH

page CONDITION:CASH: "Condition: Cash on hand" CONDITION: {
    <<title>>

    This condition compares an actor's cash-on-hand with a 
    user-specified amount.  The actor's cash-on-hand is the
    amount of money the actor has available to fund
    tactics.<p>

    The condition orders are as follows:<p>

    <<childlinks>>
}

order CONDITION:CASH:CREATE "Create Condition: Cash on hand" {
    <<parmlist>>
    <<CONDITION.ctactic>>

    <<parm a "Actor">>
    The name of the actor whose cash-on-hand is being compared.
    <</parm>>

    <<parm text1 "Comparison">>
    <b>Required.</b>  The kind of comparision being done: a value from
    the following table:<p>

    <<enumdoc ::projectlib::ecomparator>>
    <</parm>>

    <<parm x1 "Amount">>
    <b>Required.</b>  The amount of cash to which the actor's
    cash on hand will be compared.
    <</parm>>
    <</parmlist>>

    Creates the condition.
}

order CONDITION:CASH:UPDATE "Update Condition: Cash on hand" {
    <<parmlist>>
    <<CONDITION.id>>
    <<CONDITION.utactic>>

    <<parm a "Actor">>
    The name of the actor whose cash-on-hand is being compared.
    <</parm>>

    <<parm text1 "Comparison">>
    <b>Optional.</b>  The kind of comparision being done: a value from
    the following table:<p>

    <<enumdoc ::projectlib::ecomparator>>
    <</parm>>

    <<parm x1 "Amount">>
    <b>Optional.</b>  The amount of cash to which the actor's
    cash on hand will be compared.
    <</parm>>
    <</parmlist>>

    <</parmlist>>

    Allows the user to edit the condition.
}


#=======================================================================
# Cooperation Orders

page COOP: "Cooperation Orders" orders {
    <<title>>

    Athena models the cooperation of neighborhood
    civilian groups with force groups, where cooperation is defined as
    in the TRAC HUMINT methodology: the likelihood that a member of
    the civilian group will give intelligence to a member of the force
    group.  This family of orders are used to manipulate the
    initial cooperation levels between various groups.  (Use the
    <<cref MAD:COOP:>> to adjust or otherwise influence the 
    current levels.)<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order COOP:UPDATE "Update Initial Cooperation" {
    <<parmlist>>
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm coop0 "Cooperation">>
    <b>Optional.</b>  The initial cooperation level of group <i>f</i>
    with group <i>g</i>.  Cooperation levels
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal cooperation points per day.  The
    ascending trend is applied whenever the current cooperation level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal cooperation points per day.  The
    descending trend is applied whenever the current cooperation level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order updates the initial
    cooperation level of one group with another; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref MAD:>> to adjust or otherwise influence the 
    current levels.)
}

#-----------------------------------------------------------------------

order COOP:UPDATE+MULTI "Update Initial Cooperation (Multi)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids cooperation>><p>

    Programmatically, each ID is a list {<i>f g</i>} where
    <i>f</i> and <i>g</i> are defined as for the 
    <<cref COOP:UPDATE>> order.
    <</parm>>

    <<parm coop0 "Cooperation">>
    <b>Required.</b>  The initial cooperation level for the selected
    curves.  Cooperation levels
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal cooperation points per day.  The
    ascending trend is applied whenever the current cooperation level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal cooperation points per day.  The
    descending trend is applied whenever the current cooperation level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order updates the initial
    cooperation level for two or more cooperation curves, as selected 
    in the GUI.<p>

    (Use the <<cref MAD:>> to adjust or otherwise influence the 
    current levels.)
}

#=======================================================================
# Econ Model Orders

page ECON: "Economic Model Orders" orders {
    <<title>>

    This section describes the orders used to configure Athena's
    Economic Model.
}

macro ECON.pcf {} {
    |<--
    The production capacity factor (PCF) for the neighborhood, a
    non-negative real number.  This is a 
    multiplier used to dial up and down the production capacity for
    goods in a neighborhood. A factor of 1.0 usually indicates the
    production capacity at the beginning of the scenario; a factor
    less than 1.0 indicates that production capacity (e.g., factories)
    have been damaged, and a factor greater than 1.0 indicates that
    new production capacity has been built.<p>

    It is possible to being the scenario with a PCF less than 1.0,
    indicating that the neighborhood's capacity has already been
    seriously damaged as the scenario begins.
}


order ECON:UPDATE "Update Neighborhood Economic Inputs" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm pcf "Proc. Capacity Factor">>
    <b>Optional.</b>  <<ECON.pcf>>
    <</parm>>
    <</parmlist>>

    Updates the economic inputs for a single neighborhood.
}

#-----------------------------------------------------------------------

order ECON:UPDATE+MULTI "Update Economic Inputs for Multiple Neighborhoods" {
    <<parmlist>>

    <<parm ids "Neighborhoods">>
    <b>Required.</b>  <<parm.ids neighborhood>>
    <</parm>>

    <<parm pcf "Proc. Capacity Factor">>
    <b>Optional.</b>  <<ECON.pcf>>
    <</parm>>
    <</parmlist>>

    Updates the economic inputs for multiple neighborhoods.
}






#=======================================================================
# Environmental Situation Orders

page ENSIT: "Environmental Situation Orders" orders {
    <<title>>

    Athena models a variety of on-going conditions within
    neighborhoods; these are collectively referred to as
    <i>environmental situations</i>.  The set of situation types
    includes epidemics, contaminated food and water, power and
    communication outages, and so forth.  Detailed information about
    each situation type may be found in the Athena Rules document.<p>

    This family of orders is used to create, update, and resolve
    environmental situations.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

macro ENSIT.initial {} {
    |<--
    The numeric ID of an environmental situation that has not yet
    become active.  Ensits become active at the first time advance
    after their creation.
}

macro ENSIT.location {} {
    |<--
    The location of the situation, expressed as a 
    [term mapref].  The situation affects the
    neighborhood that contains this location, and so the location must
    lie within some neighborhood.
}

macro ENSIT.stype {} {
    |<--
    The type of situation.  There may be only one
    environmental situation of a given type in each neighborhood.<p>

    [enumdoc ::projectlib::eensit]
}

macro ENSIT.coverage {} {
    |<--
    Neighborhood coverage fraction, as a positive real number
    less than or equal to 1.0.  The coverage represents the fraction
    of the neighborhood's population that is affected by this situation.
}

macro ENSIT.inception {} {
    |<--
    A flag (<b>YES</b>, <b>NO</b>) that determines
    whether the situation has inception effects.  Set this to
    <b>NO</b> for situations that are to be on-going at time 0. 
}

macro ENSIT.g {} {
    |<--
    The name of the group that the neighborhood
    population considers responsible for causing this situation,
    or <b>NONE</b> if none.
}

macro ENSIT.rduration {} {
    |<--
    A duration, in integer days.  If positive, the
    situation will automatically be resolved at the end of the
    specified time. If 0, no auto-resolution will take place.<p>

    If this value is omitted, it will default to the value of the
    <b>ensit.<i>stype</i>.duration</b> [cref parmdb parameter].
}

#-----------------------------------------------------------------------

order ENSIT:CREATE "Create Environmental Situation" {
    <<parmlist>>
    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>
    <</parm>>

    <<parm stype "Type">>
    <b>Required.</b> <<ENSIT.stype>>
    <</parm>>

    <<parm coverage "Coverage">>
    <b>Required.</b> <<ENSIT.coverage>>
    <</parm>>

    <<parm inception "Inception?">>
    <b>Required.</b> <<ENSIT.inception>>
    <</parm>>

    <<parm g "Caused By">>
    <b>Required.</b>  <<ENSIT.g>>
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Required.</b>  The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  This entry is used when the situation
    resolves itself automatically; it can be overridden if the
    situation is resolved manually.
    <</parm>>

    <<parm rduration "Duration">>
    <b>Optional.</b>  <<ENSIT.rduration>>
    <</parm>>

    <</parmlist>>

    This order creates a new environmental situation.  Note that the
    <<cref ENSIT:UPDATE>> order can be used to
    edit any of these values so long as the situation has not yet
    become active, i.e., up until the next time advance.<p>
}

#-----------------------------------------------------------------------

order ENSIT:DELETE "Delete Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  <<ENSIT.initial>>
    <</parm>>
    <</parmlist>>

    Deletes an existing environmental situation.
}

#-----------------------------------------------------------------------

order ENSIT:UPDATE "Update Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  <<ENSIT.initial>>
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>
    <</parm>>

    <<parm stype "Type">>
    <b>Required.</b> <<ENSIT.stype>>
    <</parm>>

    <<parm coverage "Coverage">>
    <b>Required.</b> <<ENSIT.coverage>>
    <</parm>>

    <<parm inception "Inception?">>
    <b>Required.</b> <<ENSIT.inception>>
    <</parm>>

    <<parm g "Caused By">>
    <b>Required.</b>  <<ENSIT.g>>
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Required.</b>  The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  This entry is used when the situation
    resolves itself automatically; it can be overridden if the
    situation is resolved manually.
    <</parm>>

    <<parm rduration "Duration">>
    <b>Optional.</b>  <<ENSIT.rduration>>
    <</parm>>

    <</parmlist>>

    Updates an existing environmental situation that has not yet
    become active.
}


#-----------------------------------------------------------------------

order ENSIT:MOVE "Move Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  The numeric ID of any existing environmental
    situation.
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>  <b>Note:</b> If the ensit
    has already become active, it cannot be moved out of its
    neighborhood.
    <</parm>>

    <</parmlist>>

    Moves an existing environmental situation from one place to another.
}


order ENSIT:RESOLVE "Resolve Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  The numeric ID of any unresolved environmental
    situation.
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Optional.</b> The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  If specified, overrides the group name
    given when the situation was 
    <<cref ENSIT:CREATE created>>.
    <</parm>>

    <</parmlist>>

    Resolves an unresolved environmental situation.  Any on-going
    effects will be terminated, and the neighborhood population will
    usually respond favorably.
}

#=======================================================================
# Goal Orders

page GOAL: "Goal Orders" orders {
    <<title>>

    A <<term goal>> represents a state of affairs that an actor
    wishes to bring about.  The precise state of affairs is defined
    by one or more <<term condition>>s attached to the goal.

    The goal orders are as follows:<p>

    <<childlinks>>
} 

macro GOAL.id {} {
    |<--
    [parm goal_id "Goal ID"]
    <b>Required.</b> The ID of the goal to be updated.
    [/parm]
}

order GOAL:CREATE "Create Goal" {
    <<parmlist>>

    <<parm owner "Owner">>
    The name of the actor whose goal this is.
    <</parm>>

    <<parm narrative "Narrative">>
    <b>Required.</b>  A narrative description of the goal.  This will
    usually be a summary of the conditions attached to the goal.
    <</parm>>

    <</parmlist>>

    Creates the goal.
}

order GOAL:DELETE "Delete Goal" {
    <<parmlist>>

    <<parm goal_id "Goal ID">>
    <b>Required.</b>  The ID of an existing goal.
    <</parm>>
    
    <</parmlist>>

    Deletes the goal.
}

order GOAL:UPDATE "Update Goal" {
    <<parmlist>>
    <<GOAL.id>>

    <<parm owner "Owner">>
    <b>Display Only.</b> The name of the actor whose goal this is.
    <</parm>>

    <<parm narrative "Narrative">>
    <b>Required.</b>   A narrative description of the goal.  This will
    usually be a summary of the conditions attached to the goal.
    <</parm>>

    <</parmlist>>

    Allows the user to edit the goal.
}

order GOAL:STATE "Set Goal State" {
    <<parmlist>>

    <<parm goal_id "Goal ID">>
    <b>Required.</b>  The ID of an existing goal.
    <</parm>>

    <<parm state "State">>
    <b>Required.</b>  The goal's new state, one of: <b>normal</b>,
    <b>disabled</b>, or <b>invalid</b>.
    <</parm>>

    <</parmlist>>

    Sets the goal's state.  Note that this order is for internal use
    by the application; there is no associated order dialog.
}


#=======================================================================
# Group Orders

macro GROUP.g {flavor} {
    |<--
    The ID of an existing $flavor group.
}

macro GROUP.n {} {
    |<--
    The ID of an existing neighborhood, the group's neighborhood
    of residence.
}

macro GROUP.color {} {
    |<--
    The group's color, used when displaying the group's units
    on the map viewer.  In general, group colors will be selected
    using the color selection dialog; if a color is entered as a
    string, it must be specified as a hex color string, of
    one of the following forms<p>

    #<i>rrggbb</i><br>
    #<i>rrrgggbbb</i><br>
    #<i>rrrrggggbbbb</i><p>

    where <i>r</i>, <i>g</i> and <i>b</i> are hexadecimal digits 
    expressing a shade of red, green, or blue.  Thus, "#000000" is
    black, and "#FFFFFF" is white.<p>
}

macro GROUP.shape {} {
    |<--
    According to MIL-STD-2525a, friendly, neutral, and enemy units
    are drawn differently by the map viewer.  This parameter
    determines whether the group's units are drawn as friendly,
    neutral, or enemy.  The possible values are as follows:<p>

    [enumdoc ::projectlib::eunitshape]
}

macro GROUP.demeanor {} {
    |<--
    The demeanor of the group, i.e., its propensity for
    violence. The possible values are as follows:<p>

    [enumdoc ::projectlib::edemeanor]
}

macro GROUP.basepop {} {
    |<--
    The initial population of the group.  This population
    can be reduced by displacement to other neighborhoods, and by
    attrition.  An integer number no less than 1.
}

macro GROUP.sap {} {
    |<--
    The percentage of the group's population that supports itself by 
    subsistence agriculture, and hence does not participate in the
    regional economy.  An integer number from 0 to 100.
}

macro GROUP.a {} {
    |<--
    The group's owning actor.  This parameter may remain unset during
    [cref using.prep], but must be specified before time can be
    advanced.
}



#=======================================================================
# Civilian Group Orders

page CIVGROUP: "Civilian Group Orders" orders {
    <<title>>

    Athena uses civilian groups to model identifiable collections of
    people, e.g., Pashtuns and Punjabis.  Each group resides in a 
    single neighborhood.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order CIVGROUP:CREATE "Create Civilian Group" {
    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<parm.identifier group PASH>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "Urban Pashtuns">>
    <</parm>>

    <<parm n "Neighborhood">>
    <b>Required.</b> <<GROUP.n>>
    <</parm>>

    <<parm color "Color">>
    <b>Required.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Required.</b> <<GROUP.shape>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Required.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm basepop "Base Population">>
    <b>Required.</b> <<GROUP.basepop>>
    <</parm>>

    <<parm sap "Subsistence Agriculture Percentage">>
    <b>Required.</b> <<GROUP.sap>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new civilian group.
}


#-----------------------------------------------------------------------

order CIVGROUP:DELETE "Delete Civilian Group" {
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    civilian group, along with all entities (e.g., attitudes)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE "Update Civilian Group" {
    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "Urban Pashtuns">>
    <</parm>>

    <<parm n "Neighborhood">>
    <b>Optional.</b> <<GROUP.n>>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm basepop "Base Population">>
    <b>Optional.</b> <<GROUP.basepop>>
    <</parm>>

    <<parm sap "Subsistence Agriculture Percentage">>
    <b>Optional.</b> <<GROUP.sap>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing civilian group.<p>
}


#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+MULTI "Update Multiple Civilian Groups" {
    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "civilian group">>
    <</parm>>

    <<parm n "Neighborhood">>
    <b>Optional.</b> <<GROUP.n>>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm basepop "Base Population">>
    <b>Optional.</b> <<GROUP.basepop>>
    <</parm>>

    <<parm sap "Subsistence Agriculture Percentage">>
    <b>Optional.</b> <<GROUP.sap>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of two or more civilian groups, as selected in the GUI.<p>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+POSTPREP "Update Civilian Group (Post-PREP)" {
    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b> <<GROUP.g civilian>>
    <</parm>>

    <<parm sap "Subsistence Agriculture Percentage">>
    <b>Required.</b> <<GROUP.sap>>
    <</parm>>
    <</parmlist>>

    This order modifies the definition of an existing civilian
    group after leaving <<cref using.prep>>.  Only a subset of the
    group attributes can be edited.<p>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+POSTPREP+MULTI "Update Multiple Civilian Groups (Post-PREP)" {
    <<parmlist>>

    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "civilian group">>
    <</parm>>

    <<parm sap "Subsistence Agriculture Percentage">>
    <b>Required.</b> <<GROUP.sap>>
    <</parm>>

    <</parmlist>>

    This order modifies the
    definition of two or more civilian groups, as selected in the
    GUI, after leaving <<cref using.prep>>.  Only a subset of the 
    group attributes can be edited.<p>
}


#=======================================================================
# Force Group Orders

page FRCGROUP: "Force Group Orders" orders {
    <<title>>

    Athena uses force groups to model groups and organizations that 
    exist to apply force, from the regular army to organized crime.
    The Force Group Orders are used to define these groups.

    <<childlinks>>

    Then, the <<cref PERSONNEL:>> can be used to establish force
    levels in various neighborhoods, and the <<cref ACTIVITY:>> can be 
    used to schedule various activities by the group's personnel.
}

macro FRCGROUP.forcetype {} {
    |<--
    The force type: regular military, paramilitary (e.g., national
    police), police, irregular military (e.g., militias), or
    organized crime.

    [enumdoc ::projectlib::eforcetype]
}

macro FRCGROUP.uniformed {} {
    |<--
    Boolean flag (e.g., "Yes" or "No").  Indicates whether or not the
    group's personnel wear recognizeable uniforms.  This affects the
    offensive and defensive tactics used by the group.
}


macro FRCGROUP.local {} {
    |<--
    Boolean flag (e.g., "Yes" or "No").  Indicates whether or not the
    group is perceived as being local to the playbox.
}


#-----------------------------------------------------------------------

order FRCGROUP:CREATE "Create Force Group" {
    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<parm.identifier group BLUE>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "US Army">>
    <</parm>>

    <<parm a "Owning Actor">>
    <b>Optional.</b> <<GROUP.a>>
    <</parm>>

    <<parm color "Color">>
    <b>Required.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Required.</b> <<GROUP.shape>>
    <</parm>>

    <<parm forcetype "Force Type">>
    <b>Required.</b> <<FRCGROUP.forcetype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Required.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm uniformed "Uniformed?">>
    <b>Required.</b>  <<FRCGROUP.uniformed>>
    <</parm>>

    <<parm local "Local Group?">>
    <b>Required.</b>  <<FRCGROUP.local>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new force group.
}


#-----------------------------------------------------------------------

order FRCGROUP:DELETE "Delete Force Group" {
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    force group, along with all entities (e.g., units)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

order FRCGROUP:UPDATE "Update Force Group" {
    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "U.S. Army">>
    <</parm>>

    <<parm a "Owning Actor">>
    <b>Optional.</b> <<GROUP.a>>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm forcetype "Force Type">>
    <b>Optional.</b> <<FRCGROUP.forcetype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm uniformed "Uniformed?">>
    <b>Optional.</b>  <<FRCGROUP.uniformed>>
    <</parm>>

    <<parm local "Local Group?">>
    <b>Optional.</b>  <<FRCGROUP.local>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing force group.<p>
}


#-----------------------------------------------------------------------

order FRCGROUP:UPDATE+MULTI "Update Multiple Force Groups" {
    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "force group">>
    <</parm>>

    <<parm a "Owning Actor">>
    <b>Optional.</b> <<GROUP.a>>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm forcetype "Force Type">>
    <b>Optional.</b> <<FRCGROUP.forcetype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <<parm uniformed "Uniformed?">>
    <b>Optional.</b>  <<FRCGROUP.uniformed>>
    <</parm>>

    <<parm local "Local Group?">>
    <b>Optional.</b>  <<FRCGROUP.local>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of two or more force groups, as selected in the GUI.<p>
}


#=======================================================================
# Organization Group Orders

page ORGGROUP: "Organization Group Orders" orders {
    <<title>>
    Athena uses organization groups to model organizations that are
    active in the playbox and have a significant affect on civilian
    attitudes.  Such groups might include the Red Cross, Doctors Without
    Borders, US AID, and Haliburton.  The Organization Group Orders
    are used to define these groups.

    <<childlinks>>

    Then, the <<cref PERSONNEL:>> can be used to establish force
    levels in various neighborhoods, and the <<cref ACTIVITY:>> can be 
    used to schedule various activities by the group's personnel.
}

macro ORGGROUP.orgtype {} {
    |<--
    The organization type.<p>

    [enumdoc ::projectlib::eorgtype]
}


#-----------------------------------------------------------------------

order ORGGROUP:CREATE "Create Organization Group" {
    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<parm.identifier group RC>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "Red Cross">>
    <</parm>>

    <<parm a "Owning Actor">>
    <b>Optional.</b> <<GROUP.a>>
    <</parm>>

    <<parm color "Color">>
    <b>Required.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Required.</b> <<GROUP.shape>>
    <</parm>>

    <<parm orgtype "Organization Type">>
    <b>Required.</b> <<ORGGROUP.orgtype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Required.</b> <<GROUP.demeanor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new organization group.
}


#-----------------------------------------------------------------------

order ORGGROUP:DELETE "Delete Organization Group" {
    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    organization group, along with all entities (e.g., units)
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

order ORGGROUP:UPDATE "Update Organization Group" {
    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b> <<parm.longname group "Red Cross">>
    <</parm>>

    <<parm a "Owning Actor">>
    <b>Optional.</b> <<GROUP.a>>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm orgtype "Organization Type">>
    <b>Optional.</b> <<ORGGROUP.orgtype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of an existing organization group.<p>
}

#-----------------------------------------------------------------------

order ORGGROUP:UPDATE+MULTI "Update Multiple Organization Groups" {
    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "organization group">>
    <</parm>>

    <<parm a "Owning Actor">>
    <b>Optional.</b> <<GROUP.a>>
    <</parm>>

    <<parm color "Color">>
    <b>Optional.</b> <<GROUP.color>>
    <</parm>>

    <<parm shape "Unit Shape">>
    <b>Optional.</b> <<GROUP.shape>>
    <</parm>>

    <<parm orgtype "Organization Type">>
    <b>Optional.</b> <<ORGGROUP.orgtype>>
    <</parm>>

    <<parm demeanor "Demeanor">>
    <b>Optional.</b> <<GROUP.demeanor>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies the
    definition of two or more organization groups, as selected in the GUI.<p>
}

#=======================================================================
# Magic Attitude Driver Orders

page MAD: "Magic Attitude Driver Orders" orders {
    <<title>>

    Athena models a number of events and situations that drive
    attitude change, e.g., civilian attrition and environmental
    situations.  The set of drivers is not all encompassing, and so
    Athena allows the analyst to create <i>Magic Attitude Drivers</i>
    (MADs).  Once a MAD is created, the analyst may associate with it a
    variety of attitude adjustments and inputs; and the effects of
    these inputs will be associated with the MAD in the 
    <<cref REPORT:SAT:CONTRIB>>.<p>

    The following orders are used to create and manipulate MADs:<p>

    <<childlinks>>
}

macro MAD.mad {} {
    |<--
    The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
}

macro MAD.limit {} {
    |<--
    The magnitude of the level input in points, expressed as a real
    number, or as one of the symbols from the following table:<p>

    [::simlib::qmag html]
}

macro MAD.slope {} {
    |<--
    The slope of the input in points per day, expressed as a real
    number, or as one of the symbols from the following table:<p>

    [::simlib::qmag html]
}

macro MAD.days {} {
    |<--
    The realization time for the level input, in
    decimal days, expressed as a real number.  The input will take
    effect over this number of days.
}

macro MAD.athresh {} {
    |<--
    The ascending threshold for this input, in points.  The input
    will have no affect on curves whose value is greater than this
    amount.
}

macro MAD.dthresh {} {
    |<--
    The descending threshold for this input, in points.  The input
    will have no affect on curves whose value is less than this
    amount.
}

macro MAD.cause {} {
    |<--
    The [term cause] for any magic attitude input associated with
    this MAD.  The cause
    may be <b>UNIQUE</b>, indicating that the effects of this MAD
    are independent of all other drivers, or it may be
    any cause from the following list:<p>

    [enumdoc ::projectlib::ecause]
}

macro MAD.s {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in the same
    neighborhood as the input are multiplied by this factor.  
    If it is 0.0, there will be no such indirect effects.
}

macro MAD.p {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in <b>NEAR</b>
    neighborhoods are multiplied by this factor.  If it is 0.0, there
    will be no such indirect effects.
}

macro MAD.q {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in <b>FAR</b>
    neighborhoods are multiplied by 
    this factor.  If it is 0.0, there will be no such indirect effects.
}



#-----------------------------------------------------------------------

order MAD:CREATE "Create Magic Attitude Driver" {
    <<parmlist>>

    <<parm oneliner "Description">>
    <b>Required.</b>  A one-line description of the driver.
    <</parm>>

    <<parm cause "Cause">>
    <b>Required.</b> <<MAD.cause>>
    <</parm>>

    <<parm s "Here Factor">>
    <b>Required.</b> <<MAD.s>>
    <</parm>>

    <<parm p "Near Factor">>
    <b>Required.</b> <<MAD.p>>
    <</parm>>

    <<parm q "Far Factor">>
    <b>Required.</b> <<MAD.q>>
    <</parm>>
    
    <</parmlist>>

    Creates a new Magic Attitude Driver (MAD).  The description need
    not be unique, but should remind the analyst of the reason for the
    attitude inputs and adjustments associated with the MAD.<p>

    All magic level and slope inputs associated with this MAD will use
    the specified cause, near factor, and far factor.<p>

    <b>Note:</b> Once any attitude inputs or adjustments have been
    associated with this MAD, it can no longer be deleted; nor can its
    cause, near factor or far factor be changed.
}

#-------------------------------------------------------------------

order MAD:DELETE "Delete Magic Attitude Driver" {
    <<parmlist>>

    <<parm id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to delete.
    <</parm>>
    <</parmlist>>

    Deletes the specified MAD.  Note that a MAD cannot be deleted once
    any attitude inputs or adjustments have been associated with it.
}

#-------------------------------------------------------------------

order MAD:UPDATE "Update Magic Attitude Driver" {
    <<parmlist>>

    <<parm id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to update.
    <</parm>>

    <<parm oneliner "Description">>
    <b>Optional.</b>  A one-line description of the driver.
    <</parm>>

    <<parm cause "Cause">>
    <b>Optional.</b> <<MAD.cause>>
    <</parm>>

    <<parm s "Here Factor">>
    <b>Optional.</b> <<MAD.s>>
    <</parm>>

    <<parm p "Near Factor">>
    <b>Optional.</b> <<MAD.p>>
    <</parm>>

    <<parm q "Far Factor">>
    <b>Optional.</b> <<MAD.q>>
    <</parm>>
    
    <</parmlist>>

    Updates the MAD's definition.  Note that only the description can
    be changed once magic inputs have been entered for this MAD.
}

#-------------------------------------------------------------------

order MAD:TERMINATE "Terminate Magic Slope Inputs" {
    <<parmlist>>

    <<parm id "MAD ID">>
    <b>Required.</b>  The ID of a Magic Attitude Driver (MAD).
    <</parm>>
    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    This order terminates all currently on-going slope inputs created
    for this MAD using <<cref MAD:SAT:SLOPE>> or 
    <<cref MAD:COOP:SLOPE>>.  (Delayed indirect effects
    are terminated after a suitable delay.)
}

#=======================================================================
# Magic Satisfaction Orders

page MAD:SAT: "Magic Satisfaction Orders" MAD: {
    <<title>>

    These orders are used to set, adjust, and otherwise influence 
    satisfaction levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:SAT:ADJUST "Magic Adjust Satisfaction Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where <i>g</i> is a
    civilian group and <i>c</i> is a concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qmag html>>
    <</parm>>
    <</parmlist>>

    Immediately adjusts the value of the specified satisfaction curve by the
    specified amount, clamping the curve's value to the range -100.0,
    100.0 if need be.
}

#-----------------------------------------------------------------------

order MAD:SAT:SET "Magic Set Satisfaction Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where<i>g</i> is a
    civilian group residing and <i>c</i> is a concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm sat "sat">>
    <b>Required.</b>  The new value, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <</parmlist>>

    Immediately sets the value of the specified satisfaction curve to the
    specified amount.
}

#-----------------------------------------------------------------------

order MAD:SAT:LEVEL "Magic Satisfaction Level Input" {
    <<parmlist>>
    
    <<parm g "Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  A concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm limit "Limit">>
    <b>Required.</b>  <<MAD.limit>>
    <</parm>>

    <<parm days "Realization Time">>
    <b>Required.</b>  <<MAD.days>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic satisfaction level input into GRAM.  The input will
    change the specified curve's value by <i>limit</i> nominal points
    over a period of <i>days</i>.
}


#-----------------------------------------------------------------------

order MAD:SAT:SLOPE "Magic Satisfaction Slope Input" {
    <<parmlist>>
    
    <<parm g "Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  A concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm slope "Slope">>
    <b>Required.</b>  <<MAD.slope>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic satisfaction slope input into GRAM.  The input will
    change the specified curve's value by <i>slope</i> nominal points
    per day until the input is terminated.  The input will be
    attributed to the specified MAD.<p>

    A subsequent order for the same curve and MAD will change
    the slope of the existing slope input, rather than creating a new
    slope input.<p>

    The input can be terminated in two ways.  First, the specific
    input can be terminated by sending an identical order with a slope
    of 0.0.  Second, the <<cref MAD:TERMINATE>> order will terminate
    all ongoing slope effects for a particular MAD.
}

#=======================================================================
# Magic Cooperation Orders

page MAD:COOP: "Magic Cooperation Orders" MAD: {
    <<title>>

    These orders are used to set, adjust, and otherwise influence 
    cooperation levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:COOP:ADJUST "Magic Adjust Cooperation Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qmag html>>
    <</parmlist>>

    Adjusts the value of the specified cooperation curve by the
    specified amount, clamping the curve's value to the range 0.0,
    100.0 if need be.
}

#-----------------------------------------------------------------------

order MAD:COOP:SET "Magic Set Cooperation Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm coop "coop">>
    <b>Required.</b>  The new value, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qcooperation html>>
    <</parmlist>>

    Sets the value of the specified cooperation curve to the
    specified amount.
}

#-----------------------------------------------------------------------

order MAD:COOP:LEVEL "Magic Cooperation Level Input" {
    <<parmlist>>
    
    <<parm f "Of Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  A force group ID.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm limit "Limit">>
    <b>Required.</b>  <<MAD.limit>>
    <</parm>>

    <<parm days "Realization Time">>
    <b>Required.</b>  <<MAD.days>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic cooperation level input into GRAM.  The input will
    change the specified curve's value by <i>limit</i> nominal points
    over a period of <i>days</i>.  The input will be attributed to the
    specified MAD.
}


#-----------------------------------------------------------------------

order MAD:COOP:SLOPE "Magic Cooperation Slope Input" {
    <<parmlist>>
    
    <<parm f "Of Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  A force group ID.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm slope "Slope">>
    <b>Required.</b>  <<MAD.slope>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic cooperation slope input into GRAM.  The input will
    change the specified curve's value by <i>slope</i> nominal points
    per day until the input is terminated.  The input will be
    attributed to the specified MAD.<p>

    A subsequent order for the same curve and MAD will change
    the slope of the existing slope input, rather than creating a new
    slope input.<p>

    The input can be terminated in two ways.  First, the specific
    input can be terminated by sending an identical order with a slope
    of 0.0.  Second, the <<cref MAD:TERMINATE>> order will terminate
    all ongoing slope effects for a particular MAD.
}


#=======================================================================
# Map Orders

page MAP: "Map Orders" orders {
    <<title>>

    Athena allows the user to specify a map background to aid in both
    the construction of the scenario and the analysis and
    visualization of the results.  (See <<cref using.maps>> for more
    information.)  The following orders manipulate
    the image used as the map background:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAP:IMPORT "Import Map" {
    <<parmlist>>

    <<parm filename "Map File">>
    <b>Required.</b>  The name of a GIF, JPEG, or PNG image to be used
    as the map background.
    <</parm>>
    <</parmlist>>

    Imports an image into the scenario for use as the map background,
    replacing any previous map image.  The image data is saved within
    the scenario; it's not necessary to send the image file along with
    the saved .adb file.<p>

    This order is usually sent indirectly, using the
    <<menuref "File/Import Map...">> menu item.  However, Athena should
    eventually support order script, and it it is documented here for
    that purpose.
}




#=======================================================================
# Neighborhood Orders

page NBHOOD: "Neighborhood Orders" orders {
    <<title>>

    The Athena playbox, or region of interest, is divided into 
    neighborhoods.  A neighborhood is a polygonal area on the map
    containing civilian groups, units of various kinds, environmental
    situations, and so forth.<p>

    Neighborhoods can be stacked one on another; the upper
    neighborhood covers any lower neighborhoods.  Although Athena does
    not require it, it's customary to stack neighborhoods so that they
    nest.  The one restriction on nesting is that a neighborhood
    cannot cover another neighborhood's reference point.<p>

    Neighborhoods can only be created, updated, and deleted during 
    <<cref using.prep>>.<p>

    <<childlinks>>
}

macro NBHOOD.n {} {
    |<--
    The ID of an existing neighborhood.
}

macro NBHOOD.local {} {
    |<--
    Whether or not the neighborhood's labor force and production 
    capabilities contribute to the economy of the region of interest:<p>
    [enumdoc ::projectlib::eyesno]
}

macro NBHOOD.urbanization {} {
    |<--
    The neighborhood's urbanization level:<p>
    [enumdoc ::projectlib::eurbanization]
}

macro NBHOOD.vtygain {} {
    |<--
    The neighborhood's volatility gain, a real
    number no less than zero; it is used to dial up and down the
    effect of neighborhood [term volatility] 
    on neighborhood [term security].
}

macro NBHOOD.refpoint {} {
    |<--
    The neighborhood's reference point, expressed as
    a [term mapref].  The reference point is
    a location within the neighborhood that is guaranteed not to be
    obscured by an overlapping or nested neighborhood.
}

macro NBHOOD.polygon {} {
    |<--
    The neighborhood's boundary polygon, expressed as
    a list of [term mapref].
}

#-----------------------------------------------------------------------

order NBHOOD:CREATE "Create Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<parm.identifier neighborhood N1>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b>  <<parm.longname neighborhood "Peshawar">>
    <</parm>>

    <<parm local "Local Neighborhood?">>
    <b>Required.</b>  <<NBHOOD.local>>
    <</parm>>

    <<parm urbanization "Urbanization">>
    <b>Required.</b>  <<NBHOOD.urbanization>>
    <</parm>>

    <<parm vtygain "Volatility Gain">>
    <b>Required.</b>  <<NBHOOD.vtygain>>
    <</parm>>

    <<parm refpoint "Reference Point">>
    <b>Required.</b>  <<NBHOOD.refpoint>>
    <</parm>>

    <<parm polygon "Polygon">>
    <b>Required.</b> <<NBHOOD.polygon>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order creates a
    new neighborhood.
}

#-----------------------------------------------------------------------

order NBHOOD:DELETE "Delete Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Deletes an existing
    neighborhood, along with all entities (e.g., civilian groups)
    that depend upon it.<p>
}


#-----------------------------------------------------------------------

order NBHOOD:LOWER "Lower Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Lowers a neighborhood
    to the bottom of the stacking order, so that all overlapping
    neighborhoods are stacked upon this one, and then determines
    whether this neighborhood is obscured by any of those above it.
    (One neighborhood obscures another if it covers the other
    neighborhood's reference point.)
}


#-----------------------------------------------------------------------

order NBHOOD:RAISE "Raise Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Raises a neighborhood
    to the top of the stacking order, so that all overlapping
    neighborhoods are underneath it, and then determines
    whether this neighborhood obscures any of those below it.
    (One neighborhood obscures another if it covers the other
    neighborhood's reference point.)
}


#-----------------------------------------------------------------------

order NBHOOD:UPDATE "Update Neighborhood" {
    <<parmlist>>

    <<parm n "Select Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm longname "Long Name">>
    <b>Optional.</b>  <<parm.longname neighborhood "Peshawar">>
    <</parm>>

    <<parm local "Local Neighborhood?">>
    <b>Optional.</b>  <<NBHOOD.local>>
    <</parm>>

    <<parm urbanization "Urbanization">>
    <b>Optional.</b>  <<NBHOOD.urbanization>>
    <</parm>>

    <<parm vtygain "Volatility Gain">>
    <b>Optional.</b>  <<NBHOOD.vtygain>>
    <</parm>>

    <<parm refpoint "Reference Point">>
    <b>Optional.</b>  <<NBHOOD.refpoint>>
    <</parm>>

    <<parm polygon "Polygon">>
    <b>Optional.</b> <<NBHOOD.polygon>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies
    the definition of an existing neighborhood.
}

#-----------------------------------------------------------------------

order NBHOOD:UPDATE+MULTI "Update Multiple Neighborhoods" {
    <<parmlist>>

    <<parm ids "Neighborhoods">>
    <b>Required.</b>  <<parm.ids neighborhood>>
    <</parm>>

    <<parm local "Local Neighborhood?">>
    <b>Optional.</b>  <<NBHOOD.local>>
    <</parm>>

    <<parm urbanization "Urbanization">>
    <b>Optional.</b>  <<NBHOOD.urbanization>>
    <</parm>>

    <<parm vtygain "Volatility Gain">>
    <b>Optional.</b>  <<NBHOOD.vtygain>>
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies
    the definition of two or more neighborhoods, as selected in the GUI.
}


#=======================================================================
# Neighborhood Orders

page NBREL: "Neighborhood Relationship Orders" orders {
    <<title>>

    The Athena playbox, or region of interest, is divided into 
    <<cref NBHOOD: neighborhoods>>.  Neighborhoods are related
    to each other in two ways: by proximity, and by the time it takes
    attitude effects to spread.  The neighborhood relationship orders
    are used to edit these relationships.<p>

    Neighborhood relationships are created automatically for every
    pair of neighborhoods, and are deleted as necessary when
    neighborhoods are deleted.<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order NBREL:UPDATE "Update Neighborhood Relationship" {
    <<parmlist>>
    <<parm id "Neighborhood">> 
    <b>Required.</b>  A neighborhood relationship ID, specified as
    a list {<i>m</i>, <i>n</i>} where <i>m</i> and <i>n</i> are
    neighborhoods and the data is <i>m</i>'s relationship with
    <i>n</i>.  Note that a neighborhood's relationship with itself
    is fixed, so <i>m</i> cannot equal <i>n</i>.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <<parm effects_delay "Effects Delay">> 
    <b>Optional.</b> Decimal days.  The attitude effects of events and
    situations in neighborhood <i>n</i> are felt in neighborhood
    <i>m</i> only after this number of days.<p>

    Every neighborhood has a delay of 0.0 days with itself; this
    cannot be changed.
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies existing
    neighborhood relationships.<p>
}

#-------------------------------------------------------------------

order NBREL:UPDATE+MULTI "Update Multiple Neighborhood Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids "neighborhood relationship">><p>

     Programmatically, each ID is a list {<i>m n</i>} where <i>m</i>
    and <i>n</i> are defined as for the 
    <<cref NBREL:UPDATE>> order.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <<parm effects_delay "Effects Delay">> 
    <b>Optional.</b> Decimal days.  The attitude effects of events and
    situations in neighborhood <i>n</i> are felt in neighborhood
    <i>m</i> only after this number of days.<p>

    Every neighborhood has a delay of 0.0 days with itself; this
    cannot be changed.
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order modifies two or more
    neighborhood relationships, as selected in the GUI.<p>
}

#=======================================================================
# Group Relationship Orders

page REL: "Group Relationship Orders" orders {
    <<title>>

    Groups can be friends, enemies, or neutrals, as determined by
    their <i>relationship</i>, a number between -1.0 and 1.0.  
    Relationships are established during <<cref using.prep>> and
    are constant thereafter.<p>

    Inter-group relationships are computed from the groups' belief
    systems (force and organization groups inherit their belief
    systems from their owning actors).  In addition, these orders can
    be used to manually override the computed relationships.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order REL:OVERRIDE "Override Computed Relationship" {
    <<parmlist>>
    <<parm id "Groups">>
    <b>Required.</b>  A group relationship ID, specified as a 
    list {<i>f g</i>} where <i>f</i> and <i>g</i> are two groups.  The
    associated relationship is <i>f</i>'s relationship with <i>g</i>.
    Note that a group's relationship with itself is always 1.0 and
    cannot be overridden.
    <</parm>>

    <<parm rel "Relationship">>
    <b>Optional.</b>  The relationship between the two groups,
    a decimal number between -1.0 and 1.0.  Typical relationship
    values range from -0.5 to +0.8.
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order overrides the
    computed relationship of one group with another.
}

#-----------------------------------------------------------------------

order REL:RESTORE "Restore Computed Relationship" {
    <<parmlist>>
    <<parm id "Groups">>
    <b>Required.</b>  A group relationship ID, specified as a 
    list {<i>f g</i>} where <i>f</i> and <i>g</i> are two groups.  The
    associated relationship is <i>f</i>'s relationship with <i>g</i>.
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order restores the computed
    relationship, deleting any manual override.
}

#-----------------------------------------------------------------------

order REL:OVERRIDE+MULTI "Override Multiple Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids relationship>><p>

    Programmatically, each ID is a list {<i>f g</i>} where
    <i>f</i> and <i>g</i> are defined as for the 
    <<cref REL:OVERRIDE>> order.
    <</parm>>

    <<parm rel "Relationship">>
    <b>Optional.</b>  The relationship between two groups,
    a decimal number between -1.0 and 1.0.  Typical relationship
    values range from -0.5 to +0.8.   
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order overrides two or more
    computed relationships, as selected in the GUI.
}


#=======================================================================
# ROE Orders

page roe "Rules of Engagement Orders" orders {
    <<title>>

    A force group can be assigned Rules of Engagement (ROEs); these determine
    how and when and whether it will attack other groups and respond
    to attacks from other groups.  Force groups can be designated
    uniformed or non-uniformed; uniformed force groups use
    conventional tactics while non-uniformed force groups primarily
    use unconventional tactics.  The ROEs applicable to a group depend
    on whether it is a uniformed force (UF) or a non-uniformed force
    (NF):<p>

    <<childlinks>>
}

#=======================================================================
# Attacking ROEs

page ATTROE: "Attacking ROE Orders" roe {
    <<title>>

    An attacking ROE determines how and when a force group will try to
    attack another force group in a particular neighborhood.  By
    default, no force group will attack any other group; the analyst
    must explicitly create the relevant Attacking ROEs.<p>

    <<childlinks>>
}

macro ATTROE:U.roe {} {
    |<--
    The ROE proper, one of the following values:<p>

    [enumdoc ::projectlib::eattroeuf]

    If the ROE is <b>ATTACK</b>, then group <i>f</i> will attempt to
    hunt down and destroy units of group <i>g</i> in neighborhood
    <i>n</i>; and if not, not.  Note that there is no difference
    between having an Attacking ROE of <b>DO_NOT_ATTACK</b> and not
    having an Attacking ROE at all.
}

macro ATTROE:N.roe {} {
    |<--
    The ROE proper, one of the following values:<p>

    [enumdoc ::projectlib::eattroenf]

    If the ROE is <b>HIT_AND_RUN</b>, then group <i>f</i> will use
    hit-and-run tactics against group <i>g</i>, trying on each attack
    to nibble away at the uniformed force while taking minimal
    losses.<p>

    If the ROE is <b>STAND_AND_FIGHT</b>, then group <i>f</i> will
    expend a pre-determined number of troops in order to kill as many
    personnel of group <i>g</i> as possible.<p>

    Otherwise, group <i>f</i> will not attempt to attack.  Note that
    there is no difference between having an Attacking ROE of
    <b>DO_NOT_ATTACK</b> and not having an Attacking ROE at all.
}

macro ATTROE.cooplimit {} {
    |<--
    Group <i>f</i> will not attack group <i>g</i>
    unless it has sufficient cooperation from the residents of
    neighborhood <i>n</i>.  This parameter determines the required
    level of cooperation.  It is expressed as a real number between
    0.0 and 100.0, or as one of the symbols from the following table:<p>

    [::simlib::qcooperation html]
}

macro ATTROE:N.rate {} {
    |<--
    Given an ROE other than <b>DO_NOT_ATTACK</b>, group <i>f</i> will 
    attempt to attack group <i>g</i> at a rate determined by this
    parameter.<p>

    <b>Note:</b> The actual rate should also be conditioned by the resources
    available to the the attacking group; this, however, depends on
    Athena's Economic and Political models, which have not yet been
    implemented.
}


#-----------------------------------------------------------------------

order ATTROE:DELETE "Delete Attacking ROE" {
    <<parmlist>>
    <<parm id "Combatants">>
    <b>Required.</b>  A list {<i>n f g</i>} where <i>n</i> is the name 
    of a neighborhood, <i>f</i> is the name of a force
    group, and <i>g</i> is the name of the force group
    to be attacked.
    <</parm>>

    <</parmlist>>

    Deletes the Attacking ROE currently in place for attacks by group
    <i>f</i> on group <i>g</i> in neighborhood <i>n</i>.  (It is an
    error if no such ROE exists.)<p>

    Note that this is equivalent to setting the Attacking ROE to
    <b>DO_NOT_ATTACK</b>; see 
    <<cref ATTROE:NF:UPDATE>> and 
    <<cref ATTROE:UF:UPDATE>>.
}


#=======================================================================
# Attacking ROEs: Non-uniformed

page ATTROE:NF: "Attacking ROE (Non-Uniformed) Orders" ATTROE: {
    <<title>>

    Non-uniformed forces are those that hide among the local
    population and use terrorist and other unconventional tactics.
    This family of orders determines how and when non-uniformed forces
    will attempt to find and destroy uniformed force personnel in 
    a particular neighborhood.  (The response of the uniformed force
    to being attacked is determined by the uniformed force's
    <<cref TACTIC:DEFEND: "Defending ROE">>.)<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ATTROE:NF:CREATE "Create Attacking ROE (Non-Uniformed)" {
    <<parmlist>>
    <<parm id "Combatants">>
    <b>Required.</b>  A list {<i>n f g</i>} where <i>n</i> is the name 
    of a neighborhood, <i>f</i> is the name of a non-uniformed force
    group, and <i>g</i> is the name of the uniformed force group
    to be attacked.
    <</parm>>

    <<parm roe "ROE">>
    <b>Required.</b>  <<ATTROE:N.roe>>
    <</parm>>

    <<parm cooplimit "Cooperation Limit">>
    <b>Required.</b>  <<ATTROE.cooplimit>>
    <</parm>>

    <<parm rate "Attacks/Day">>
    <b>Required.</b>  <<ATTROE:N.rate>>
    <</parm>>

    <</parmlist>>

    Creates a new Attacking ROE for a non-uniformed force group vs. a
    uniformed force group.  Note that simply setting the ROE to
    <b>ATTACK</b> doesn't guarantee that attacks will occur.  The
    cooperation limit must be met, there must be units of the
    uniformed force to attack, the attacker must be able to find
    them, and so forth.<p>

    Attacks can be terminated by setting the ROE to
    <b>DO_NOT_ATTACK</b> using 
    <<cref ATTROE:NF:UPDATE>> or by deleting the ROE
    altogether using <<cref ATTROE:DELETE>>.
}


#-----------------------------------------------------------------------

order ATTROE:NF:UPDATE "Update Attacking ROE (Non-Uniformed)" {
    <<parmlist>>
    <<parm id "Combatants">>
    <b>Required.</b>  A list {<i>n f g</i>} where <i>n</i> is the name 
    of a neighborhood, <i>f</i> is the name of a non-uniformed force
    group, and <i>g</i> is the name of the uniformed force group
    to be attacked.
    <</parm>>

    <<parm roe "ROE">>
    <b>Optional.</b>  <<ATTROE:N.roe>>
    <</parm>>

    <<parm cooplimit "Cooperation Limit">>
    <b>Optional.</b>  <<ATTROE.cooplimit>>
    <</parm>>

    <<parm rate "Attacks/Day">>
    <b>Optional.</b>  <<ATTROE:N.rate>>
    <</parm>>

    <</parmlist>>

    Updates an existing Attacking ROE for a non-uniformed force group vs. a
    uniformed force group.
}


#-----------------------------------------------------------------------

order ATTROE:NF:UPDATE+MULTI "Update Multiple Attacking ROEs (Non-Uniformed)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids "Attacking ROE">><p>

    Programmatically, each ID is a list {<i>n f g</i>} where <i>n</i>,
    <i>f</i>, and <i>g</i> are defined as for the 
    <<cref ATTROE:NF:UPDATE>> order. 
    <</parm>>

    <<parm roe "ROE">>
    <b>Optional.</b>  <<ATTROE:N.roe>>
    <</parm>>

    <<parm cooplimit "Cooperation Limit">>
    <b>Optional.</b>  <<ATTROE.cooplimit>>
    <</parm>>

    <<parm rate "Attacks/Day">>
    <b>Optional.</b>  <<ATTROE:N.rate>>
    <</parm>>

    <</parmlist>>

    Updates each of the selected ROEs.
}


#=======================================================================
# Attacking ROEs: Uniformed

page ATTROE:UF: "Attacking ROE (Uniformed) Orders" ATTROE: {
    <<title>>

    Uniformed forces are those (like the U.S. military) that wear
    uniforms and use conventional tactics.  This family of orders
    determines how and when uniformed forces will attempt to find and
    destroy non-uniformed force personnel in a particular
    neighborhood.  The orders are as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ATTROE:UF:CREATE "Create Attacking ROE (Uniformed)" {
    <<parmlist>>
    <<parm id "Combatants">>
    <b>Required.</b>  A list {<i>n f g</i>} where <i>n</i> is the name 
    of a neighborhood, <i>f</i> is the name of a uniformed force
    group, and <i>g</i> is the name of the non-uniformed force group
    to be attacked.
    <</parm>>

    <<parm roe "ROE">>
    <b>Required.</b>  <<ATTROE:U.roe>>
    <</parm>>

    <<parm cooplimit "Cooperation Limit">>
    <b>Required.</b>  <<ATTROE.cooplimit>>
    <</parm>>

    <</parmlist>>

    Creates a new Attacking ROE for a uniformed force group vs. a
    non-uniformed force group.  Note that simply setting the ROE to
    <b>ATTACK</b> doesn't guarantee that attacks will occur.  The
    cooperation limit must be met, there must be units of the
    non-uniformed force to attack, the attacker must be able to find
    them, and so forth.<p>

    Attacks can be terminated by setting the ROE to
    <b>DO_NOT_ATTACK</b> using 
    <<cref ATTROE:UF:UPDATE>> or by deleting the ROE
    altogether using <<cref ATTROE:DELETE>>.
}


#-----------------------------------------------------------------------

order ATTROE:UF:UPDATE "Update Attacking ROE (Uniformed)" {
    <<parmlist>>
    <<parm id "Combatants">>
    <b>Required.</b>  A list {<i>n f g</i>} where <i>n</i> is the name 
    of a neighborhood, <i>f</i> is the name of a uniformed force
    group, and <i>g</i> is the name of the non-uniformed force group
    to be attacked.
    <</parm>>

    <<parm roe "ROE">>
    <b>Optional.</b>  <<ATTROE:U.roe>>
    <</parm>>

    <<parm cooplimit "Cooperation Limit">>
    <b>Optional.</b>  <<ATTROE.cooplimit>>
    <</parm>>

    <</parmlist>>

    Updates an existing Attacking ROE for a uniformed force group vs. a
    non-uniformed force group.
}

#-----------------------------------------------------------------------

order ATTROE:UF:UPDATE+MULTI "Update Multiple Attacking ROEs (Uniformed)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids "Attacking ROE">><p>

    Programmatically, each ID is a list {<i>n f g</i>} where <i>n</i>,
    <i>f</i>, and <i>g</i> are defined as for the 
    <<cref ATTROE:UF:UPDATE>> order. 
    <</parm>>

    <<parm roe "ROE">>
    <b>Optional.</b>  <<ATTROE:U.roe>>
    <</parm>>

    <<parm cooplimit "Cooperation Limit">>
    <b>Optional.</b>  <<ATTROE.cooplimit>>
    <</parm>>

    <</parmlist>>

    Updates each of the selected ROEs.
}


#=======================================================================
# Satisfaction Orders

page SAT: "Satisfaction Orders" orders {
    <<title>>

    Athena models the satisfaction of civilian groups with respect
    to a variety of
    concerns.  This family of orders are used to manipulate the
    initial satisfaction levels and related parameters.  (Use the
    <<cref MAD:SAT:>> to adjust or otherwise influence the 
    current levels.)<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order SAT:UPDATE "Update Initial Satisfaction" {
    <<parmlist>>
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where <i>g</i> is a
    civilian group and <i>c</i> is a concern.
    <</parm>>

    <<parm sat0 "Sat at T0">>
    <b>Optional.</b>  The initial satisfaction level of group <i>g</i>
    with concern <i>c</i>.  Satisfaction levels
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm saliency "Saliency">>
    <b>Optional.</b>  The importance of concern <i>c</i> to the group.
    Saliencies range from 0.0 to 1.0, and are defined either
    numerically or using the following rating scale:<p>

    <<::simlib::qsaliency html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal satisfaction points per day.  The
    ascending trend is applied whenever the current satisfaction level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal satisfaction points per day.  The
    descending trend is applied whenever the current satisfaction level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order updates the initial
    satisfaction level of one group with a concern; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref MAD:>> to adjust or otherwise influence the 
    current levels.)

}


#-----------------------------------------------------------------------

order SAT:UPDATE+MULTI "Update Initial Satisfaction (Multi)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids satisfaction>><p>

    Programmatically, each ID is a list {<i>g c</i>} where
    <i>g</i> and <i>c</i> are defined as for the 
    <<cref SAT:UPDATE>> order.
    <</parm>>

    <<parm sat0 "Sat at T0">>
    <b>Optional.</b>  The initial satisfaction level of group <i>g</i>
    with concern <i>c</i>.  Satisfaction levels
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm saliency "Saliency">>
    <b>Optional.</b>  The importance of concern <i>c</i> to the group.
    Saliencies range from 0.0 to 1.0, and are defined either
    numerically or using the following rating scale:<p>

    <<::simlib::qsaliency html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal satisfaction points per day.  The
    ascending trend is applied whenever the current satisfaction level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal satisfaction points per day.  The
    descending trend is applied whenever the current satisfaction level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>
    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  This order updates two or more initial
    satisfaction levels, as selected in the GUI; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref MAD:>> to adjust or otherwise influence the 
    current levels.)
}

#=======================================================================
# Simulation Control Orders

page SIM: "Simulation Control Orders" orders {
    <<title>>

    The orders in this set are used to control the simulation in
    general.  Most of them are used implicitly, by various GUI
    controls.  They are documented here for completeness.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order SIM:STARTDATE "Set Start Date" {
    <<parmlist>>
    <<parm startdate "Start Date">>
    <b>Required.</b>  A <<term zulu>> corresponding to 
    simulation time 0.  By convention, the hours and minutes 
    should be "0000".
    <</parm>>

    <</parmlist>>

    <b><<cref using.prep>> Only.</b>  Athena generally reports
    simulation time as a number of integer days and as a zulu-time.
    This order determines how simulation time is translated to zulu-time.
}


order SIM:RUN "Run Simulation" {
    <<parmlist>>
    <<parm days "Days to Run">>
    <b>Optional.</b>  An integer number of days.  If 0, or not
    specified, the simulation will run until explicitly paused by the
    user.  If greater than 0, the simulation will run for the
    specified number of days, and then halt.
    <</parm>>

    <<parm block "Block?">>
    <b>Optional.</b>  A boolean flag.  If true, the order will
    block--that is, the simulation will run for the specified number
    of days and then the order handler will return.  If false (the
    default) the order handler returns immediately, and the simulation
    runs forward under the control of the Tcl event loop.<p>
    <</parm>>

    <</parmlist>>

    Advances simulation time.  This order is usually triggered by the
    "play" button in the GUI.<p>

    If the simulation is in the <<cref using.prep>> state, the order
    does a sanity check on the scenario; time will not be allowed to
    advance if the scenario is incomplete.
}


order SIM:PAUSE "Pause Simulation" {
    Pauses the simulation at the next possible moment: immediately if
    the simulation is waiting in the Tcl event loop between 
    <<term tick>>s, and at the end of the current tick if it's in the 
    middle of a tick.<p>

    This order is usually triggered by the "pause" button in the GUI.
}


#=======================================================================
# Tactic Orders

page TACTIC: "Tactic Orders" orders {
    <<title>>

    A <<term tactic>> is an action an <<term actor>> can choose to 
    carry out.  There are many different types of tactic, each of
    which has its own "CREATE" and "UPDATE" orders; other orders are
    shared by all tactic types.<p>

    The general tactic orders and tactic types are as follows:<p>

    <<childlinks>>
} 

macro TACTIC.cowner {} {
    |<--
    [parm owner "Owner"]
    <b>Required.</b>  The ID of the actor to which this tactic
    belongs.
    [/parm]
}

macro TACTIC.uowner {} {
    |<--
    [parm owner "Owner"]
    <b>Display Only.</b>  The ID of the actor to which this tactic
    belongs. This parameter is displayed in the order dialog as an aid 
    to the  user.
    [/parm]
}

macro TACTIC.id {} {
    |<--
    [parm tactic_id "Tactic ID"]
    <b>Required.</b> The ID of the tactic to be updated.
    [/parm]
}

macro TACTIC.priority {} {
    |<--
    [parm priority "Priority"]
    <b>Optional.</b>  Indicates the initial priority of this tactic.
    If <b>top</b>, the tactic will have priority over all other
    tactics for this actor;; if <b>bottom</b>, it will have the lowest
    priority.  The priority can then be changed using the
    <<cref TACTIC:PRIORITY>> order.
    [/parm]
}

order TACTIC:DELETE "Delete Tactic" {
    <<parmlist>>

    <<parm tactic_id "Tactic ID">>
    <b>Required.</b>  The ID of an existing tactic.
    <</parm>>

    <<parm owner "Owner">>
    <b>Display Only.</b>  The ID of the actor that owns this tactic.
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>

    <<parm tactic_type "Tactic Type">>
    <b>Display Only.</b>  The tactic's type.  
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>
    
    <</parmlist>>

    Deletes the tactic.
}

order TACTIC:PRIORITY "Set Tactic Priority" {
    <<parmlist>>

    <<parm tactic_id "Tactic ID">>
    <b>Required.</b>  The ID of an existing tactic.
    <</parm>>

    <<parm owner "Owner">>
    <b>Display Only.</b>  The ID of the actor that owns this tactic.
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>

    <<parm tactic_type "Tactic Type">>
    <b>Display Only.</b>  The tactic's type.  
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>

    <<parm priority "Priority">>
    <b>Required.</b>  The tactic's new priority with respect to
    other tactics belonging to the same <<term actor>>.
    Possible values are <b>top</b>, <b>bottom</b>, <b>raise</b>, and
    <b>lower</b>.  The values <b>top</b> and <b>bottom</b> give the
    tactic the highest or lowest priority among the actor's
    tactics; the values <b>raise</b> and <b>lower</b> move the tactic
    up or down one step.
    <</parm>>

    <</parmlist>>

    Sets the tactic's priority.  Note that this order is usually sent
    implicitly via buttons on the <<tabref Strategy>>.
}


order TACTIC:STATE "Set Tactic State" {
    <<parmlist>>

    <<parm tactic_id "Tactic ID">>
    <b>Required.</b>  The ID of an existing tactic.
    <</parm>>

    <<parm state "State">>
    <b>Required.</b>  The tactic's new state, one of: <b>normal</b>,
    <b>disabled</b>, or <b>invalid</b>.
    <</parm>>

    <</parmlist>>

    Sets the tactic's state.  Note that this order is for internal use
    by the application; there is no associated order dialog.
}


#-----------------------------------------------------------------------
# Tactic: DEFEND

page TACTIC:DEFEND: "Tactic: Set Defensive ROE" TACTIC: {
    <<title>>

    This tactic sets the defensive <<term roe>> for uniformed force groups
    belonging to an <<term actor>>.<p>

    Defending ROEs determine how a uniformed force group responds to
    attack by a non-uniformed force group: do they shoot back, and if
    so under what conditions.  As such, it has no direct costs, either
    in dollars or personnel.<p>

    Every uniformed force group has an automatically-created Defending
    ROE in every neighborhood; the ROE defaults to
    <b>FIRE_BACK_IF_PRESSED</b>.  This tactic adjusts the ROE
    according to the actor's <<term condition>>s.<p>

    The tactic orders are as follows:<p>

    <<childlinks>>
}

macro DEFEND.roe {} {
    |<--
    The ROE proper, one of the following values:<p>

    [enumdoc ::projectlib::edefroeuf]

    If the ROE is <b>HOLD_FIRE</b>, then the group will never fire
    back at attackers.  If the ROE is <b>FIRE_BACK_IF_PRESSED</b>,
    then the group will fire back only if the attacker continues to
    press the attack after the initial engagement.  That is, the group
    will <i>not</i> fire back if the attacker does a hit-and-run.  If
    the ROE is <b>FIRE_BACK_IMMEDIATELY</b>, the group will always
    fire back at its attackers.<p>

    Note that the number of civilian casualties depends on whether or
    not the group fires back at its attackers.
}

order TACTIC:DEFEND:CREATE "Create Tactic: Set Defensive ROE" {
    <<parmlist>>
    <<TACTIC.cowner>>

    <<parm g "Defending Group">>
    <b>Required.</b>  The ID of a uniformed force group belonging to
    the <i>owner</i>.
    <</parm>>

    <<parm n "In Neighborhood">>
    <b>Required.</b>  The neighborhood for which the ROE will be
    set.
    <</parm>>

    <<parm text1 "ROE">>
    <b>Required.</b>  <<DEFEND.roe>>
    <</parm>>

    <<TACTIC.priority>>
    <</parmlist>>

    Creates the tactic.
}

order TACTIC:DEFEND:UPDATE "Update Tactic: Set Defensive ROE" {
    <<parmlist>>
    <<TACTIC.id>>
    <<TACTIC.uowner>>

    <<parm g "Defending Group">>
    <b>Display Only.</b>  The ID of a uniformed force group belonging to
    the <i>owner</i>.
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>

    <<parm n "In Neighborhood">>
    <b>Display only.</b>  The neighborhood for which the ROE will be
    set.
    This parameter is displayed in the order dialog as an aid to the
    user.
    <</parm>>

    <<parm text1 "ROE">>
    <b>Required.</b>  <<DEFEND.roe>>
    <</parm>>

    <</parmlist>>

    Allows the user to edit the tactic.
}

#-----------------------------------------------------------------------
# Tactic: SAVEMONEY

page TACTIC:SAVEMONEY: "Tactic: Save Money" TACTIC: {
    <<title>>

    This tactic allows the actor to reserve a percentage of his weekly
    income for later use.

    <<childlinks>>
}

order TACTIC:SAVEMONEY:CREATE "Create Tactic: Save Money" {
    <<parmlist>>
    <<TACTIC.cowner>>

    <<parm int1 "Percent of Income">>
    <b>Required.</b> The percentage of the actor's income to save, as
    an integer from 0 to 100.
    <</parm>>

    <<TACTIC.priority>>
    <</parmlist>>

    Creates the tactic.
}


order TACTIC:SAVEMONEY:UPDATE "Update Tactic: Save Money" {
    <<parmlist>>
    <<TACTIC.id>>
    <<TACTIC.uowner>>

    <<parm int1 "Percent of Income">>
    <b>Required.</b> The percentage of the actor's income to save, as
    an integer from 0 to 100.
    <</parm>>

    <</parmlist>>

    Allows the user to edit the tactic.
}

#=======================================================================
# Unit Orders

page UNIT: "Unit Orders" orders {
    <<title>>

    A <<term unit>> is an object that represents some number of people in 
    a particular neighborhood, typically performing some activity.

    Units are modified using the following orders:<p>

    <<childlinks>>
}


order UNIT:MOVE "Move Unit" {
    <<parmlist>>
    <<parm u "Name">>
    <b>Required.</b>  The name of the unit to move.
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  The unit's new location, expressed as
    a <<term mapref>>.
    <</parm>>
    <</parmlist>>

    Moves the unit to its new location, which must be within the same 
    neighborhood.
}



#=======================================================================
# Order Orders

page ORDER: "Order Scheduling Orders" orders {
    <<title>>

    Athena allows certain orders to be scheduled to execute at some
    later time.  These orders are used to schedule orders for
    execution, and to cancel the scheduled orders.<p>

    The user will usually use these orders indirectly, via the
    the "Schedule" button on the various order dialogs, and the "X" 
    button on the Orders browser;  Athena <<version>> provides no 
    other way for the user to access them.  They are documented here 
    for completeness' sake.<p>

    In the long-run, it is likely that Athena will be able to execute
    order scripts; at that time, the user will be able to enter these
    orders directly into the scripts.<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order ORDER:CANCEL "Cancel Scheduled Order" {
    <<parmlist>>

    <<parm id "Order ID">> 
    <b>Required.</b>  The ID of the scheduled order, as shown in 
    the Orders browser.
    <</parm>>

    <</parmlist>>

    This order cancels a scheduled order given its ID.
}

#-------------------------------------------------------------------

order ORDER:SCHEDULE "Schedule Order" {
    <<parmlist>>

    <<parm timespec "Time Spec">> 
    <b>Required.</b> The time at which the order should be scheduled
    to execute, expressed as a <<term timespec>>.  The time must be at
    least "NOW+1".
    <</parm>>

    <<parm name "Order Name">>
    <b>Required.</b> The name of the order, as shown on the second
    line of the order's help page.  For example, the name of this
    order (as opposed to its title) is <b>ORDER:SCHEDULE</b>.

    <<parm parmdict "Parm Dict">>
    A Tcl dictionary of parameter names and values, using the 
    parameter names shown in parentheses on the order's help page.
    The name of this parameter, for example, is <b>parmdict</b>.
    <</parm>>

    <</parmlist>>

    This order schedules the order to execute at the specified time.
    It does not ensure that the order will be accepted; a valid order
    might become invalid by the time it executes, and an invalid order
    might (in particular cases) become valid.
}

#=======================================================================
# Parm Orders

page PARM: "Model Parameter Orders" orders {
    <<title>>

    These orders are used to set the values of the 
    Athena <<cref parmdb>>.<p>

    The user will usually use these orders indirectly, via the
    <<cmdref parm>> <<cref cmd "executive command">> and its
    subcommands; Athena <<version>> provides no other way for the user
    to access them.  They are documented here for completeness'
    sake.<p>

    In the long-run, it is likely that Athena will be able to execute
    order scripts; at that time, the user will be able to enter these
    orders directly into the scripts.<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order PARM:IMPORT "Import Parameter File" {
    <<parmlist>>

    <<parm filename "Parameter File">> 
    <b>Required.</b>  Name of a parmdb(5) parameter file.
    <</parm>>

    <</parmlist>>

    This order imports <<cref parmdb "model parameter">> settings from
    a disk file.  See <<cmdref parm import>> for details.
}


#-------------------------------------------------------------------

order PARM:RESET "Reset Parameters to Defaults" {
    This order resets all <<cref parmdb "model parameters">> to
    their default values.  See <<cmdref parm reset>> for details.
}

#-------------------------------------------------------------------

order PARM:SET "Set Parameter Value" {
    <<order.header>>

    <<parmlist>>

    <<parm parm "Parameter">> 
    <b>Required.</b>  Name of a parmdb(5) parameter.
    <</parm>>

    <<parm value "Value">> 
    <b>Required.</b>  New parameter value.
    <</parm>>

    <</parmlist>>

    This order sets the value of the named parameter.  See 
    <<cmdref parm set>> for details. 
}

#=======================================================================
# Personnel Orders

page PERSONNEL: "Personnel Orders" orders {
    <<title>>

    In Athena, force and organization personnel must be stationed in 
    a neighborhood before they can be assigned
    <<cref ACTIVITY: "activities">>.  These orders are used to 
    manage these "force levels".<p>

    <<childlinks>>
}


order PERSONNEL:SET "Set Group Personnel" {
    <<parmlist>>
    <<parm id "Nbhood/Group">>
    <b>Required.</b>  A list {<i>n g</i>} where <i>n</i> is the name
    of a neighborhood and <i>g</i> is the name of a a force or
    organization group.
    <</parm>>

    <<parm personnel "Personnel">>
    <b>Required.</b> The number of group <i>g's</i> personnel to
    assign to neighborhood <i>n</i>.
    <</parm>>

    <</parmlist>>

    Assigns the specified number of personnel to the neighborhood.
    By default, no force or organization personnel are assigned to 
    any neighborhood.<p>
}


order PERSONNEL:ADJUST "Adjust Group Personnel" {
    <<parmlist>>
    <<parm id "Nbhood/Group">>
    <b>Required.</b>  A list {<i>n g</i>} where <i>n</i> is the name
    of a neighborhood and <i>g</i> is the name of a a force or
    organization group.
    <</parm>>

    <<parm delta "Delta Personnel">>
    <b>Required.</b> The number of personnel by which the group's
    force level will be increased or decreased.
    <</parm>>

    <</parmlist>>

    Increases or decreases the number of group <i>g</i>'s personnel 
    stationed in neighborhood <i>n</i> by the specified amount.<p>
}
















