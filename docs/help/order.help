# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    order.help
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Athena Help Documentation: Orders
#
#    This file is included into athena.help.
#
#    Orders have help pages with names like
#
#        /order/<token1>/<token2>?/...?
#
#    E.g, the CIVGROUP:CREATE order has the page
#
#       /order/civgroup/create
#
#    In some cases, the implied hierarchy in the order names is misleading;
#    for example, CIVGROUP:UPDATE:MULTI has the page
#
#       /order/civgroup/update:multi
#
#    It would better if the "UPDATE:MULTI" orders were renamed, but for
#    now, that's how it is.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------

page / order "Orders" {
    <<title>>
    The analyst communicates with Athena by means of <i>orders</i>.
    Most orders are sent by means of an order dialog; some are sent
    implicitly.  For example, dragging a unit from one place to
    another on the map implicitly sends the <<cref /order/unit/move>> 
    order.  Order dialogs can be invoked in a number of ways, e.g., by
    selecting an order from the <<cref /menu/orders>>.<p>

    Orders are grouped in the following categories:<p>

    <<childlinks>>
}

# order name title text
#
# name     The order's name (but see below)
# title    The order's title (e.g., menu item text)
# text     The documentation of the order.
#
# Defines a help page for one order.  The order hierarchy is determined
# automatically using the ":"'s in the order name.
#
# Sometimes a colon shouldn't add a new level to the order hierarchy,
# e.g., orders FOO:UPDATE and FOO:UPDATE:MULTI are at the same level.
# In this case, enter the latter as "FOO:UPDATE+MULTI".

proc order {name title text} {
    lassign [name2path /order : $name] parent slug
    set slug [string map {+ :} $slug]
    set name [string map {+ :} $name]

    set text "<<order.header [list $title]>>\n\n$text"
    page $parent $slug $name $text
}

# Formats the title for an order page
macro order.header {otitle} {
    |<--
    [mktitle normal "" $otitle "(<tt>[pageinfo title]</tt>)"]
}

macro parm.identifier {entity example} {
    |<--
    The ID for the new $entity.  It may
    contain letters and digits, and must begin with a letter.  It may
    not be the same as the ID or long name of any existing
    neighborhood, group, etc.  It should usually be short, between 2
    and 8 characters in length, e.g., <b>$example</b>.
}

macro parm.longname {entity example} {
    |<--
    A short human-readable name for the
    $entity, e.g., "$example".  If left empty on creation, the long 
    name defaults to the ${entity} ID.
}

macro parm.ids {entity} {
    |<--
    The IDs of two or more $entity entities, as selected in the GUI.
}


#=======================================================================
# Actor Orders

page /order actor "Actor Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term actor>>s.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ACTOR:CREATE "Create Actor" {
    <b><<term prep>> Only.</b>  This order creates a new 
    <<term actor>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<actor_ parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order ACTOR:DELETE "Delete Actor" {
    <b><<term prep>> Only.</b>  Deletes an existing
    <<term actor>>, along with all entities (e.g., beliefs)
    that depend upon it, given its ID.    
    The order parameters are as follows:<p>

    <<parmlist>>
    <<parm a "Actor">>
    <b>Required.</b>  ID of an existing actor.
    <</parm>>
    <</parmlist>>

}

#-----------------------------------------------------------------------

order ACTOR:UPDATE "Update Actor" {
    <b><<term prep>> Only.</b>  This order modifies the
    definition of an existing <<term actor>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm a "Select Actor">>
    <b>Required.</b> ID of an existing actor.
    <</parm>>

    <<actor_ parms -optional -tags update>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

order ACTOR:INCOME "Update Actor Income" {
    This order modifies the income of an existing <<term actor>>.  
    It may be used interactively when the simulation is paused, and
    by the <<cref /object/tactic/executive>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm a "Select Actor">>
    <b>Required.</b> ID of an existing actor.
    <</parm>>

    <<actor_ parm income -required>>

    <</parmlist>>
}


#-----------------------------------------------------------------------

order ACTOR:SUPPORTS "Update Actor Supports" {
    This order specifies which <<term actor>> this actor usually
    supports politically, in the absence of a 
    <<cref /object/tactic/support>> for a given neighborhood.
    It may be used interactively when the simulation is paused, and
    by the <<cref /object/tactic/executive>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm a "Select Actor">>
    <b>Required.</b> ID of an existing actor.
    <</parm>>

    <<actor_ parm supports -required>>

    <</parmlist>>
}



#-----------------------------------------------------------------------

page /order attrit "Attrition Orders" {
    <<title>>

    Athena assesses attrition due to conflict between groups
    periodically; the period is nominally one week.  In addition,
    the analyst can cause magic attrition to unit personnel and to the 
    civilian population at any time.<p>

    <b>Note:</b> Magic attrition takes effect immediately; however, the
    attitude effects resulting from magic attrition are assessed as
    part of the regular weekly attrition assessment.<p>

    <<childlinks>>
}

macro ATTRIT.responsible {} {
    |<--
    [parm g1 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]

    [parm g2 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]
}

macro ATTRIT.general {} {
    |<--
    <b>Staffing Pools:</b>  Every unit is staffed from a staffing
    pool.  For civilian units, the staffing pool is the base
    population of the group in its neighborhood of residence; for force
    and organization units, the staffing pool is the number of
    personnel deployed to the unit's neighborhood of origin.
    
    Attrition reduces not only the number of personnel in the affected
    units, but also the number of personnel available in the group's
    staffing pool.<p>

    <b>Attitude Implications:</b>  Civilian and organization
    casualties affect the satisfaction of the relevant groups.  If
    responsible force groups are specified, then civilian casualties
    will affect the cooperation of the civilian group with the
    responsible groups.<p>

    <b>Use in [cref /object/tactic/executive]:</b>
    This order can be scheduled for execution by the EXECUTIVE tactic
    using the [cref /command/sched] executive command.  It cannot be
    sent immediately by the EXECUTIVE tactic using the
    [cref /command/send] executive command.
    
}


#-----------------------------------------------------------------------

order ATTRIT:GROUP "Magic Attrit Group" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm f "To Group">>
    <b>Required.</b>  The name of an existing civilian, force, or
    organization group to receive the casualites.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected group's
    units in a selected neighborhood.  The group's units are attrited
    proportional to their size, i.e., a unit twice as big as another
    will take twice the casualties.  Additional effects depend on
    the kind of group.<p>

    <<ATTRIT.general>>
}

#-----------------------------------------------------------------------

order ATTRIT:NBHOOD "Magic Attrit Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    Attrits all civilian units in the neighborhood by the specified number
    of casualties.  Units are attrited proportionally to their size,
    i.e., a unit twice as big as another will take twice the
    casualties.<p>

    <<ATTRIT.general>>
}

#=======================================================================
# Belief System Orders

macro TOPIC.tid {} {
    |<--
    The ID of an existing topic.
}

macro TOPIC.title {} {
    |<--
    A human readable title that defines the topic.
}

macro TOPIC.relevance {} {
    |<--
    A boolean flag that indicates whether the topic is relevant or
    not.  Irrelevant topics are omitted from the affinity
    computations.<p>
}

page /order bsystem "Belief System Orders" {
    <<title>>

    Every <<term civgroup>> and every <<term actor>> has a 
    <<term bsystem>>: a set of <<term position>>s on 
    various <<term topic>>s. Athena computes the <<term affinity>>
    between between pairs and groups and between groups and actors,
    based on their agreements and disagreements with respect to their
    belief systems. These orders are used to create and update belief
    systems.<p>

    <<childlinks>>
}


#-----------------------------------------------------------------------

page /order/bsystem topic "Topic Orders" {
    <<title>>

    Each <<term bsystem>> consists of a 
    <<term group>> or <<term actor>>'s set of 
    <<term position>>s on each of a set of <<term topic>>s.  These
    orders are used to create, update, and delete topics.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order BSYSTEM:TOPIC:CREATE "Create Belief System Topic" {
    <<parmlist>>
    <<parm tid "Topic ID">>
    <b>Required.</b>  <<parm.identifier topic T1>>
    <</parm>>

    <<parm title "Title">>
    <b>Required.</b> <<TOPIC.title>>
    <</parm>>

    <<parm relevance "Relevant?">>
    <b>Required.</b> <<TOPIC.relevance>>
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order creates a
    new <<term topic>>.
}


#-----------------------------------------------------------------------

order BSYSTEM:TOPIC:DELETE "Delete Belief System Topic" {
    <<parmlist>>

    <<parm tid "Topic ID">>
    <b>Required.</b>  <<TOPIC.tid>>
    <</parm>>
    <</parmlist>>

    <b><<term prep>> Only.</b>  Deletes an existing
    belief system <<term topic>>, along with all beliefs
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

order BSYSTEM:TOPIC:UPDATE "Update Belief System Topic" {
    <<parmlist>>
    <<parm tid "Select Topic">>
    <b>Required.</b>  <<TOPIC.tid>>
    <</parm>>

    <<parm title "Title">>
    <b>Optional.</b> <<TOPIC.title>>
    <</parm>>

    <<parm relevance "Relevant?">>
    <b>Optional.</b> <<TOPIC.relevance>>
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order modifies the
    definition of an existing <<term topic>>.<p>
}

#-----------------------------------------------------------------------

page /order/bsystem belief "Belief Orders" {
    <<title>>

    Each <<term bsystem>> consists of a 
    set of beliefs, each consisting of a 
    <<term position>> and an <<term emphasis>> on agreement or
    disagreement with respect that position.
    Every <<term civgroup>> and <<term actor>> automatically has
    a belief about every defined <<term topic>>.  The following
    order is used to edit beliefs.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order BSYSTEM:BELIEF:UPDATE "Update Belief" {
    <<parmlist>>
    <<parm id "Select Belief">>
    <b>Required.</b>  A belief ID, which is an {<i>eid tid</i>} pair.
    The <i>eid</i> is an entity ID: a <<term civgroup>> or 
    <<term actor>> name.  The <i>tid</i> is a <<term topic>> ID.
    <</parm>>

    <<parm position "Position">>
    <b>Optional.</b> The entity's <<term position>> on the topic, a
    number from -1.0 to 1.0.  The symbolic constants defined in the
    following table may also be used:<p>

    <<::simlib::qposition html>>
    <</parm>>

    <<parm emphasis "Emphasis is On">>
    <b>Optional.</b> The entity's <<term emphasis>> on agreement or 
    disagreement for the topic, a number from 0.0 to 1.0.  The 
    symbolic constants defined in the following table should generally
    be used.<p>

    <<::simlib::qemphasis html>>
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order modifies the
    an existing belief in a <<term bsystem>>.<p>
}

#=======================================================================
# CAP Orders

page /order cap "CAP Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term cap>>s, and to set the neighborhood coverage and group
    penetration for CAPs.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order CAP:CREATE "Create Comm. Asset Package" {
    <b><<term prep>> Only.</b>  This order creates a new 
    <<term cap>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<cap_ parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order CAP:DELETE "Delete Comm. Asset Package" {
    <b><<term prep>> Only.</b>  Deletes an existing
    <<term cap>>, along with all entities
    that depend upon it, given its ID.    
    The order parameters are as follows:<p>

    <<parmlist>>
    <<parm k "CAP">>
    <b>Required.</b>  ID of an existing CAP.
    <</parm>>
    <</parmlist>>

}

#-----------------------------------------------------------------------

order CAP:UPDATE "Update Comm. Asset Package" {
    <b><<term prep>> Only.</b>  This order modifies the
    definition of an existing <<term cap>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm k "Select CAP">>
    <b>Required.</b> ID of an existing CAP.
    <</parm>>

    <<cap_ parms -optional -tags update>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

order CAP:UPDATE+MULTI "Update Multiple CAPs" {
    <b><<term prep>> Only.</b>  This order modifies the definition
    of two or more existing <<term cap>>s, as selected in the GUI.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids "CAP">>
    <</parm>>

    <<cap_ parms -optional -tags multi>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order/cap nbcov "Neighborhood Coverage Orders" {
    <<title>>

    Each <<term cap>> has a coverage area consisting of part or all of
    some set of neighborhoods; the coverage area is defined as a
    neighborhood coverage fraction for each neighborhood in the
    playbox.  The following orders are used to edit the coverage area.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order CAP:NBCOV:SET "Set CAP Neighborhood Coverage" {
    This order sets the neighborhood
    coverage fraction for a particular <<term cap>> and neighborhood.<p>

    <<parmlist>>
    <<parm id "CAP/Nbhood">>
    <b>Required.</b> A CAP neighborhood coverage ID, which is a list
    {<i>k n</i>} where <i>k</i> is the CAP ID and <i>n</i> is the 
    neighborhood ID.
    <</parm>>

    <<parm nbcov "Coverage">>
        The CAP's coverage of the neighborhood, expressed as a fraction
        from 0.0 to 1.0.
    <</parm>>
    <</parmlist>><p>

    This order can be <<cref /command/send sent>> by the
    <<cref /object/tactic/executive>>.<p>
}

#-----------------------------------------------------------------------

order CAP:NBCOV:SET+MULTI "Set Multiple CAP Neighborhood Coverages" {
    This order sets the neighborhood coverage fraction for several
    <<term cap>>s and neighborhoods.<p>

    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b> A list of CAP neighborhood coverage IDs.  
    Programmatically, each ID is a list {<i>k n</i>} where <i>k</i>
    is the CAP ID and <i>n</i> is the neighborhood ID.
    <</parm>>

    <<parm nbcov "Coverage">>
        The CAPs' coverage of the neighborhoods, expressed as a fraction
        from 0.0 to 1.0.
    <</parm>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order/cap pen "Group Penetration Orders" {
    <<title>>

    Each <<term cap>> is received by some portion of the groups in
    its coverage area.   This is called the group penetration, and it
    is set as a penetration fraction from 0.0 to 1.0 for each
    civilian group in the playbox.  Note that it is possible to give
    a group a positive penetration fraction even if its neighborhood
    is not in the CAP's coverage area; such a group is called an
    "orphan" group.  Orphan groups are highlighted in the 
    <<cref /tab/info/group_penetration>>.<p>

    The following orders are used to set group penetration.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order CAP:PEN:SET "Set CAP Group Penetration" {
    This order sets the group penetration fraction for a particular 
    <<term cap>> and civilian group.<p>

    <<parmlist>>
    <<parm id "CAP/Group">>
    <b>Required.</b> A CAP group penetration ID, which is a list
    {<i>k g</i>} where <i>k</i> is the CAP ID and <i>g</i> is the 
    civilian group ID.
    <</parm>>

    <<parm pen "Penetration">>
        The CAP's penetration of the group, expressed as a fraction
        from 0.0 to 1.0.
    <</parm>>
    <</parmlist>><p>

    This order can be <<cref /command/send sent>> by the
    <<cref /object/tactic/executive>>.<p>
}

#-----------------------------------------------------------------------

order CAP:PEN:SET+MULTI "Set Multiple CAP Group Penetrations" {
    This order sets the group penetration fraction for several 
    <<term cap>>s and civilian groups.<p>

    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b> A list of CAP group penetration IDs.  
    Programmatically, each ID is a list {<i>k g</i>} where <i>k</i>
    is the CAP ID and <i>g</i> is the civilian group ID.
    <</parm>>

    <<parm pen "Penetration">>
        The CAPs' penetration of the civilian groups, expressed as 
        a fraction from 0.0 to 1.0.
    <</parm>>
    <</parmlist>>
}


#=======================================================================
# Condition Orders

include order_condition.help

#=======================================================================
# Cooperation Orders

page /order coop "Cooperation Orders" {
    <<title>>

    Athena models the cooperation of neighborhood
    civilian groups with force groups, where cooperation is defined as
    in the TRAC HUMINT methodology: the likelihood that a member of
    the civilian group will give intelligence to a member of the force
    group.  This family of orders are used to manipulate the
    initial baseline cooperation levels between various groups.  (Use the
    <<cref /order/mad/coop>> to adjust or otherwise influence the 
    cooperation levels during simulation.)<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order COOP:UPDATE "Update Initial Cooperation" {
    <<parmlist>>
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm base "Baseline">>
    <b>Optional.</b>  The initial baseline cooperation level of 
    group <i>f</i> with group <i>g</i>.  Cooperation levels
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order updates the initial baseline
    cooperation level of one group with another; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    cooperation levels during simulation.)
}

#-----------------------------------------------------------------------

order COOP:UPDATE+MULTI "Update Initial Cooperation (Multi)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids cooperation>><p>

    Programmatically, each ID is a list {<i>f g</i>} where
    <i>f</i> and <i>g</i> are defined as for the 
    <<cref /order/coop/update>> order.
    <</parm>>

    <<parm base "Baseline">>
    <b>Required.</b>  The initial baseline cooperation level for 
    the selected curves.  Cooperation levels run from 0.0 to 100.0, and 
    are defined either numerically or using the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order updates the initial baseline
    cooperation level for two or more cooperation curves, as selected 
    in the GUI.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    cooperation levels during simulation.)
}

#=======================================================================
# Econ Model Orders

page /order econ "Economic Model Orders" {
    <<title>>

    This section describes the orders used to configure Athena's
    Economic Model.
}

macro ECON.pcf {} {
    |<--
    The production capacity factor (PCF) for the neighborhood, a
    non-negative real number.  This is a 
    multiplier used to dial up and down the production capacity for
    goods in a neighborhood. A factor of 1.0 usually indicates the
    production capacity at the beginning of the scenario; a factor
    less than 1.0 indicates that production capacity (e.g., factories)
    have been damaged, and a factor greater than 1.0 indicates that
    new production capacity has been built.<p>

    It is possible to being the scenario with a PCF less than 1.0,
    indicating that the neighborhood's capacity has already been
    seriously damaged as the scenario begins.
}


order ECON:UPDATE "Update Neighborhood Economic Inputs" {
    <<parmlist>>

    <<NBHOOD.n>>

    <<parm pcf "Proc. Capacity Factor">>
    <b>Optional.</b>  <<ECON.pcf>>
    <</parm>>
    <</parmlist>>

    Updates the economic inputs for a single neighborhood.
}

#-----------------------------------------------------------------------

order ECON:UPDATE+MULTI "Update Economic Inputs for Multiple Neighborhoods" {
    <<parmlist>>

    <<parm ids "Neighborhoods">>
    <b>Required.</b>  <<parm.ids neighborhood>>
    <</parm>>

    <<parm pcf "Proc. Capacity Factor">>
    <b>Optional.</b>  <<ECON.pcf>>
    <</parm>>
    <</parmlist>>

    Updates the economic inputs for multiple neighborhoods.
}






#=======================================================================
# Environmental Situation Orders

page /order ensit "Environmental Situation Orders" {
    <<title>>

    Athena models a variety of on-going conditions within
    neighborhoods; these are collectively referred to as
    <i>environmental situations</i>.  The set of situation types
    includes epidemics, contaminated food and water, power and
    communication outages, and so forth.  Detailed information about
    each situation type may be found in the Athena Rules document.<p>

    This family of orders is used to create, update, and resolve
    environmental situations.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

macro ENSIT.initial {} {
    |<--
    The numeric ID of an environmental situation that has not yet
    become active.  Ensits become active at the first time advance
    after their creation.
}

macro ENSIT.location {} {
    |<--
    The location of the situation, expressed as a 
    [term mapref].  The situation affects the
    neighborhood that contains this location, and so the location must
    lie within some neighborhood.
}

macro ENSIT.stype {} {
    |<--
    The type of situation.  There may be only one
    environmental situation of a given type in each neighborhood.<p>

    [enumdoc ::projectlib::eensit]
}

macro ENSIT.coverage {} {
    |<--
    Neighborhood coverage fraction, as a positive real number
    less than or equal to 1.0.  The coverage represents the fraction
    of the neighborhood's population that is affected by this situation.
}

macro ENSIT.inception {} {
    |<--
    A flag (<b>YES</b>, <b>NO</b>) that determines
    whether the situation has inception effects.  Set this to
    <b>NO</b> for situations that are to be on-going at time 0. 
}

macro ENSIT.g {} {
    |<--
    The name of the group that the neighborhood
    population considers responsible for causing this situation,
    or <b>NONE</b> if none.
}

macro ENSIT.rduration {} {
    |<--
    A duration, in integer days.  If positive, the
    situation will automatically be resolved at the end of the
    specified time. If 0, no auto-resolution will take place.<p>

    If this value is omitted, it will default to the value of the
    <b>ensit.<i>stype</i>.duration</b> [cref /parmdb parameter].
}

#-----------------------------------------------------------------------

order ENSIT:CREATE "Create Environmental Situation" {
    <<parmlist>>
    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>
    <</parm>>

    <<parm stype "Type">>
    <b>Required.</b> <<ENSIT.stype>>
    <</parm>>

    <<parm coverage "Coverage">>
    <b>Required.</b> <<ENSIT.coverage>>
    <</parm>>

    <<parm inception "Inception?">>
    <b>Required.</b> <<ENSIT.inception>>
    <</parm>>

    <<parm g "Caused By">>
    <b>Required.</b>  <<ENSIT.g>>
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Required.</b>  The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  This entry is used when the situation
    resolves itself automatically; it can be overridden if the
    situation is resolved manually.
    <</parm>>

    <<parm rduration "Duration">>
    <b>Optional.</b>  <<ENSIT.rduration>>
    <</parm>>

    <</parmlist>>

    This order creates a new environmental situation.  Note that the
    <<cref /order/ensit/update>> order can be used to
    edit any of these values so long as the situation has not yet
    become active, i.e., up until the next time advance.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#-----------------------------------------------------------------------

order ENSIT:DELETE "Delete Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  <<ENSIT.initial>>
    <</parm>>
    <</parmlist>>

    Deletes an existing environmental situation.
}

#-----------------------------------------------------------------------

order ENSIT:UPDATE "Update Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  <<ENSIT.initial>>
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>
    <</parm>>

    <<parm stype "Type">>
    <b>Required.</b> <<ENSIT.stype>>
    <</parm>>

    <<parm coverage "Coverage">>
    <b>Required.</b> <<ENSIT.coverage>>
    <</parm>>

    <<parm inception "Inception?">>
    <b>Required.</b> <<ENSIT.inception>>
    <</parm>>

    <<parm g "Caused By">>
    <b>Required.</b>  <<ENSIT.g>>
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Required.</b>  The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  This entry is used when the situation
    resolves itself automatically; it can be overridden if the
    situation is resolved manually.
    <</parm>>

    <<parm rduration "Duration">>
    <b>Optional.</b>  <<ENSIT.rduration>>
    <</parm>>

    <</parmlist>>

    Updates an existing environmental situation that has not yet
    become active.
}


#-----------------------------------------------------------------------

order ENSIT:MOVE "Move Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  The numeric ID of any existing environmental
    situation.
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>  <b>Note:</b> If the ensit
    has already become active, it cannot be moved out of its
    neighborhood.
    <</parm>>

    <</parmlist>>

    Moves an existing environmental situation from one place to another.
}


order ENSIT:RESOLVE "Resolve Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  The numeric ID of any unresolved environmental
    situation.
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Optional.</b> The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  If specified, overrides the group name
    given when the situation was 
    <<cref /order/ensit/create created>>.
    <</parm>>

    <</parmlist>>

    Resolves an unresolved environmental situation.  Any on-going
    effects will be terminated, and the neighborhood population will
    usually respond favorably.<p>


    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#=======================================================================
# Goal Orders

page /order goal "Goal Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term goal>>s.

    <<childlinks>>
} 

order GOAL:CREATE "Create Goal" {
    This order creates a new <<term goal>>.
    The order parameters are as follows:<p>

    <<goal_ parmlist -required -tags create>>
}

order GOAL:DELETE "Delete Goal" {
    Deletes an existing <<term goal>>, along with all entities 
    (e.g., conditions) that depend upon it.    
    The order parameters are as follows:<p>

    <<parmlist>>

    <<parm goal_id "Goal ID">>
    <b>Required.</b>  The ID of an existing goal.
    <</parm>>
    
    <</parmlist>>

    Deletes the goal.
}

order GOAL:UPDATE "Update Goal" {
    This order modifies the
    definition of an existing <<term goal>>.  
    The order parameters are as follows:<p>

    <<parmlist>>
    <<goal_ parm goal_id -required>>

    <<parm owner "Owner">>
    <b>Display Only.</b> The name of the actor whose goal this is.
    <</parm>>

    <<goal_ parm narrative -required>>

    <</parmlist>>
}

order GOAL:STATE "Set Goal State" {
    Sets the <<term goal>>'s state.  Note that this order is for 
    internal use by the application; there is no associated order 
    dialog.  The order parameters are as follows:<p>


    <<parmlist>>
    <<goal_ parms -required -tags state>>
    <</parmlist>>
}


#=======================================================================
# Group Orders

macro GROUP.g {flavor} {
    |<--
    The ID of an existing $flavor group.
}

macro GROUP.color {} {
    |<--
    The group's color, used when displaying the group's units
    on the map viewer.  In general, group colors will be selected
    using the color selection dialog; if a color is entered as a
    string, it must be specified as a hex color string, of
    one of the following forms<p>

    #<i>rrggbb</i><br>
    #<i>rrrgggbbb</i><br>
    #<i>rrrrggggbbbb</i><p>

    where <i>r</i>, <i>g</i> and <i>b</i> are hexadecimal digits 
    expressing a shade of red, green, or blue.  Thus, "#000000" is
    black, and "#FFFFFF" is white.<p>
}

macro GROUP.shape {} {
    |<--
    According to MIL-STD-2525a, friendly, neutral, and enemy units
    are drawn differently by the map viewer.  This parameter
    determines whether the group's units are drawn as friendly,
    neutral, or enemy.  The possible values are as follows:<p>

    [enumdoc ::projectlib::eunitshape]
}

macro GROUP.demeanor {} {
    |<--
    The demeanor of the group, i.e., its propensity for
    violence. The possible values are as follows:<p>

    [enumdoc ::projectlib::edemeanor]
}

macro GROUP.a {} {
    |<--
    The group's owning actor.  This parameter may remain unset during
    [term prep], but must be specified before time can be
    advanced.
}

macro GROUP.cost {} {
    |<--
    The cost to the owning actor of 
    maintaining one member of the group in the playbox for one week,
    in dollars.
    Costs incurred outside the playbox should be excluded, e.g., 
    wages for U.S. troops.  The cost is expressed as a decimal number
    with an optional "K", "M", or "B" suffix, "1K" is 1,000 dollars.
}




#=======================================================================
# Civilian Group Orders

page /order civgroup "Civilian Group Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term civgroup>>s.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order CIVGROUP:CREATE "Create Civilian Group" {
    <b><<term prep>> Only.</b>  This order creates a
    new <<term civgroup>>.  The order parameters
    are as follows:<p>
    
    <<parmlist>>
    <<group_civ parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order CIVGROUP:DELETE "Delete Civilian Group" {
    <b><<term prep>> Only.</b>  Deletes an existing
    civilian group, along with all entities (e.g., attitudes)
    that depend upon it.<p>

    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>
    <</parmlist>>

}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE "Update Civilian Group" {
    <b><<term prep>> Only.</b>  This order updates an
    existing <<term civgroup>>.  The order parameters
    are as follows:<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>

    <<group_civ parms -optional -tags update>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+MULTI "Update Multiple Civilian Groups" {
    <b><<term prep>> Only.</b>  This order modifies two or 
    more <<term civgroup>>s, as selected in the GUI.<p>

    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "civilian group">>
    <</parm>>

    <<group_civ parms -optional -tags multi>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+POSTPREP "Update Civilian Group (Post-PREP)" {
    This order updates an existing <<term civgroup>>
    after leaving <<term prep>>.  Only a subset of the
    group attributes can be edited.<p>

    This order can be sent by an 
    <<cref /object/tactic/executive>> script using the 
    <<cref /command/send>> executive command.<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b> <<GROUP.g civilian>>
    <</parm>>

    <<group_civ parms -required -tags postprep>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+POSTPREP+MULTI "Update Multiple Civilian Groups (Post-PREP)" {
    This order updates two or more existing <<term civgroup>>s,
    as selected in the GUI, 
    after leaving <<term prep>>.  Only a subset of the
    group attributes can be edited.<p>

    <<parmlist>>

    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "civilian group">>
    <</parm>>

    <<group_civ parms -required -tags postprep>>
    <</parmlist>>
}


#=======================================================================
# Force Group Orders

page /order frcgroup "Force Group Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term frcgroup>>s.

    <<childlinks>>
}


#-----------------------------------------------------------------------

order FRCGROUP:CREATE "Create Force Group" {
    <b><<term prep>> Only.</b>  This order creates a new 
    <<term frcgroup>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<group_frc parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order FRCGROUP:DELETE "Delete Force Group" {
    <b><<term prep>> Only.</b>  Deletes an existing
    <<term frcgroup>>, along with all entities
    that depend upon it.  The order parameters are as follows:<p>

    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order FRCGROUP:UPDATE "Update Force Group" {
    <b><<term prep>> Only.</b>  This order modifies the
    definition of an existing <<term frcgroup>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>

    <<group_frc parms -optional -tags update>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order FRCGROUP:UPDATE+MULTI "Update Multiple Force Groups" {
    <b><<term prep>> Only.</b>  This order modifies the
    definition of two or more existing <<term frcgroup>>s, as
    selected in the GUI.  The order parameters are as follows:<p>

    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "force group">>
    <</parm>>

    <<group_frc parms -optional -tags multi>>
    <</parmlist>>
}


#=======================================================================
# Organization Group Orders

page /order orggroup "Organization Group Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term orggroup>>s.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ORGGROUP:CREATE "Create Organization Group" {
    <b><<term prep>> Only.</b>  This order creates a new 
    <<term orggroup>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<group_org parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order ORGGROUP:DELETE "Delete Organization Group" {
    <b><<term prep>> Only.</b>  Deletes an existing
    <<term orggroup>>, along with all entities
    that depend upon it.<p>

    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order ORGGROUP:UPDATE "Update Organization Group" {
    <b><<term prep>> Only.</b>  This order modifies the
    definition of an existing <<term orggroup>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>

    <<group_org parms -optional -tags update>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order ORGGROUP:UPDATE+MULTI "Update Multiple Organization Groups" {
    <b><<term prep>> Only.</b>  This order modifies the
    definition of two or more existing <<term orggroup>>s, as
    selected in the GUI.  The order parameters are as follows:<p>

    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "organization group">>
    <</parm>>

    <<group_org parms -optional -tags multi>>
    <</parmlist>>
}

#=======================================================================
# Magic Attitude Driver Orders

page /order mad "Magic Attitude Driver Orders" {
    <<title>>

    Athena models a number of events and situations that drive
    attitude change, e.g., civilian attrition and environmental
    situations.  The set of drivers is not all encompassing, and so
    Athena allows the analyst to create <i>Magic Attitude Drivers</i>
    (MADs).  Once a MAD is created, the analyst may associate with it a
    variety of attitude adjustments and inputs; and the effects of
    these inputs will be associated with the MAD when viewing the history.<p>

    The following orders are used to create and manipulate MADs:<p>

    <<childlinks>>
}

macro MAD.mad {} {
    |<--
    The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
}

macro MAD.mode {} {
    |<--
    The mode, <b>persistent</b> or <b>transient</b>.  Transient inputs
    affect the current level of the curve during the next time step; 
    persistent inputs affect the curve's baseline, and hence usually 
    persistent during subsequent weeks.
}

macro MAD.mag {} {
    |<--
    The magnitude of the input in points, expressed as a real
    number, or as one of the symbols from the following table:<p>

    [::simlib::qmag html]
}

macro MAD.cause {} {
    |<--
    The [term cause] for any magic attitude input associated with
    this MAD.  The cause
    may be <b>UNIQUE</b>, indicating that the effects of this MAD
    are independent of all other drivers, or it may be
    any cause from the following list:<p>

    [enumdoc ::projectlib::ecause]
}

macro MAD.s {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in the same
    neighborhood as the input are multiplied by this factor.  
    If it is 0.0, there will be no such indirect effects.
}

macro MAD.p {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in <b>NEAR</b>
    neighborhoods are multiplied by this factor.  If it is 0.0, there
    will be no such indirect effects.
}

macro MAD.q {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in <b>FAR</b>
    neighborhoods are multiplied by 
    this factor.  If it is 0.0, there will be no such indirect effects.
}



#-----------------------------------------------------------------------

order MAD:CREATE "Create Magic Attitude Driver" {
    <<parmlist>>

    <<parm narrative "Narrative">>
    <b>Required.</b>  A one-line description of the driver.
    <</parm>>

    <<parm cause "Cause">>
    <b>Required.</b> <<MAD.cause>>
    <</parm>>

    <<parm s "Here Factor">>
    <b>Required.</b> <<MAD.s>>
    <</parm>>

    <<parm p "Near Factor">>
    <b>Required.</b> <<MAD.p>>
    <</parm>>

    <<parm q "Far Factor">>
    <b>Required.</b> <<MAD.q>>
    <</parm>>
    
    <</parmlist>>

    Creates a new Magic Attitude Driver (MAD).  The narrative need
    not be unique, but should remind the analyst of the reason for the
    attitude inputs and adjustments associated with the MAD.<p>

    All magic inputs associated with this MAD will use
    the specified cause, near factor, and far factor.<p>

    <b>Note:</b> Once any attitude inputs or adjustments have been
    associated with this MAD, it can no longer be deleted.<p>

    This order can be <<cref /command/send sent>> by the
    <<cref /object/tactic/executive>>.
}

#-------------------------------------------------------------------

order MAD:DELETE "Delete Magic Attitude Driver" {
    <<parmlist>>

    <<parm driver_id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to delete.
    <</parm>>
    <</parmlist>>

    Deletes the specified MAD.  Note that a MAD cannot be deleted once
    any attitude inputs or adjustments have been associated with it.
}

#-------------------------------------------------------------------

order MAD:UPDATE "Update Magic Attitude Driver" {
    <<parmlist>>

    <<parm driver_id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to update.
    <</parm>>

    <<parm narrative "Narrative">>
    <b>Optional.</b>  A one-line description of the driver.
    <</parm>>

    <<parm cause "Cause">>
    <b>Optional.</b> <<MAD.cause>>
    <</parm>>

    <<parm s "Here Factor">>
    <b>Optional.</b> <<MAD.s>>
    <</parm>>

    <<parm p "Near Factor">>
    <b>Optional.</b> <<MAD.p>>
    <</parm>>

    <<parm q "Far Factor">>
    <b>Optional.</b> <<MAD.q>>
    <</parm>>
    
    <</parmlist>>

    Updates the MAD's definition.
}


#=======================================================================
# Magic Horizontal Relationship Orders

page /order/mad hrel "Magic Horizontal Relationship Orders" {
    <<title>>

    These orders are used to adjust and otherwise influence 
    horizontal relationship levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:HREL:ADJUST "Magic Adjust Horizontal Relationship Baseline" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A horizontal relationship curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> and <i>g</i> are two different groups.
    <</parm>>

    <<parm driver_id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number.
    <</parm>>
    <</parmlist>>

    Adjusts the value of the specified horizontal relationship curve's 
    baseline by the specified amount, clamping the curve's value to
    the range 0.0, 100.0 if need be.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#-----------------------------------------------------------------------

order MAD:HREL:INPUT "Magic Horizontal Relationship Input" {
    <<parmlist>>
    
    <<parm driver_id "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm mode "Mode">>
    <b>Required.</b> <<MAD.mode>>
    <</parm>>

    <<parm f "Of Group">>
    <b>Required.</b>  A group ID.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  A different group ID.
    <</parm>>

    <<parm mag "Magnitude">>
    <b>Required.</b>  <<MAD.mag>>
    <</parm>>
    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic horizontal relationship input into URAM.   The input will
    be persistent or transient, and will the specified curve's value 
    by <i>mag</i> nominal points at the next time advance.
    The input will be attributed to the
    specified MAD.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#=======================================================================
# Magic Vertical Relationship Orders

page /order/mad vrel "Magic Vertical Relationship Orders" {
    <<title>>

    These orders are used to adjust and otherwise influence 
    vertical relationship levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}


#-----------------------------------------------------------------------

order MAD:VREL:ADJUST "Magic Adjust Vertical Relationship Baseline" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A vertical relationship curve ID, which is a list 
    {<i>g a</i>} where <i>g</i> is a group and <i>a</i> is an actor.
    <</parm>>

    <<parm driver_id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number.
    <</parm>>
    <</parmlist>>

    Adjusts the value of the specified vertical relationship curve's 
    baseline
    by the specified amount, clamping the curve's value to the range 0.0,
    100.0 if need be.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#-----------------------------------------------------------------------

order MAD:VREL:INPUT "Magic Vertical Relationship Input" {
    <<parmlist>>
    
    <<parm driver_id "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm mode "Mode">>
    <b>Required.</b> <<MAD.mode>>
    <</parm>>

    <<parm g "Of Group">>
    <b>Required.</b>  A group ID.
    <</parm>>

    <<parm a "With Actor">>
    <b>Required.</b>  An actor ID.
    <</parm>>

    <<parm mag "Magnitude">>
    <b>Required.</b>  <<MAD.mag>>
    <</parm>>
    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic vertical relationship input into URAM.   The input will
    be persistent or transient, and will the specified curve's value 
    by <i>mag</i> nominal points at the next time advance.
    The input will be attributed to the
    specified MAD.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#=======================================================================
# Magic Satisfaction Orders

page /order/mad sat "Magic Satisfaction Orders" {
    <<title>>

    These orders are used to adjust and otherwise influence 
    satisfaction levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:SAT:ADJUST "Magic Adjust Satisfaction Baseline" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where <i>g</i> is a
    civilian group and <i>c</i> is a concern.
    <</parm>>

    <<parm driver_id "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number.
    <</parm>>
    <</parmlist>>

    Immediately adjusts the value of the specified satisfaction curve's
    baseline by the specified amount, clamping the curve's value to 
    the range -100.0, 100.0 if need be.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#-----------------------------------------------------------------------

order MAD:SAT:INPUT "Magic Satisfaction Input" {
    <<parmlist>>
    
    <<parm driver_id "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm mode "Mode">>
    <b>Required.</b> <<MAD.mode>>
    <</parm>>

    <<parm g "Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  A concern.
    <</parm>>

    <<parm mag "Magnitude">>
    <b>Required.</b>  <<MAD.mag>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic satisfaction input into URAM.  The input will
    be persistent or transient, and will the specified curve's value 
    by <i>mag</i> nominal points at the next time advance.
    The input will be attributed to the
    specified MAD.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#=======================================================================
# Magic Cooperation Orders

page /order/mad coop "Magic Cooperation Orders" {
    <<title>>

    These orders are used to adjust and otherwise influence 
    cooperation levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:COOP:ADJUST "Magic Adjust Cooperation Baseline" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm driver_id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number.
    <</parm>>
    <</parmlist>>

    Adjusts the value of the specified cooperation curve's baseline
    by the specified amount, clamping the curve's value to the range 0.0,
    100.0 if need be.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}

#-----------------------------------------------------------------------

order MAD:COOP:INPUT "Magic Cooperation Input" {
    <<parmlist>>
    
    <<parm driver_id "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm mode "Mode">>
    <b>Required.</b> <<MAD.mode>>
    <</parm>>

    <<parm f "Of Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  A force group ID.
    <</parm>>

    <<parm mag "Magnitude">>
    <b>Required.</b>  <<MAD.mag>>
    <</parm>>
    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic cooperation input into URAM.   The input will
    be persistent or transient, and will the specified curve's value 
    by <i>mag</i> nominal points at the next time advance.
    The input will be attributed to the
    specified MAD.<p>

    This order can be <<cref /command/send sent>>
    or <<cref /command/sched scheduled>> by the
    <<cref /object/tactic/executive>>.
}



#=======================================================================
# Map Orders

page /order map "Map Orders" {
    <<title>>

    Athena allows the user to specify a map background to aid in both
    the construction of the scenario and the analysis and
    visualization of the results.  The following orders manipulate
    the image used as the map background:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAP:IMPORT "Import Map" {
    <<parmlist>>

    <<parm filename "Map File">>
    <b>Required.</b>  The name of a GIF, JPEG, or PNG image to be used
    as the map background.
    <</parm>>
    <</parmlist>>

    Imports an image into the scenario for use as the map background,
    replacing any previous map image.  The image data is saved within
    the scenario; it's not necessary to send the image file along with
    the saved .adb file.<p>

    This order is usually sent indirectly, using the
    <<menu "File/Import Map...">> menu item.  However, Athena should
    eventually support order script, and it it is documented here for
    that purpose.
}




#=======================================================================
# Neighborhood Orders

include order_nbhood.help

#=======================================================================
# Neighborhood Relationship Orders

page /order nbrel "Neighborhood Relationship Orders" {
    <<title>>

    The Athena playbox, or region of interest, is divided into 
    <<cref /order/nbhood neighborhoods>>.  Neighborhoods are related
    to each other in two ways: by proximity, and by the time it takes
    attitude effects to spread.  The neighborhood relationship orders
    are used to edit these relationships.<p>

    Neighborhood relationships are created automatically for every
    pair of neighborhoods, and are deleted as necessary when
    neighborhoods are deleted.<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order NBREL:UPDATE "Update Neighborhood Relationship" {
    <<parmlist>>
    <<parm id "Neighborhood">> 
    <b>Required.</b>  A neighborhood relationship ID, specified as
    a list {<i>m</i>, <i>n</i>} where <i>m</i> and <i>n</i> are
    neighborhoods and the data is <i>m</i>'s relationship with
    <i>n</i>.  Note that a neighborhood's relationship with itself
    is fixed, so <i>m</i> cannot equal <i>n</i>.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order modifies existing
    neighborhood relationships.<p>
}

#-------------------------------------------------------------------

order NBREL:UPDATE+MULTI "Update Multiple Neighborhood Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids "neighborhood relationship">><p>

     Programmatically, each ID is a list {<i>m n</i>} where <i>m</i>
    and <i>n</i> are defined as for the 
    <<cref /order/nbrel/update>> order.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order modifies two or more
    neighborhood relationships, as selected in the GUI.<p>
}

#=======================================================================
# Horizontal Relationship Orders

page /order hrel "Horizontal Relationship Orders" {
    <<title>>

    Groups can be friends, enemies, or neutrals, as determined by
    their <i>horizontal relationship</i>, a number between -1.0 and 1.0.<p>

    Initial relationships are computed from the groups' belief
    systems (force and organization groups inherit their belief
    systems from their owning actors), but can be overridden
    manually by the user using these orders.  Once the scenario is
    locked, relationships can vary dynamically.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order HREL:OVERRIDE "Override Baseline Horizontal Relationship" {
    <<parmlist>>
    <<parm id "Groups">>
    <b>Required.</b>  A group relationship ID, specified as a 
    list {<i>f g</i>} where <i>f</i> and <i>g</i> are two groups.  The
    associated relationship is <i>f</i>'s relationship with <i>g</i>.
    Note that a group's relationship with itself is always 1.0 and
    cannot be overridden.
    <</parm>>

    <<parm base "Baseline">>
    <b>Optional.</b>  The new baseline relationship between the two groups,
    a decimal number between -1.0 and 1.0.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order overrides the
    affinity-based initial baseline relationship between the two
    groups with one of the user's choosing.
}

#-----------------------------------------------------------------------

order HREL:RESTORE "Restore Baseline Horizontal Relationship" {
    <<parmlist>>
    <<parm id "Groups">>
    <b>Required.</b>  A group relationship ID, specified as a 
    list {<i>f g</i>} where <i>f</i> and <i>g</i> are two groups.  The
    associated relationship is <i>f</i>'s relationship with <i>g</i>.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order restores the affinity-based
    initial baseline relationship between the two groups, 
    deleting any manual override.
}

#-----------------------------------------------------------------------

order HREL:OVERRIDE+MULTI "Override Multiple Baseline Horizontal Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids relationship>><p>

    Programmatically, each ID is a list {<i>f g</i>} where
    <i>f</i> and <i>g</i> are defined as for the 
    <<cref /order/hrel/override>> order.
    <</parm>>

    <<parm base "Baseline">>
    <b>Optional.</b>  The baseline relationship between two groups,
    a decimal number between -1.0 and 1.0.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order overrides two or more
    affinity-based initial baseline horizontal relationships, 
    as selected in the GUI, with values of the user's choosing.
}

#=======================================================================
# Vertical Relationship Orders

page /order vrel "Vertical Relationship Orders" {
    <<title>>

    A group can support or oppose an actor, as determined by its
    <i>vertical relationship</i> with the actor, a number between 
    -1.0 and 1.0.<p>

    Initial vertical relationships are computed from the belief
    systems of the group and actor, where force and organization groups 
    inherit their belief systems from their owning actors; they can be 
    overridden manually using these orders.  Once the scenario 
    is locked, relationships can vary dynamically.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order VREL:OVERRIDE "Override Baseline Vertical Relationship" {
    <<parmlist>>
    <<parm id "Group/Actor">>
    <b>Required.</b>  A vertical relationship ID, specified as a 
    list {<i>g a</i>} where <i>g</i> is a group and <i>a</i> is an actor.
    The associated relationship is <i>g</i>'s relationship with <i>a</i>.
    <</parm>>

    <<parm base "Baseline">>
    <b>Optional.</b>  The new baseline relationship between the group 
    and the actor, a decimal number between -1.0 and 1.0.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order overrides the
    affinity-based initial baseline relationship between the group
    and the actor with one of the user's choosing.
}

#-----------------------------------------------------------------------

order VREL:RESTORE "Restore Baseline Vertical Relationship" {
    <<parmlist>>
    <<parm id "Group/Actor">>
    <b>Required.</b>  A vertical relationship ID, specified as a 
    list {<i>g a</i>} where <i>g</i> is a group and <i>a</i> is an 
    actor.  The associated relationship is <i>g</i>'s relationship 
    with <i>a</i>.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order restores the affinity-based
    initial baseline relationship between the group and the actor, 
    deleting any manual override.
}

#-----------------------------------------------------------------------

order VREL:OVERRIDE+MULTI "Override Multiple Baseline Vertical Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids relationship>><p>

    Programmatically, each ID is a list {<i>g a</i>} where
    <i>g</i> and <i>a</i> are defined as for the 
    <<cref /order/hrel/override>> order.
    <</parm>>

    <<parm base "Baseline">>
    <b>Optional.</b>  The baseline relationship between a group and an 
    actor, a decimal number between -1.0 and 1.0.
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order overrides two or more
    affinity-based initial baseline vertical relationships, 
    as selected in the GUI, with values of the user's choosing.
}

#=======================================================================
# Satisfaction Orders

page /order sat "Satisfaction Orders" {
    <<title>>

    Athena models the satisfaction of civilian groups with respect
    to a variety of
    concerns.  This family of orders are used to manipulate the
    initial baseline satisfaction levels and related parameters.  
    (Use the <<cref /order/mad/sat>> to adjust or otherwise influence the 
    levels during simulation.)<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order SAT:UPDATE "Update Baseline Satisfaction" {
    <<parmlist>>
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where <i>g</i> is a
    civilian group and <i>c</i> is a concern.
    <</parm>>

    <<parm base "Baseline">>
    <b>Optional.</b>  The initial baseline satisfaction level of 
    group <i>g</i> with concern <i>c</i>.  Satisfaction levels
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm saliency "Saliency">>
    <b>Optional.</b>  The importance of concern <i>c</i> to the group.
    Saliencies range from 0.0 to 1.0, and are defined either
    numerically or using the following rating scale:<p>

    <<::simlib::qsaliency html>>
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  This order updates the initial baseline
    satisfaction level of one group with a concern; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    levels during simulation.)
}


#-----------------------------------------------------------------------

order SAT:UPDATE+MULTI "Update Baseline Satisfaction (Multi)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids satisfaction>><p>

    Programmatically, each ID is a list {<i>g c</i>} where
    <i>g</i> and <i>c</i> are defined as for the 
    <<cref /order/sat/update>> order.
    <</parm>>

    <<parm base "baseline">>
    <b>Optional.</b>  The initial baseline satisfaction level of 
    group <i>g</i> with concern <i>c</i>.  Satisfaction levels
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm saliency "Saliency">>
    <b>Optional.</b>  The importance of concern <i>c</i> to the group.
    Saliencies range from 0.0 to 1.0, and are defined either
    numerically or using the following rating scale:<p>

    <<::simlib::qsaliency html>>
    <</parm>>
    
    <</parmlist>>

    <b><<term prep>> Only.</b>  This order updates two or more initial
    baseline satisfaction levels, as selected in the GUI; this can only 
    be done during the Scenario Preparation phase.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    levels during simulation.)
}

#=======================================================================
# Simulation Control Orders

page /order sim "Simulation Control Orders" {
    <<title>>

    The orders in this set are used to control the simulation in
    general.  Most of them are used implicitly, by various GUI
    controls.  They are documented here for completeness.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order SIM:STARTDATE "Set Start Date" {
    <<parmlist>>
    <<parm startdate "Start Date">>
    <b>Required.</b>  A <<term zulu>> corresponding to 
    simulation time 0.  By convention, the hours and minutes 
    should be "0000".
    <</parm>>

    <</parmlist>>

    <b><<term prep>> Only.</b>  Athena generally reports
    simulation time as a number of integer days and as a zulu-time.
    This order determines how simulation time is translated to zulu-time.
}


order SIM:RUN "Run Simulation" {
    <<parmlist>>
    <<parm days "Days to Run">>
    <b>Optional.</b>  An integer number of days.  If 0, or not
    specified, the simulation will run until explicitly paused by the
    user.  If greater than 0, the simulation will run for the
    specified number of days, and then halt.
    <</parm>>

    <<parm block "Block?">>
    <b>Optional.</b>  A boolean flag.  If true, the order will
    block--that is, the simulation will run for the specified number
    of days and then the order handler will return.  If false (the
    default) the order handler returns immediately, and the simulation
    runs forward under the control of the Tcl event loop.<p>
    <</parm>>

    <</parmlist>>

    Advances simulation time.  This order is usually triggered by the
    "play" button in the GUI.<p>

    If the simulation is in the <<term prep>> state, the order
    does a sanity check on the scenario; time will not be allowed to
    advance if the scenario is incomplete.
}


order SIM:PAUSE "Pause Simulation" {
    Pauses the simulation at the next possible moment: immediately if
    the simulation is waiting in the Tcl event loop between 
    <<term tick>>s, and at the end of the current tick if it's in the 
    middle of a tick.<p>

    This order is usually triggered by the "pause" button in the GUI.
}


#=======================================================================
# Tactic Orders

include order_tactic.help

#=======================================================================
# Unit Orders

page /order unit "Unit Orders" {
    <<title>>

    A <<term unit>> is an object that represents some number of people in 
    a particular neighborhood, typically performing some activity.

    Units are modified using the following orders:<p>

    <<childlinks>>
}


order UNIT:MOVE "Move Unit" {
    <<parmlist>>
    <<parm u "Name">>
    <b>Required.</b>  The name of the unit to move.
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  The unit's new location, expressed as
    a <<term mapref>>.
    <</parm>>
    <</parmlist>>

    Moves the unit to its new location, which must be within the same 
    neighborhood.
}



#=======================================================================
# Order Orders

page /order order "Order Scheduling Orders" {
    <<title>>

    Athena allows certain orders to be scheduled to execute at some
    later time.  These orders are used to schedule orders for
    execution, and to cancel the scheduled orders.<p>

    The user will usually use these orders indirectly, via the
    the "Schedule" button on the various order dialogs, and the "X" 
    button on the Orders browser;  Athena <<version>> provides no 
    other way for the user to access them.  They are documented here 
    for completeness' sake.<p>

    In the long-run, it is likely that Athena will be able to execute
    order scripts; at that time, the user will be able to enter these
    orders directly into the scripts.<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order ORDER:CANCEL "Cancel Scheduled Order" {
    <<parmlist>>

    <<parm id "Order ID">> 
    <b>Required.</b>  The ID of the scheduled order, as shown in 
    the Orders browser.
    <</parm>>

    <</parmlist>>

    This order cancels a scheduled order given its ID.
}

#-------------------------------------------------------------------

order ORDER:SCHEDULE "Schedule Order" {
    <<parmlist>>

    <<parm timespec "Time Spec">> 
    <b>Required.</b> The time at which the order should be scheduled
    to execute, expressed as a <<term timespec>>.  The time must be at
    least "NOW+1".
    <</parm>>

    <<parm name "Order Name">>
    <b>Required.</b> The name of the order, as shown on the second
    line of the order's help page.  For example, the name of this
    order (as opposed to its title) is <b>ORDER:SCHEDULE</b>.

    <<parm parmdict "Parm Dict">>
    A Tcl dictionary of parameter names and values, using the 
    parameter names shown in parentheses on the order's help page.
    The name of this parameter, for example, is <b>parmdict</b>.
    <</parm>>

    <</parmlist>>

    This order schedules the order to execute at the specified time.
    It does not ensure that the order will be accepted; a valid order
    might become invalid by the time it executes, and an invalid order
    might (in particular cases) become valid.
}

#=======================================================================
# Parm Orders

page /order parm "Model Parameter Orders" {
    <<title>>

    These orders are used to set the values of the 
    Athena <<cref /parmdb>>.<p>

    The user will usually use these orders indirectly, via the
    <<command parm>> <<cref /command "executive command">> and its
    subcommands; Athena <<version>> provides no other way for the user
    to access them.  They are documented here for completeness'
    sake.<p>

    In the long-run, it is likely that Athena will be able to execute
    order scripts; at that time, the user will be able to enter these
    orders directly into the scripts.<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order PARM:IMPORT "Import Parameter File" {
    <<parmlist>>

    <<parm filename "Parameter File">> 
    <b>Required.</b>  Name of a parmdb(5) parameter file.
    <</parm>>

    <</parmlist>>

    This order imports <<cref /parmdb "model parameter">> settings from
    a disk file.  See <<command parm import>> for details.
}


#-------------------------------------------------------------------

order PARM:RESET "Reset Parameters to Defaults" {
    This order resets all <<cref /parmdb "model parameters">> to
    their default values.  See <<command parm reset>> for details.
}

#-------------------------------------------------------------------

order PARM:SET "Set Parameter Value" {
    <<parmlist>>

    <<parm parm "Parameter">> 
    <b>Required.</b>  Name of a parmdb(5) parameter.
    <</parm>>

    <<parm value "Value">> 
    <b>Required.</b>  New parameter value.
    <</parm>>

    <</parmlist>>

    This order sets the value of the named parameter.  See 
    <<command parm set>> for details. 
}

#=======================================================================
# Report Orders

page /order report "Report Orders" {
    <<title>>

    These orders are used to request specific reports.  The requested
    report will appear in the Detail Browser.  Most reports are 
    customized or filtered versions of standard Detail Browser pages.
    The complete set of requested reports is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order REPORT:DRIVER "Attitude Drivers Report" {
    This report lists the events and situations which have driven 
    changes in Athena's attitude model.<p>

    <<parmlist>>

    <<parm state "Driver State">>
    <b>Required.</b>  The report will include only those drivers with the
    given state.  The set of valid states is as follows:<p>

    <ul>
    <li> <b>all</b>: All drivers
    <li> <b>active</b>:  Active drivers: those that are currently or have 
         previously caused attitudes to change.
    <li> <b>empty</b>: Empty drivers: those that have never caused
         attitudes to change.
    </ul>
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

order REPORT:PARMDB "Model Parameters Report" {
    This report lists each of Athena's model parameters with its current
    and default values.<p>

    The report's output can be filtered in two ways.  First, if
    <b>CHANGED</b> is selected, the report will include only those
    parameters whose values differ from their installation defaults.  
    Second, the report will include only parameters whose names match
    the specified wildcard pattern.  (Wildcard-matching is case-insensitive.)
    For example, the wildcard "aam.UFvsNF.*" will limit the output to
    the parameters governing uniformed vs. non-uniformed attrition.<p>

    <<parmlist>>

    <<parm state "Parameter State">>
    <b>Required.</b>  The set of parameters to include in the report:<p>

    <ul>
    <li> <b>ALL</b>: All parameters
    <li> <b>CHANGED</b>:  All parameters that have been changed from their 
         default settings.
    </ul>
    <</parm>>

    <<parm wildcard "Wildcard">>
    <b>Optional.</b>  A wildcard pattern, e.g., the pattern "aam.*"
    matches all of the attrition model parameters.
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

order REPORT:SATCONTRIB "Contribution to Satisfaction Report" {
    For a given satisfaction curve or group mood, this report lists
    the top satisfaction drivers along with their total contributions
    to satisfaction change.  The user can select the time interval,
    and the maximum number of drivers to list.<p>

    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  The name of the civilian group.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  The name of a concern, as chosen from the
    following list, or "MOOD" for the group's mood:<p>

    <<enumdoc ::projectlib::econcern>>
    <</parm>>

    <<parm top "Number">>
    <b>Optional.</b>  The maximum number of drivers to include in the
    list.  Defaults to 20.    
    <</parm>>

    <<parm start "Start Time">>
    <b>Optional.</b>  The start time of the interval of interest, 
    expressed as a <<term timespec>>.  Defaults to "T0", the start of
    simulation time.
    <</parm>>

    <<parm end "End Time">>
    <b>Optional.</b>  The end time of the interval of interest, 
    expressed as a <<term timespec>>.  Defaults to "NOW", the current
    simulation time.
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order sqdeploy "Status Quo Group Deployment Orders" {
    <<title>>

    In Athena, force and organization personnel must be deployed to
    neighborhoods.  During simulation, this is done via the
    <<cref /object/tactic/deploy>> during <<term strategy>> execution.
    However, strategy execution assumes the presence of a status quo:
    troop deployments, neighborhood security levels, and so forth;
    without this status quo, strategies will not execute as they
    ought.<p>

    Consequently, these orders are used to specify the "status quo"
    troop deployments for all force and organization groups.  These
    deployments form part of the context for the initial strategy
    execution that takes place when the scenario is locked and
    simulation begins.<p>

    <<childlinks>>
}

order SQDEPLOY:SET "Set Status Quo Group Deployment" {
    This order is used to set a force or organization group's initial
    "status quo" deployment of personnel into a particular
    neighborhood.  By default, no personnel are assigned to any
    neighborhood.<p>

    <<parmlist>>
    <<parm id "Nbhood/Group">>
    <b>Required.</b>  A list {<i>n g</i>} where <i>n</i> is the name
    of a neighborhood and <i>g</i> is the name of a a force or
    organization group.
    <</parm>>

    <<parm personnel "Personnel">>
    <b>Required.</b> The number of group <i>g's</i> personnel to
    deploy to neighborhood <i>n</i>.
    <</parm>>

    <</parmlist>>
}

order SQDEPLOY:DELETE "Delete Status Quo Group Deployment" {
    This order is used to delete an initial
    "status quo" deployment of force or organization group personnel 
    into a particular, that is, to set an existing deployment to
    zero.<p>

    <<parmlist>>
    <<parm id "Nbhood/Group">>
    <b>Required.</b>  A list {<i>n g</i>} where <i>n</i> is the name
    of a neighborhood and <i>g</i> is the name of a a force or
    organization group.
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order sqservice "Status Quo ENI Funding Orders" {
    <<title>>

    In Athena, <<term actor>>s provide Essential Non-Infrastructure
    (ENI) services to <<term civgroup>>s using the 
    <<cref /object/tactic/fundeni>> during <<term strategy>>
    execution.  However, strategies execute in the context of the
    status quo, and so the actor's tactics cannot establish the
    status quo at time 0, when the scenario is locked and simulation
    begins.<p>

    Consequently, these orders are used to specify the "status quo"
    level of funding for ENI services from each actor to each each
    civilian group.  This affects the initial vertical
    relationship between each civilian group and each actor, which in turn
    affects each actor's support and influence in each neighborhood.<p>

    <<childlinks>>
}

order SQSERVICE:SET "Set Status Quo ENI Funding" {
    This order is used to set an <<term actor>>'s status quo level 
    of funding for Essential Non-Infrastructure (ENI) services to a 
    <<term civgroup>>.  By default, no services are funded.<p>

    <<parmlist>>
    <<parm id "Group/Actor">>
    <b>Required.</b>  A list {<i>g a</i>} where <i>g</i> is the name
    of a civilian group and <i>a</i> is the name of an actor.
    <</parm>>

    <<parm funding "Funding, $/week">>
    <b>Required.</b> The amount of money being spent on ENI services
    by the actor for the group each week, in the status quo.
    <</parm>>

    <</parmlist>>
}

order SQSERVICE:RESET "Reset Status Quo ENI Funding" {
    This order is used to reset an <<term actor>>'s status quo level 
    of funding for Essential Non-Infrastructure (ENI) services to a 
    <<term civgroup>> back to zero.<p>

    <<parmlist>>
    <<parm id "Group/Actor">>
    <b>Required.</b>  A list {<i>g a</i>} where <i>g</i> is the name
    of a civilian group and <i>a</i> is the name of an actor.
    <</parm>>

    <</parmlist>>
}
