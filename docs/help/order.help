# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    order.help
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Athena Help Documentation: Orders
#
#    This file is included into athena.help.
#
#    Orders have help pages with names like
#
#        /order/<token1>/<token2>?/...?
#
#    E.g, the CIVGROUP:CREATE order has the page
#
#       /order/civgroup/create
#
#    In some cases, the implied hierarchy in the order names is misleading;
#    for example, CIVGROUP:UPDATE:MULTI has the page
#
#       /order/civgroup/update:multi
#
#    It would better if the "UPDATE:MULTI" orders were renamed, but for
#    now, that's how it is.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------

page / order "Orders" {
    <<title>>
    The analyst communicates with Athena by means of <i>orders</i>.
    Most orders are sent by means of an order dialog; some are sent
    implicitly.  For example, dragging a unit from one place to
    another on the map implicitly sends the <<cref /order/unit/move>> 
    order.  Order dialogs can be invoked in a number of ways, e.g., by
    selecting an order from the <<cref /menu/orders>>.<p>

    Orders are grouped in the following categories:<p>

    <<childlinks>>
}

# order name title text
#
# name     The order's name (but see below)
# title    The order's title (e.g., menu item text)
# text     The documentation of the order.
#
# Defines a help page for one order.  The order hierarchy is determined
# automatically using the ":"'s in the order name.
#
# Sometimes a colon shouldn't add a new level to the order hierarchy,
# e.g., orders FOO:UPDATE and FOO:UPDATE:MULTI are at the same level.
# In this case, enter the latter as "FOO:UPDATE+MULTI".

proc order {name title text} {
    lassign [name2path /order : $name] parent slug
    set slug [string map {+ :} $slug]
    set name [string map {+ :} $name]

    set text "<<order.header [list $title]>>\n\n$text"
    page $parent $slug $name $text
}

# Formats the title for an order page
macro order.header {otitle} {
    |<--
    [mktitle normal "" $otitle "(<tt>[pageinfo title]</tt>)"]
}

macro parm.identifier {entity example} {
    |<--
    The ID for the new $entity.  It may
    contain letters and digits, and must begin with a letter.  It may
    not be the same as the ID or long name of any existing
    neighborhood, group, etc.  It should usually be short, between 2
    and 8 characters in length, e.g., <b>$example</b>.
}

macro parm.longname {entity example} {
    |<--
    A short human-readable name for the
    $entity, e.g., "$example".  If left empty on creation, the long 
    name defaults to the ${entity} ID.
}

macro parm.ids {entity} {
    |<--
    The IDs of two or more $entity entities, as selected in the GUI.
}


#=======================================================================
# Actor Orders

page /order actor "Actor Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term actor>>s.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ACTOR:CREATE "Create Actor" {
    <b><<cref /using/prep>> Only.</b>  This order creates a new 
    <<term actor>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<actor_ parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order ACTOR:DELETE "Delete Actor" {
    <b><<cref /using/prep>> Only.</b>  Deletes an existing
    <<term actor>>, along with all entities (e.g., beliefs)
    that depend upon it, given its ID.    
    The order parameters are as follows:<p>

    <<parmlist>>
    <<parm a "Actor">>
    <b>Required.</b>  ID of an existing actor.
    <</parm>>
    <</parmlist>>

}

#-----------------------------------------------------------------------

order ACTOR:UPDATE "Update Actor" {
    <b><<cref /using/prep>> Only.</b>  This order modifies the
    definition of an existing <<term actor>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm a "Select Actor">>
    <b>Required.</b> ID of an existing actor.
    <</parm>>

    <<actor_ parms -optional -tags update>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order attrit "Attrition Orders" {
    <<title>>

    Athena assesses attrition due to conflict between groups
    periodically; the period is nominally one week.  In addition,
    the analyst can cause magic attrition to unit personnel and to the 
    civilian population at any time.<p>

    <b>Note:</b> Magic attrition takes effect immediately; however, the
    attitude effects resulting from magic attrition are assessed as
    part of the regular weekly attrition assessment.<p>

    <<childlinks>>
}

macro ATTRIT.responsible {} {
    |<--
    [parm g1 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]

    [parm g2 "Responsible Group"]
    <b>Optional.</b>  The name of a force group that is wholly or
    partially responsible for the casualties.
    [/parm]
}

macro ATTRIT.general {} {
    |<--
    <b>Staffing Pools:</b>  Every unit is staffed from a staffing
    pool.  For civilian units, the staffing pool is the base
    population of the group in its neighborhood of residence; for force
    and organization units, the staffing pool is the number of
    personnel deployed to the unit's neighborhood of origin.
    
    Attrition reduces not only the number of personnel in the affected
    units, but also the number of personnel available in the group's
    staffing pool.<p>

    <b>Attitude Implications:</b>  Civilian and organization
    casualties affect the satisfaction of the relevant groups.  If
    responsible force groups are specified, then civilian casualties
    will affect the cooperation of the civilian group with the
    responsible groups.<p>

    <b>Use in [cref /object/tactic/executive]:</b>
    This order can be scheduled for execution by the EXECUTIVE tactic
    using the [cref /command/sched] executive command.  It cannot be
    sent immediately by the EXECUTIVE tactic using the
    [cref /command/send] executive command.
    
}


#-----------------------------------------------------------------------

order ATTRIT:GROUP "Magic Attrit Group" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm f "To Group">>
    <b>Required.</b>  The name of an existing civilian, force, or
    organization group to receive the casualites.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected group's
    units in a selected neighborhood.  The group's units are attrited
    proportional to their size, i.e., a unit twice as big as another
    will take twice the casualties.  Additional effects depend on
    the kind of group.<p>

    <<ATTRIT.general>>
}

#-----------------------------------------------------------------------

order ATTRIT:NBHOOD "Magic Attrit Neighborhood" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  The name of an existing neighborhood.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    Attrits all civilian units in the neighborhood by the specified number
    of casualties.  Units are attrited proportionally to their size,
    i.e., a unit twice as big as another will take twice the
    casualties.<p>

    <<ATTRIT.general>>
}

#-----------------------------------------------------------------------

order ATTRIT:UNIT "Magic Attrit Unit" {
    <<parmlist>>

    <<parm u "Unit">>
    <b>Required.</b>  The name of an existing unit.
    <</parm>>

    <<parm casualties "Casualties">>
    <b>Required.</b>  The number of personnel to be attrited, a
    positive integer.
    <</parm>>

    <<ATTRIT.responsible>>

    <</parmlist>>

    This order magically inflicts casualties upon a selected unit.  The
    casualties are presumed to be dead, and are deducted from the
    unit's personnel.<p>

    <<ATTRIT.general>>
}

#=======================================================================
# Belief System Orders

macro TOPIC.tid {} {
    |<--
    The ID of an existing topic.
}

macro TOPIC.title {} {
    |<--
    A human readable title that defines the topic.
}

macro TOPIC.relevance {} {
    |<--
    A boolean flag that indicates whether the topic is relevant or
    not.  Irrelevant topics are omitted from the affinity
    computations.<p>
}

page /order bsystem "Belief System Orders" {
    <<title>>

    Every <<term civgroup>> and every <<term actor>> has a 
    <<term bsystem>>: a set of <<term position>>s on 
    various <<term topic>>s. Athena computes the <<term affinity>>
    between between pairs and groups and between groups and actors,
    based on their agreements and disagreements with respect to their
    belief systems. These orders are used to create and update belief
    systems.<p>

    <<childlinks>>
}


#-----------------------------------------------------------------------

page /order/bsystem topic "Topic Orders" {
    <<title>>

    Each <<term bsystem>> consists of a 
    <<term group>> or <<term actor>>'s set of 
    <<term position>>s on each of a set of <<term topic>>s.  These
    orders are used to create, update, and delete topics.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order BSYSTEM:TOPIC:CREATE "Create Belief System Topic" {
    <<parmlist>>
    <<parm tid "Topic ID">>
    <b>Required.</b>  <<parm.identifier topic T1>>
    <</parm>>

    <<parm title "Title">>
    <b>Required.</b> <<TOPIC.title>>
    <</parm>>

    <<parm relevance "Relevant?">>
    <b>Required.</b> <<TOPIC.relevance>>
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order creates a
    new <<term topic>>.
}


#-----------------------------------------------------------------------

order BSYSTEM:TOPIC:DELETE "Delete Belief System Topic" {
    <<parmlist>>

    <<parm tid "Topic ID">>
    <b>Required.</b>  <<TOPIC.tid>>
    <</parm>>
    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  Deletes an existing
    belief system <<term topic>>, along with all beliefs
    that depend upon it.<p>
}

#-----------------------------------------------------------------------

order BSYSTEM:TOPIC:UPDATE "Update Belief System Topic" {
    <<parmlist>>
    <<parm tid "Select Topic">>
    <b>Required.</b>  <<TOPIC.tid>>
    <</parm>>

    <<parm title "Title">>
    <b>Optional.</b> <<TOPIC.title>>
    <</parm>>

    <<parm relevance "Relevant?">>
    <b>Optional.</b> <<TOPIC.relevance>>
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order modifies the
    definition of an existing <<term topic>>.<p>
}

#-----------------------------------------------------------------------

page /order/bsystem belief "Belief Orders" {
    <<title>>

    Each <<term bsystem>> consists of a 
    set of beliefs, each consisting of a 
    <<term position>> and an <<term emphasis>> on agreement or
    disagreement with respect that position.
    Every <<term civgroup>> and <<term actor>> automatically has
    a belief about every defined <<term topic>>.  The following
    order is used to edit beliefs.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order BSYSTEM:BELIEF:UPDATE "Update Belief" {
    <<parmlist>>
    <<parm id "Select Belief">>
    <b>Required.</b>  A belief ID, which is an {<i>eid tid</i>} pair.
    The <i>eid</i> is an entity ID: a <<term civgroup>> or 
    <<term actor>> name.  The <i>tid</i> is a <<term topic>> ID.
    <</parm>>

    <<parm position "Position">>
    <b>Optional.</b> The entity's <<term position>> on the topic, a
    number from -1.0 to 1.0.  The symbolic constants defined in the
    following table may also be used:<p>

    <<::simlib::qposition html>>
    <</parm>>

    <<parm emphasis "Emphasis is On">>
    <b>Optional.</b> The entity's <<term emphasis>> on agreement or 
    disagreement for the topic, a number from 0.0 to 1.0.  The 
    symbolic constants defined in the following table should generally
    be used.<p>

    <<::simlib::qemphasis html>>
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order modifies the
    an existing belief in a <<term bsystem>>.<p>
}

#=======================================================================
# Condition Orders

include order_condition.help

#=======================================================================
# Cooperation Orders

page /order coop "Cooperation Orders" {
    <<title>>

    Athena models the cooperation of neighborhood
    civilian groups with force groups, where cooperation is defined as
    in the TRAC HUMINT methodology: the likelihood that a member of
    the civilian group will give intelligence to a member of the force
    group.  This family of orders are used to manipulate the
    initial cooperation levels between various groups.  (Use the
    <<cref /order/mad/coop>> to adjust or otherwise influence the 
    current levels.)<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order COOP:UPDATE "Update Initial Cooperation" {
    <<parmlist>>
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm coop0 "Cooperation">>
    <b>Optional.</b>  The initial cooperation level of group <i>f</i>
    with group <i>g</i>.  Cooperation levels
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal cooperation points per day.  The
    ascending trend is applied whenever the current cooperation level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal cooperation points per day.  The
    descending trend is applied whenever the current cooperation level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order updates the initial
    cooperation level of one group with another; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    current levels.)
}

#-----------------------------------------------------------------------

order COOP:UPDATE+MULTI "Update Initial Cooperation (Multi)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids cooperation>><p>

    Programmatically, each ID is a list {<i>f g</i>} where
    <i>f</i> and <i>g</i> are defined as for the 
    <<cref /order/coop/update>> order.
    <</parm>>

    <<parm coop0 "Cooperation">>
    <b>Required.</b>  The initial cooperation level for the selected
    curves.  Cooperation levels
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal cooperation points per day.  The
    ascending trend is applied whenever the current cooperation level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal cooperation points per day.  The
    descending trend is applied whenever the current cooperation level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from 0.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qcooperation html>>
    <</parm>>
    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order updates the initial
    cooperation level for two or more cooperation curves, as selected 
    in the GUI.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    current levels.)
}

#=======================================================================
# Econ Model Orders

page /order econ "Economic Model Orders" {
    <<title>>

    This section describes the orders used to configure Athena's
    Economic Model.
}

macro ECON.pcf {} {
    |<--
    The production capacity factor (PCF) for the neighborhood, a
    non-negative real number.  This is a 
    multiplier used to dial up and down the production capacity for
    goods in a neighborhood. A factor of 1.0 usually indicates the
    production capacity at the beginning of the scenario; a factor
    less than 1.0 indicates that production capacity (e.g., factories)
    have been damaged, and a factor greater than 1.0 indicates that
    new production capacity has been built.<p>

    It is possible to being the scenario with a PCF less than 1.0,
    indicating that the neighborhood's capacity has already been
    seriously damaged as the scenario begins.
}


order ECON:UPDATE "Update Neighborhood Economic Inputs" {
    <<parmlist>>

    <<parm n "Neighborhood">>
    <b>Required.</b>  <<NBHOOD.n>>
    <</parm>>

    <<parm pcf "Proc. Capacity Factor">>
    <b>Optional.</b>  <<ECON.pcf>>
    <</parm>>
    <</parmlist>>

    Updates the economic inputs for a single neighborhood.
}

#-----------------------------------------------------------------------

order ECON:UPDATE+MULTI "Update Economic Inputs for Multiple Neighborhoods" {
    <<parmlist>>

    <<parm ids "Neighborhoods">>
    <b>Required.</b>  <<parm.ids neighborhood>>
    <</parm>>

    <<parm pcf "Proc. Capacity Factor">>
    <b>Optional.</b>  <<ECON.pcf>>
    <</parm>>
    <</parmlist>>

    Updates the economic inputs for multiple neighborhoods.
}






#=======================================================================
# Environmental Situation Orders

page /order ensit "Environmental Situation Orders" {
    <<title>>

    Athena models a variety of on-going conditions within
    neighborhoods; these are collectively referred to as
    <i>environmental situations</i>.  The set of situation types
    includes epidemics, contaminated food and water, power and
    communication outages, and so forth.  Detailed information about
    each situation type may be found in the Athena Rules document.<p>

    This family of orders is used to create, update, and resolve
    environmental situations.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

macro ENSIT.initial {} {
    |<--
    The numeric ID of an environmental situation that has not yet
    become active.  Ensits become active at the first time advance
    after their creation.
}

macro ENSIT.location {} {
    |<--
    The location of the situation, expressed as a 
    [term mapref].  The situation affects the
    neighborhood that contains this location, and so the location must
    lie within some neighborhood.
}

macro ENSIT.stype {} {
    |<--
    The type of situation.  There may be only one
    environmental situation of a given type in each neighborhood.<p>

    [enumdoc ::projectlib::eensit]
}

macro ENSIT.coverage {} {
    |<--
    Neighborhood coverage fraction, as a positive real number
    less than or equal to 1.0.  The coverage represents the fraction
    of the neighborhood's population that is affected by this situation.
}

macro ENSIT.inception {} {
    |<--
    A flag (<b>YES</b>, <b>NO</b>) that determines
    whether the situation has inception effects.  Set this to
    <b>NO</b> for situations that are to be on-going at time 0. 
}

macro ENSIT.g {} {
    |<--
    The name of the group that the neighborhood
    population considers responsible for causing this situation,
    or <b>NONE</b> if none.
}

macro ENSIT.rduration {} {
    |<--
    A duration, in integer days.  If positive, the
    situation will automatically be resolved at the end of the
    specified time. If 0, no auto-resolution will take place.<p>

    If this value is omitted, it will default to the value of the
    <b>ensit.<i>stype</i>.duration</b> [cref /parmdb parameter].
}

#-----------------------------------------------------------------------

order ENSIT:CREATE "Create Environmental Situation" {
    <<parmlist>>
    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>
    <</parm>>

    <<parm stype "Type">>
    <b>Required.</b> <<ENSIT.stype>>
    <</parm>>

    <<parm coverage "Coverage">>
    <b>Required.</b> <<ENSIT.coverage>>
    <</parm>>

    <<parm inception "Inception?">>
    <b>Required.</b> <<ENSIT.inception>>
    <</parm>>

    <<parm g "Caused By">>
    <b>Required.</b>  <<ENSIT.g>>
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Required.</b>  The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  This entry is used when the situation
    resolves itself automatically; it can be overridden if the
    situation is resolved manually.
    <</parm>>

    <<parm rduration "Duration">>
    <b>Optional.</b>  <<ENSIT.rduration>>
    <</parm>>

    <</parmlist>>

    This order creates a new environmental situation.  Note that the
    <<cref /order/ensit/update>> order can be used to
    edit any of these values so long as the situation has not yet
    become active, i.e., up until the next time advance.<p>
}

#-----------------------------------------------------------------------

order ENSIT:DELETE "Delete Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  <<ENSIT.initial>>
    <</parm>>
    <</parmlist>>

    Deletes an existing environmental situation.
}

#-----------------------------------------------------------------------

order ENSIT:UPDATE "Update Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  <<ENSIT.initial>>
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>
    <</parm>>

    <<parm stype "Type">>
    <b>Required.</b> <<ENSIT.stype>>
    <</parm>>

    <<parm coverage "Coverage">>
    <b>Required.</b> <<ENSIT.coverage>>
    <</parm>>

    <<parm inception "Inception?">>
    <b>Required.</b> <<ENSIT.inception>>
    <</parm>>

    <<parm g "Caused By">>
    <b>Required.</b>  <<ENSIT.g>>
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Required.</b>  The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  This entry is used when the situation
    resolves itself automatically; it can be overridden if the
    situation is resolved manually.
    <</parm>>

    <<parm rduration "Duration">>
    <b>Optional.</b>  <<ENSIT.rduration>>
    <</parm>>

    <</parmlist>>

    Updates an existing environmental situation that has not yet
    become active.
}


#-----------------------------------------------------------------------

order ENSIT:MOVE "Move Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  The numeric ID of any existing environmental
    situation.
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  <<ENSIT.location>>  <b>Note:</b> If the ensit
    has already become active, it cannot be moved out of its
    neighborhood.
    <</parm>>

    <</parmlist>>

    Moves an existing environmental situation from one place to another.
}


order ENSIT:RESOLVE "Resolve Environmental Situation" {
    <<parmlist>>

    <<parm s "Situation">>
    <b>Required.</b>  The numeric ID of any unresolved environmental
    situation.
    <</parm>>

    <<parm resolver "Resolved By">>
    <b>Optional.</b> The name of the group that the neighborhood
    population will consider responsible for resolving this situation,
    or <b>NONE</b> if none.  If specified, overrides the group name
    given when the situation was 
    <<cref /order/ensit/create created>>.
    <</parm>>

    <</parmlist>>

    Resolves an unresolved environmental situation.  Any on-going
    effects will be terminated, and the neighborhood population will
    usually respond favorably.
}

#=======================================================================
# Goal Orders

page /order goal "Goal Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term goal>>s.

    <<childlinks>>
} 

order GOAL:CREATE "Create Goal" {
    This order creates a new <<term goal>>.
    The order parameters are as follows:<p>

    <<goal_ parmlist -required -tags create>>
}

order GOAL:DELETE "Delete Goal" {
    Deletes an existing <<term goal>>, along with all entities 
    (e.g., conditions) that depend upon it.    
    The order parameters are as follows:<p>

    <<parmlist>>

    <<parm goal_id "Goal ID">>
    <b>Required.</b>  The ID of an existing goal.
    <</parm>>
    
    <</parmlist>>

    Deletes the goal.
}

order GOAL:UPDATE "Update Goal" {
    This order modifies the
    definition of an existing <<term goal>>.  
    The order parameters are as follows:<p>

    <<parmlist>>
    <<goal_ parm goal_id -required>>

    <<parm owner "Owner">>
    <b>Display Only.</b> The name of the actor whose goal this is.
    <</parm>>

    <<goal_ parm narrative -required>>

    <</parmlist>>
}

order GOAL:STATE "Set Goal State" {
    Sets the <<term goal>>'s state.  Note that this order is for 
    internal use by the application; there is no associated order 
    dialog.  The order parameters are as follows:<p>


    <<parmlist>>
    <<goal_ parms -required -tags state>>
    <</parmlist>>
}


#=======================================================================
# Group Orders

macro GROUP.g {flavor} {
    |<--
    The ID of an existing $flavor group.
}

macro GROUP.color {} {
    |<--
    The group's color, used when displaying the group's units
    on the map viewer.  In general, group colors will be selected
    using the color selection dialog; if a color is entered as a
    string, it must be specified as a hex color string, of
    one of the following forms<p>

    #<i>rrggbb</i><br>
    #<i>rrrgggbbb</i><br>
    #<i>rrrrggggbbbb</i><p>

    where <i>r</i>, <i>g</i> and <i>b</i> are hexadecimal digits 
    expressing a shade of red, green, or blue.  Thus, "#000000" is
    black, and "#FFFFFF" is white.<p>
}

macro GROUP.shape {} {
    |<--
    According to MIL-STD-2525a, friendly, neutral, and enemy units
    are drawn differently by the map viewer.  This parameter
    determines whether the group's units are drawn as friendly,
    neutral, or enemy.  The possible values are as follows:<p>

    [enumdoc ::projectlib::eunitshape]
}

macro GROUP.demeanor {} {
    |<--
    The demeanor of the group, i.e., its propensity for
    violence. The possible values are as follows:<p>

    [enumdoc ::projectlib::edemeanor]
}

macro GROUP.a {} {
    |<--
    The group's owning actor.  This parameter may remain unset during
    [cref /using/prep], but must be specified before time can be
    advanced.
}

macro GROUP.cost {} {
    |<--
    The cost to the owning actor of 
    maintaining one member of the group in the playbox for one week,
    in dollars.
    Costs incurred outside the playbox should be excluded, e.g., 
    wages for U.S. troops.  The cost is expressed as a decimal number
    with an optional "K", "M", or "B" suffix, "1K" is 1,000 dollars.
}




#=======================================================================
# Civilian Group Orders

page /order civgroup "Civilian Group Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term civgroup>>s.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order CIVGROUP:CREATE "Create Civilian Group" {
    <b><<cref /using/prep>> Only.</b>  This order creates a
    new <<term civgroup>>.  The order parameters
    are as follows:<p>
    
    <<parmlist>>
    <<group_civ parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order CIVGROUP:DELETE "Delete Civilian Group" {
    <b><<cref /using/prep>> Only.</b>  Deletes an existing
    civilian group, along with all entities (e.g., attitudes)
    that depend upon it.<p>

    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>
    <</parmlist>>

}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE "Update Civilian Group" {
    <b><<cref /using/prep>> Only.</b>  This order updates an
    existing <<term civgroup>>.  The order parameters
    are as follows:<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g civilian>>
    <</parm>>

    <<group_civ parms -optional -tags update>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+MULTI "Update Multiple Civilian Groups" {
    <b><<cref /using/prep>> Only.</b>  This order modifies two or 
    more <<term civgroup>>s, as selected in the GUI.<p>

    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "civilian group">>
    <</parm>>

    <<group_civ parms -optional -tags multi>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+POSTPREP "Update Civilian Group (Post-PREP)" {
    This order updates an existing <<term civgroup>>
    after leaving <<cref /using/prep>>.  Only a subset of the
    group attributes can be edited.<p>

    This order can be sent by an 
    <<cref /object/tactic/executive>> script using the 
    <<cref /command/send>> executive command.<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b> <<GROUP.g civilian>>
    <</parm>>

    <<group_civ parms -required -tags postprep>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order CIVGROUP:UPDATE+POSTPREP+MULTI "Update Multiple Civilian Groups (Post-PREP)" {
    This order updates two or more existing <<term civgroup>>s,
    as selected in the GUI, 
    after leaving <<cref /using/prep>>.  Only a subset of the
    group attributes can be edited.<p>

    <<parmlist>>

    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "civilian group">>
    <</parm>>

    <<group_civ parms -required -tags postprep>>
    <</parmlist>>
}


#=======================================================================
# Force Group Orders

page /order frcgroup "Force Group Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term frcgroup>>s.

    <<childlinks>>
}


#-----------------------------------------------------------------------

order FRCGROUP:CREATE "Create Force Group" {
    <b><<cref /using/prep>> Only.</b>  This order creates a new 
    <<term frcgroup>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<group_frc parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order FRCGROUP:DELETE "Delete Force Group" {
    <b><<cref /using/prep>> Only.</b>  Deletes an existing
    <<term frcgroup>>, along with all entities
    that depend upon it.  The order parameters are as follows:<p>

    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order FRCGROUP:UPDATE "Update Force Group" {
    <b><<cref /using/prep>> Only.</b>  This order modifies the
    definition of an existing <<term frcgroup>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g force>>
    <</parm>>

    <<group_frc parms -optional -tags update>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order FRCGROUP:UPDATE+MULTI "Update Multiple Force Groups" {
    <b><<cref /using/prep>> Only.</b>  This order modifies the
    definition of two or more existing <<term frcgroup>>s, as
    selected in the GUI.  The order parameters are as follows:<p>

    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "force group">>
    <</parm>>

    <<group_frc parms -optional -tags multi>>
    <</parmlist>>
}


#=======================================================================
# Organization Group Orders

page /order orggroup "Organization Group Orders" {
    <<title>>

    These orders are used create, update, and delete 
    <<term orggroup>>s.

    <<childlinks>>
}

#-----------------------------------------------------------------------

order ORGGROUP:CREATE "Create Organization Group" {
    <b><<cref /using/prep>> Only.</b>  This order creates a new 
    <<term orggroup>>.
    The order parameters are as follows:<p>

    <<parmlist>>
    <<group_org parms -required -tags create>>
    <</parmlist>>
}


#-----------------------------------------------------------------------

order ORGGROUP:DELETE "Delete Organization Group" {
    <b><<cref /using/prep>> Only.</b>  Deletes an existing
    <<term orggroup>>, along with all entities
    that depend upon it.<p>

    <<parmlist>>
    <<parm g "Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order ORGGROUP:UPDATE "Update Organization Group" {
    <b><<cref /using/prep>> Only.</b>  This order modifies the
    definition of an existing <<term orggroup>>.  The order
    parameters are as follows:<p>

    <<parmlist>>
    <<parm g "Select Group">>
    <b>Required.</b>  <<GROUP.g organization>>
    <</parm>>

    <<group_org parms -optional -tags update>>
    <</parmlist>>
}

#-----------------------------------------------------------------------

order ORGGROUP:UPDATE+MULTI "Update Multiple Organization Groups" {
    <b><<cref /using/prep>> Only.</b>  This order modifies the
    definition of two or more existing <<term orggroup>>s, as
    selected in the GUI.  The order parameters are as follows:<p>

    <<parmlist>>
    <<parm ids "Groups">>
    <b>Required.</b>  <<parm.ids "organization group">>
    <</parm>>

    <<group_org parms -optional -tags multi>>
    <</parmlist>>
}

#=======================================================================
# Magic Attitude Driver Orders

page /order mad "Magic Attitude Driver Orders" {
    <<title>>

    Athena models a number of events and situations that drive
    attitude change, e.g., civilian attrition and environmental
    situations.  The set of drivers is not all encompassing, and so
    Athena allows the analyst to create <i>Magic Attitude Drivers</i>
    (MADs).  Once a MAD is created, the analyst may associate with it a
    variety of attitude adjustments and inputs; and the effects of
    these inputs will be associated with the MAD when viewing the history.<p>

    The following orders are used to create and manipulate MADs:<p>

    <<childlinks>>
}

macro MAD.mad {} {
    |<--
    The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
}

macro MAD.limit {} {
    |<--
    The magnitude of the level input in points, expressed as a real
    number, or as one of the symbols from the following table:<p>

    [::simlib::qmag html]
}

macro MAD.slope {} {
    |<--
    The slope of the input in points per day, expressed as a real
    number, or as one of the symbols from the following table:<p>

    [::simlib::qmag html]
}

macro MAD.days {} {
    |<--
    The realization time for the level input, in
    decimal days, expressed as a real number.  The input will take
    effect over this number of days.
}

macro MAD.athresh {} {
    |<--
    The ascending threshold for this input, in points.  The input
    will have no affect on curves whose value is greater than this
    amount.
}

macro MAD.dthresh {} {
    |<--
    The descending threshold for this input, in points.  The input
    will have no affect on curves whose value is less than this
    amount.
}

macro MAD.cause {} {
    |<--
    The [term cause] for any magic attitude input associated with
    this MAD.  The cause
    may be <b>UNIQUE</b>, indicating that the effects of this MAD
    are independent of all other drivers, or it may be
    any cause from the following list:<p>

    [enumdoc ::projectlib::ecause]
}

macro MAD.s {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in the same
    neighborhood as the input are multiplied by this factor.  
    If it is 0.0, there will be no such indirect effects.
}

macro MAD.p {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in <b>NEAR</b>
    neighborhoods are multiplied by this factor.  If it is 0.0, there
    will be no such indirect effects.
}

macro MAD.q {} {
    |<--
    Indirect effects of magic attitude inputs for this MAD in <b>FAR</b>
    neighborhoods are multiplied by 
    this factor.  If it is 0.0, there will be no such indirect effects.
}



#-----------------------------------------------------------------------

order MAD:CREATE "Create Magic Attitude Driver" {
    <<parmlist>>

    <<parm oneliner "Description">>
    <b>Required.</b>  A one-line description of the driver.
    <</parm>>

    <<parm cause "Cause">>
    <b>Required.</b> <<MAD.cause>>
    <</parm>>

    <<parm s "Here Factor">>
    <b>Required.</b> <<MAD.s>>
    <</parm>>

    <<parm p "Near Factor">>
    <b>Required.</b> <<MAD.p>>
    <</parm>>

    <<parm q "Far Factor">>
    <b>Required.</b> <<MAD.q>>
    <</parm>>
    
    <</parmlist>>

    Creates a new Magic Attitude Driver (MAD).  The description need
    not be unique, but should remind the analyst of the reason for the
    attitude inputs and adjustments associated with the MAD.<p>

    All magic level and slope inputs associated with this MAD will use
    the specified cause, near factor, and far factor.<p>

    <b>Note:</b> Once any attitude inputs or adjustments have been
    associated with this MAD, it can no longer be deleted; nor can its
    cause, near factor or far factor be changed.
}

#-------------------------------------------------------------------

order MAD:DELETE "Delete Magic Attitude Driver" {
    <<parmlist>>

    <<parm id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to delete.
    <</parm>>
    <</parmlist>>

    Deletes the specified MAD.  Note that a MAD cannot be deleted once
    any attitude inputs or adjustments have been associated with it.
}

#-------------------------------------------------------------------

order MAD:UPDATE "Update Magic Attitude Driver" {
    <<parmlist>>

    <<parm id "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to update.
    <</parm>>

    <<parm oneliner "Description">>
    <b>Optional.</b>  A one-line description of the driver.
    <</parm>>

    <<parm cause "Cause">>
    <b>Optional.</b> <<MAD.cause>>
    <</parm>>

    <<parm s "Here Factor">>
    <b>Optional.</b> <<MAD.s>>
    <</parm>>

    <<parm p "Near Factor">>
    <b>Optional.</b> <<MAD.p>>
    <</parm>>

    <<parm q "Far Factor">>
    <b>Optional.</b> <<MAD.q>>
    <</parm>>
    
    <</parmlist>>

    Updates the MAD's definition.  Note that only the description can
    be changed once magic inputs have been entered for this MAD.
}

#-------------------------------------------------------------------

order MAD:TERMINATE "Terminate Magic Slope Inputs" {
    <<parmlist>>

    <<parm id "MAD ID">>
    <b>Required.</b>  The ID of a Magic Attitude Driver (MAD).
    <</parm>>
    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    This order terminates all currently on-going slope inputs created
    for this MAD using <<cref /order/mad/sat/slope>> or 
    <<cref /order/mad/coop/slope>>.  (Delayed indirect effects
    are terminated after a suitable delay.)
}

#=======================================================================
# Magic Satisfaction Orders

page /order/mad sat "Magic Satisfaction Orders" {
    <<title>>

    These orders are used to set, adjust, and otherwise influence 
    satisfaction levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:SAT:ADJUST "Magic Adjust Satisfaction Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where <i>g</i> is a
    civilian group and <i>c</i> is a concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qmag html>>
    <</parm>>
    <</parmlist>>

    Immediately adjusts the value of the specified satisfaction curve by the
    specified amount, clamping the curve's value to the range -100.0,
    100.0 if need be.
}

#-----------------------------------------------------------------------

order MAD:SAT:SET "Magic Set Satisfaction Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where<i>g</i> is a
    civilian group residing and <i>c</i> is a concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm sat "sat">>
    <b>Required.</b>  The new value, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <</parmlist>>

    Immediately sets the value of the specified satisfaction curve to the
    specified amount.
}

#-----------------------------------------------------------------------

order MAD:SAT:LEVEL "Magic Satisfaction Level Input" {
    <<parmlist>>
    
    <<parm g "Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  A concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm limit "Limit">>
    <b>Required.</b>  <<MAD.limit>>
    <</parm>>

    <<parm days "Realization Time">>
    <b>Required.</b>  <<MAD.days>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic satisfaction level input into GRAM.  The input will
    change the specified curve's value by <i>limit</i> nominal points
    over a period of <i>days</i>.
}


#-----------------------------------------------------------------------

order MAD:SAT:SLOPE "Magic Satisfaction Slope Input" {
    <<parmlist>>
    
    <<parm g "Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  A concern.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm slope "Slope">>
    <b>Required.</b>  <<MAD.slope>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic satisfaction slope input into GRAM.  The input will
    change the specified curve's value by <i>slope</i> nominal points
    per day until the input is terminated.  The input will be
    attributed to the specified MAD.<p>

    A subsequent order for the same curve and MAD will change
    the slope of the existing slope input, rather than creating a new
    slope input.<p>

    The input can be terminated in two ways.  First, the specific
    input can be terminated by sending an identical order with a slope
    of 0.0.  Second, the <<cref /order/mad/terminate>> order will terminate
    all ongoing slope effects for a particular MAD.
}

#=======================================================================
# Magic Cooperation Orders

page /order/mad coop "Magic Cooperation Orders" {
    <<title>>

    These orders are used to set, adjust, and otherwise influence 
    cooperation levels.  All such changes are attributes to
    some Magic Attitude Driver (MAD).<p>

    The following orders are available:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAD:COOP:ADJUST "Magic Adjust Cooperation Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm delta "Delta">>
    <b>Required.</b>  The magnitude of the change, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qmag html>>
    <</parmlist>>

    Adjusts the value of the specified cooperation curve by the
    specified amount, clamping the curve's value to the range 0.0,
    100.0 if need be.
}

#-----------------------------------------------------------------------

order MAD:COOP:SET "Magic Set Cooperation Level" {
    <<parmlist>>
    
    <<parm id "Curve">>
    <b>Required.</b>  A cooperation curve ID, which is a list 
    {<i>f g</i>} where <i>f</i> is a
    civilian group and <i>g</i> is a force group.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  The ID of the Magic Attitude Driver (MAD) to which
    the change will be attributed.
    <</parm>>

    <<parm coop "coop">>
    <b>Required.</b>  The new value, expressed as a real
    number, or as one of the symbols from the following table:<p>

    <<::simlib::qcooperation html>>
    <</parmlist>>

    Sets the value of the specified cooperation curve to the
    specified amount.
}

#-----------------------------------------------------------------------

order MAD:COOP:LEVEL "Magic Cooperation Level Input" {
    <<parmlist>>
    
    <<parm f "Of Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  A force group ID.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm limit "Limit">>
    <b>Required.</b>  <<MAD.limit>>
    <</parm>>

    <<parm days "Realization Time">>
    <b>Required.</b>  <<MAD.days>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic cooperation level input into GRAM.  The input will
    change the specified curve's value by <i>limit</i> nominal points
    over a period of <i>days</i>.  The input will be attributed to the
    specified MAD.
}


#-----------------------------------------------------------------------

order MAD:COOP:SLOPE "Magic Cooperation Slope Input" {
    <<parmlist>>
    
    <<parm f "Of Group">>
    <b>Required.</b>  A civilian group ID.
    <</parm>>

    <<parm g "With Group">>
    <b>Required.</b>  A force group ID.
    <</parm>>

    <<parm mad "MAD ID">>
    <b>Required.</b>  <<MAD.mad>>
    <</parm>>

    <<parm slope "Slope">>
    <b>Required.</b>  <<MAD.slope>>
    <</parm>>

    <<parm athresh "Ascending Threshold">>
    <b>Required.</b>  <<MAD.athresh>>
    <</parm>>

    <<parm dthresh "Descending Threshold">>
    <b>Required.</b>  <<MAD.dthresh>>
    <</parm>>

    <</parmlist>>

    <b>This order must be scheduled in advance.</b>
    Enters a magic cooperation slope input into GRAM.  The input will
    change the specified curve's value by <i>slope</i> nominal points
    per day until the input is terminated.  The input will be
    attributed to the specified MAD.<p>

    A subsequent order for the same curve and MAD will change
    the slope of the existing slope input, rather than creating a new
    slope input.<p>

    The input can be terminated in two ways.  First, the specific
    input can be terminated by sending an identical order with a slope
    of 0.0.  Second, the <<cref /order/mad/terminate>> order will terminate
    all ongoing slope effects for a particular MAD.
}


#=======================================================================
# Map Orders

page /order map "Map Orders" {
    <<title>>

    Athena allows the user to specify a map background to aid in both
    the construction of the scenario and the analysis and
    visualization of the results.  (See <<cref /using/maps>> for more
    information.)  The following orders manipulate
    the image used as the map background:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order MAP:IMPORT "Import Map" {
    <<parmlist>>

    <<parm filename "Map File">>
    <b>Required.</b>  The name of a GIF, JPEG, or PNG image to be used
    as the map background.
    <</parm>>
    <</parmlist>>

    Imports an image into the scenario for use as the map background,
    replacing any previous map image.  The image data is saved within
    the scenario; it's not necessary to send the image file along with
    the saved .adb file.<p>

    This order is usually sent indirectly, using the
    <<menu "File/Import Map...">> menu item.  However, Athena should
    eventually support order script, and it it is documented here for
    that purpose.
}




#=======================================================================
# Neighborhood Orders

include order_nbhood.help

#=======================================================================
# Neighborhood Relationship Orders

page /order nbrel "Neighborhood Relationship Orders" {
    <<title>>

    The Athena playbox, or region of interest, is divided into 
    <<cref /order/nbhood neighborhoods>>.  Neighborhoods are related
    to each other in two ways: by proximity, and by the time it takes
    attitude effects to spread.  The neighborhood relationship orders
    are used to edit these relationships.<p>

    Neighborhood relationships are created automatically for every
    pair of neighborhoods, and are deleted as necessary when
    neighborhoods are deleted.<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order NBREL:UPDATE "Update Neighborhood Relationship" {
    <<parmlist>>
    <<parm id "Neighborhood">> 
    <b>Required.</b>  A neighborhood relationship ID, specified as
    a list {<i>m</i>, <i>n</i>} where <i>m</i> and <i>n</i> are
    neighborhoods and the data is <i>m</i>'s relationship with
    <i>n</i>.  Note that a neighborhood's relationship with itself
    is fixed, so <i>m</i> cannot equal <i>n</i>.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <<parm effects_delay "Effects Delay">> 
    <b>Optional.</b> Decimal days.  The attitude effects of events and
    situations in neighborhood <i>n</i> are felt in neighborhood
    <i>m</i> only after this number of days.<p>

    Every neighborhood has a delay of 0.0 days with itself; this
    cannot be changed.
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order modifies existing
    neighborhood relationships.<p>
}

#-------------------------------------------------------------------

order NBREL:UPDATE+MULTI "Update Multiple Neighborhood Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids "neighborhood relationship">><p>

     Programmatically, each ID is a list {<i>m n</i>} where <i>m</i>
    and <i>n</i> are defined as for the 
    <<cref /order/nbrel/update>> order.
    <</parm>>

    <<parm proximity "Proximity">>  
    <b>Optional.</b> The proximity between the two neighborhoods from
    <i>m</i>'s point of view:<p>

    <<enumdoc ::simlib::eproximity>><p>

    Every neighborhood has a proximity of <b>HERE</b> with itself;
    this cannot be changed.  Two distinct neighborhoods can have a
    proximity from <b>NEAR</b> to <b>REMOTE</b>.<p>

    The attitude effects of events and situations in neighborhood <i>n</i>
    diminish with distance, and vanish altogether in neighborhoods
    <i>m</i> that consider <i>n</i> to be <b>REMOTE</b>.
    <</parm>>

    <<parm effects_delay "Effects Delay">> 
    <b>Optional.</b> Decimal days.  The attitude effects of events and
    situations in neighborhood <i>n</i> are felt in neighborhood
    <i>m</i> only after this number of days.<p>

    Every neighborhood has a delay of 0.0 days with itself; this
    cannot be changed.
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order modifies two or more
    neighborhood relationships, as selected in the GUI.<p>
}

#=======================================================================
# Group Relationship Orders

page /order rel "Group Relationship Orders" {
    <<title>>

    Groups can be friends, enemies, or neutrals, as determined by
    their <i>relationship</i>, a number between -1.0 and 1.0.  
    Relationships are established during <<cref /using/prep>> and
    are constant thereafter.<p>

    Inter-group relationships are computed from the groups' belief
    systems (force and organization groups inherit their belief
    systems from their owning actors).  In addition, these orders can
    be used to manually override the computed relationships.<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order REL:OVERRIDE "Override Computed Relationship" {
    <<parmlist>>
    <<parm id "Groups">>
    <b>Required.</b>  A group relationship ID, specified as a 
    list {<i>f g</i>} where <i>f</i> and <i>g</i> are two groups.  The
    associated relationship is <i>f</i>'s relationship with <i>g</i>.
    Note that a group's relationship with itself is always 1.0 and
    cannot be overridden.
    <</parm>>

    <<parm rel "Relationship">>
    <b>Optional.</b>  The relationship between the two groups,
    a decimal number between -1.0 and 1.0.  Typical relationship
    values range from -0.5 to +0.8.
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order overrides the
    computed relationship of one group with another.
}

#-----------------------------------------------------------------------

order REL:RESTORE "Restore Computed Relationship" {
    <<parmlist>>
    <<parm id "Groups">>
    <b>Required.</b>  A group relationship ID, specified as a 
    list {<i>f g</i>} where <i>f</i> and <i>g</i> are two groups.  The
    associated relationship is <i>f</i>'s relationship with <i>g</i>.
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order restores the computed
    relationship, deleting any manual override.
}

#-----------------------------------------------------------------------

order REL:OVERRIDE+MULTI "Override Multiple Relationships" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids relationship>><p>

    Programmatically, each ID is a list {<i>f g</i>} where
    <i>f</i> and <i>g</i> are defined as for the 
    <<cref /order/rel/override>> order.
    <</parm>>

    <<parm rel "Relationship">>
    <b>Optional.</b>  The relationship between two groups,
    a decimal number between -1.0 and 1.0.  Typical relationship
    values range from -0.5 to +0.8.   
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order overrides two or more
    computed relationships, as selected in the GUI.
}

#=======================================================================
# Satisfaction Orders

page /order sat "Satisfaction Orders" {
    <<title>>

    Athena models the satisfaction of civilian groups with respect
    to a variety of
    concerns.  This family of orders are used to manipulate the
    initial satisfaction levels and related parameters.  (Use the
    <<cref /order/mad/sat>> to adjust or otherwise influence the 
    current levels.)<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order SAT:UPDATE "Update Initial Satisfaction" {
    <<parmlist>>
    <<parm id "Curve">>
    <b>Required.</b>  A satisfaction curve ID, which is a list 
    {<i>g c</i>} where <i>g</i> is a
    civilian group and <i>c</i> is a concern.
    <</parm>>

    <<parm sat0 "Sat at T0">>
    <b>Optional.</b>  The initial satisfaction level of group <i>g</i>
    with concern <i>c</i>.  Satisfaction levels
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm saliency "Saliency">>
    <b>Optional.</b>  The importance of concern <i>c</i> to the group.
    Saliencies range from 0.0 to 1.0, and are defined either
    numerically or using the following rating scale:<p>

    <<::simlib::qsaliency html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal satisfaction points per day.  The
    ascending trend is applied whenever the current satisfaction level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal satisfaction points per day.  The
    descending trend is applied whenever the current satisfaction level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>
    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order updates the initial
    satisfaction level of one group with a concern; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    current levels.)

}


#-----------------------------------------------------------------------

order SAT:UPDATE+MULTI "Update Initial Satisfaction (Multi)" {
    <<parmlist>>
    <<parm ids "IDs">>
    <b>Required.</b>  <<parm.ids satisfaction>><p>

    Programmatically, each ID is a list {<i>g c</i>} where
    <i>g</i> and <i>c</i> are defined as for the 
    <<cref /order/sat/update>> order.
    <</parm>>

    <<parm sat0 "Sat at T0">>
    <b>Optional.</b>  The initial satisfaction level of group <i>g</i>
    with concern <i>c</i>.  Satisfaction levels
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm saliency "Saliency">>
    <b>Optional.</b>  The importance of concern <i>c</i> to the group.
    Saliencies range from 0.0 to 1.0, and are defined either
    numerically or using the following rating scale:<p>

    <<::simlib::qsaliency html>>
    <</parm>>

    <<parm atrend "Ascending Trend">>
    <b>Optional.</b> The ascending trend for this curve, 
    a non-negative slope in nominal satisfaction points per day.  The
    ascending trend is applied whenever the current satisfaction level
    is less than <i>athresh</i>.  If this value is 0.0, there is no ascending
    trend for this curve.
    <</parm>>

    <<parm athresh "Asc. Threshold">>
    <b>Optional.</b> The ascending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>

    <<parm dtrend "Descending Trend">>
    <b>Optional.</b> The descending trend for this curve, 
    a non-positive slope in nominal satisfaction points per day.  The
    descending trend is applied whenever the current satisfaction level
    is greater than <i>dthresh</i>.  If this value is 0.0, there is no 
    descending trend for this curve.
    <</parm>>

    <<parm dthresh "Desc. Threshold">>
    <b>Optional.</b> The descending threshold for this curve.  Thresholds
    run from -100.0 to 100.0, and are defined either numerically or using
    the following rating scale:<p>

    <<::simlib::qsat html>>
    <</parm>>
    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  This order updates two or more initial
    satisfaction levels, as selected in the GUI; this can only be done
    during the Scenario Preparation phase.<p>

    (Use the <<cref /order/mad>> to adjust or otherwise influence the 
    current levels.)
}

#=======================================================================
# Simulation Control Orders

page /order sim "Simulation Control Orders" {
    <<title>>

    The orders in this set are used to control the simulation in
    general.  Most of them are used implicitly, by various GUI
    controls.  They are documented here for completeness.<p>

    The full set of orders is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order SIM:STARTDATE "Set Start Date" {
    <<parmlist>>
    <<parm startdate "Start Date">>
    <b>Required.</b>  A <<term zulu>> corresponding to 
    simulation time 0.  By convention, the hours and minutes 
    should be "0000".
    <</parm>>

    <</parmlist>>

    <b><<cref /using/prep>> Only.</b>  Athena generally reports
    simulation time as a number of integer days and as a zulu-time.
    This order determines how simulation time is translated to zulu-time.
}


order SIM:RUN "Run Simulation" {
    <<parmlist>>
    <<parm days "Days to Run">>
    <b>Optional.</b>  An integer number of days.  If 0, or not
    specified, the simulation will run until explicitly paused by the
    user.  If greater than 0, the simulation will run for the
    specified number of days, and then halt.
    <</parm>>

    <<parm block "Block?">>
    <b>Optional.</b>  A boolean flag.  If true, the order will
    block--that is, the simulation will run for the specified number
    of days and then the order handler will return.  If false (the
    default) the order handler returns immediately, and the simulation
    runs forward under the control of the Tcl event loop.<p>
    <</parm>>

    <</parmlist>>

    Advances simulation time.  This order is usually triggered by the
    "play" button in the GUI.<p>

    If the simulation is in the <<cref /using/prep>> state, the order
    does a sanity check on the scenario; time will not be allowed to
    advance if the scenario is incomplete.
}


order SIM:PAUSE "Pause Simulation" {
    Pauses the simulation at the next possible moment: immediately if
    the simulation is waiting in the Tcl event loop between 
    <<term tick>>s, and at the end of the current tick if it's in the 
    middle of a tick.<p>

    This order is usually triggered by the "pause" button in the GUI.
}


#=======================================================================
# Tactic Orders

include order_tactic.help

#=======================================================================
# Unit Orders

page /order unit "Unit Orders" {
    <<title>>

    A <<term unit>> is an object that represents some number of people in 
    a particular neighborhood, typically performing some activity.

    Units are modified using the following orders:<p>

    <<childlinks>>
}


order UNIT:MOVE "Move Unit" {
    <<parmlist>>
    <<parm u "Name">>
    <b>Required.</b>  The name of the unit to move.
    <</parm>>

    <<parm location "Location">>
    <b>Required.</b>  The unit's new location, expressed as
    a <<term mapref>>.
    <</parm>>
    <</parmlist>>

    Moves the unit to its new location, which must be within the same 
    neighborhood.
}



#=======================================================================
# Order Orders

page /order order "Order Scheduling Orders" {
    <<title>>

    Athena allows certain orders to be scheduled to execute at some
    later time.  These orders are used to schedule orders for
    execution, and to cancel the scheduled orders.<p>

    The user will usually use these orders indirectly, via the
    the "Schedule" button on the various order dialogs, and the "X" 
    button on the Orders browser;  Athena <<version>> provides no 
    other way for the user to access them.  They are documented here 
    for completeness' sake.<p>

    In the long-run, it is likely that Athena will be able to execute
    order scripts; at that time, the user will be able to enter these
    orders directly into the scripts.<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order ORDER:CANCEL "Cancel Scheduled Order" {
    <<parmlist>>

    <<parm id "Order ID">> 
    <b>Required.</b>  The ID of the scheduled order, as shown in 
    the Orders browser.
    <</parm>>

    <</parmlist>>

    This order cancels a scheduled order given its ID.
}

#-------------------------------------------------------------------

order ORDER:SCHEDULE "Schedule Order" {
    <<parmlist>>

    <<parm timespec "Time Spec">> 
    <b>Required.</b> The time at which the order should be scheduled
    to execute, expressed as a <<term timespec>>.  The time must be at
    least "NOW+1".
    <</parm>>

    <<parm name "Order Name">>
    <b>Required.</b> The name of the order, as shown on the second
    line of the order's help page.  For example, the name of this
    order (as opposed to its title) is <b>ORDER:SCHEDULE</b>.

    <<parm parmdict "Parm Dict">>
    A Tcl dictionary of parameter names and values, using the 
    parameter names shown in parentheses on the order's help page.
    The name of this parameter, for example, is <b>parmdict</b>.
    <</parm>>

    <</parmlist>>

    This order schedules the order to execute at the specified time.
    It does not ensure that the order will be accepted; a valid order
    might become invalid by the time it executes, and an invalid order
    might (in particular cases) become valid.
}

#=======================================================================
# Parm Orders

page /order parm "Model Parameter Orders" {
    <<title>>

    These orders are used to set the values of the 
    Athena <<cref /parmdb>>.<p>

    The user will usually use these orders indirectly, via the
    <<command parm>> <<cref /command "executive command">> and its
    subcommands; Athena <<version>> provides no other way for the user
    to access them.  They are documented here for completeness'
    sake.<p>

    In the long-run, it is likely that Athena will be able to execute
    order scripts; at that time, the user will be able to enter these
    orders directly into the scripts.<p>

    The orders are as follows:<p>

    <<childlinks>>
}

#-------------------------------------------------------------------

order PARM:IMPORT "Import Parameter File" {
    <<parmlist>>

    <<parm filename "Parameter File">> 
    <b>Required.</b>  Name of a parmdb(5) parameter file.
    <</parm>>

    <</parmlist>>

    This order imports <<cref /parmdb "model parameter">> settings from
    a disk file.  See <<command parm import>> for details.
}


#-------------------------------------------------------------------

order PARM:RESET "Reset Parameters to Defaults" {
    This order resets all <<cref /parmdb "model parameters">> to
    their default values.  See <<command parm reset>> for details.
}

#-------------------------------------------------------------------

order PARM:SET "Set Parameter Value" {
    <<parmlist>>

    <<parm parm "Parameter">> 
    <b>Required.</b>  Name of a parmdb(5) parameter.
    <</parm>>

    <<parm value "Value">> 
    <b>Required.</b>  New parameter value.
    <</parm>>

    <</parmlist>>

    This order sets the value of the named parameter.  See 
    <<command parm set>> for details. 
}

#=======================================================================
# Report Orders

page /order report "Report Orders" {
    <<title>>

    These orders are used to request specific reports.  The requested
    report will appear in the Detail Browser.  Most reports are 
    customized or filtered versions of standard Detail Browser pages.
    The complete set of requested reports is as follows:<p>

    <<childlinks>>
}

#-----------------------------------------------------------------------

order REPORT:DRIVER "Attitude Drivers Report" {
    This report lists the events and situations which have driven 
    changes in Athena's attitude model.<p>

    <<parmlist>>

    <<parm state "Driver State">>
    <b>Required.</b>  The report will include only those drivers with the
    given state.  The set of valid states is as follows:<p>

    <ul>
    <li> <b>all</b>: All drivers
    <li> <b>active</b>:  Active drivers: those that are currently causing 
         attitudes to change.
    <li> <b>inactive</b>: Inactive drivers: those that are no longer
         causing attitudes to change.
    <li> <b>empty</b>: Empty drivers: those that have never caused
         attitudes to change.
    </ul>
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

order REPORT:PARMDB "Model Parameters Report" {
    This report lists each of Athena's model parameters with its current
    and default values.<p>

    The report's output can be filtered in two ways.  First, if
    <b>CHANGED</b> is selected, the report will include only those
    parameters whose values differ from their installation defaults.  
    Second, the report will include only parameters whose names match
    the specified wildcard pattern.  (Wildcard-matching is case-insensitive.)
    For example, the wildcard "aam.UFvsNF.*" will limit the output to
    the parameters governing uniformed vs. non-uniformed attrition.<p>

    <<parmlist>>

    <<parm state "Parameter State">>
    <b>Required.</b>  The set of parameters to include in the report:<p>

    <ul>
    <li> <b>ALL</b>: All parameters
    <li> <b>CHANGED</b>:  All parameters that have been changed from their 
         default settings.
    </ul>
    <</parm>>

    <<parm wildcard "Wildcard">>
    <b>Optional.</b>  A wildcard pattern, e.g., the pattern "aam.*"
    matches all of the attrition model parameters.
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

order REPORT:SATCONTRIB "Contribution to Satisfaction Report" {
    For a given satisfaction curve or group mood, this report lists
    the top satisfaction drivers along with their total contributions
    to satisfaction change.  The user can select the time interval,
    and the maximum number of drivers to list.<p>

    <<parmlist>>

    <<parm g "Group">>
    <b>Required.</b>  The name of the civilian group.
    <</parm>>

    <<parm c "Concern">>
    <b>Required.</b>  The name of a concern, as chosen from the
    following list, or "MOOD" for the group's mood:<p>

    <<enumdoc ::projectlib::econcern>>
    <</parm>>

    <<parm top "Number">>
    <b>Optional.</b>  The maximum number of drivers to include in the
    list.  Defaults to 20.    
    <</parm>>

    <<parm start "Start Time">>
    <b>Optional.</b>  The start time of the interval of interest, 
    expressed as a <<term timespec>>.  Defaults to "T0", the start of
    simulation time.
    <</parm>>

    <<parm end "End Time">>
    <b>Optional.</b>  The end time of the interval of interest, 
    expressed as a <<term timespec>>.  Defaults to "NOW", the current
    simulation time.
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order sqdeploy "Status Quo Group Deployment Orders" {
    <<title>>

    In Athena, force and organization personnel must be deployed to
    neighborhoods.  During simulation, this is done via the
    <<cref /object/tactic/deploy>> during <<term strategy>> execution.
    However, strategy execution assumes the presence of a status quo:
    troop deployments, neighborhood security levels, and so forth;
    without this status quo, strategies will not execute as they
    ought.<p>

    Consequently, these orders are used to specify the "status quo"
    troop deployments for all force and organization groups.  These
    deployments form part of the context for the initial strategy
    execution that takes place when the scenario is locked and
    simulation begins.<p>

    <<childlinks>>
}

order SQDEPLOY:SET "Set Status Quo Group Deployment" {
    This order is used to set a force or organization group's initial
    "status quo" deployment of personnel into a particular
    neighborhood.  By default, no personnel are assigned to any
    neighborhood.<p>

    <<parmlist>>
    <<parm id "Nbhood/Group">>
    <b>Required.</b>  A list {<i>n g</i>} where <i>n</i> is the name
    of a neighborhood and <i>g</i> is the name of a a force or
    organization group.
    <</parm>>

    <<parm personnel "Personnel">>
    <b>Required.</b> The number of group <i>g's</i> personnel to
    deploy to neighborhood <i>n</i>.
    <</parm>>

    <</parmlist>>
}

order SQDEPLOY:DELETE "Delete Status Quo Group Deployment" {
    This order is used to delete an initial
    "status quo" deployment of force or organization group personnel 
    into a particular, that is, to set an existing deployment to
    zero.<p>

    <<parmlist>>
    <<parm id "Nbhood/Group">>
    <b>Required.</b>  A list {<i>n g</i>} where <i>n</i> is the name
    of a neighborhood and <i>g</i> is the name of a a force or
    organization group.
    <</parm>>

    <</parmlist>>
}

#-----------------------------------------------------------------------

page /order sqservice "Status Quo ENI Funding Orders" {
    <<title>>

    In Athena, <<term actor>>s provide Essential Non-Infrastructure
    (ENI) services to <<term civgroup>>s using the 
    <<cref /object/tactic/fundeni>> during <<term strategy>>
    execution.  However, strategies execute in the context of the
    status quo, and so the actor's tactics cannot establish the
    status quo at time 0, when the scenario is locked and simulation
    begins.<p>

    Consequently, these orders are used to specify the "status quo"
    level of funding for ENI services from each actor to each each
    civilian group.  This affects the initial vertical
    relationship between each civilian group and each actor, which in turn
    affects each actor's support and influence in each neighborhood.<p>

    <<childlinks>>
}

order SQSERVICE:SET "Set Status Quo ENI Funding" {
    This order is used to set an <<term actor>>'s status quo level 
    of funding for Essential Non-Infrastructure (ENI) services to a 
    <<term civgroup>>.  By default, no services are funded.<p>

    <<parmlist>>
    <<parm id "Group/Actor">>
    <b>Required.</b>  A list {<i>g a</i>} where <i>g</i> is the name
    of a civilian group and <i>a</i> is the name of an actor.
    <</parm>>

    <<parm funding "Funding, $/week">>
    <b>Required.</b> The amount of money being spent on ENI services
    by the actor for the group each week, in the status quo.
    <</parm>>

    <</parmlist>>
}

order SQSERVICE:RESET "Reset Status Quo ENI Funding" {
    This order is used to reset an <<term actor>>'s status quo level 
    of funding for Essential Non-Infrastructure (ENI) services to a 
    <<term civgroup>> back to zero.<p>

    <<parmlist>>
    <<parm id "Group/Actor">>
    <b>Required.</b>  A list {<i>g a</i>} where <i>g</i> is the name
    of a civilian group and <i>a</i> is the name of an actor.
    <</parm>>

    <</parmlist>>
}