<<manpage {projectgui(n) htmlframe(n)} "HTML-based layout widget">>

<<section SYNOPSIS>>

<pre>
package require projectgui 1.0
namespace import ::projectgui::*
</pre>

<<itemlist>>

<<section DESCRIPTION>>

The htmlframe(n) widget is an <<xref htmlviewer(n)>> widget configured 
for use as a layout manager.  The client creates any number of widgets
as children of the htmlframe(n), and then specifies the layout as an
HTML string.<p>

The child widgets appear in the HTML string as
<code>&lt;input&gt;</code> elements whose <code>name</code> attribute
is the last component of the child widget's name.  If the widgets are
created like this, for example,<p>

<pre>
    htmlframe $hf
    ttk::label $hf.hello -text "Hello, world!"
    ...
</pre>

then the "hello" widget is layed out like this:<p>

<pre>
    &lt;item name="hello"&gt;
</pre>

The size of the widget can be set explicitly in the usual way, when
the widget is created; alternatively, the widget's width in characters
can be set using the <code>&lt;input&gt;</code>'s <code>size</code>
attribute.<p>

The client may also wish to set the <code>id</code>,
<code>class</code>, and <code>style</code> attributes.<p>

<<subsection "Dynamic Layout">>

The layout can be changed at any time, simply by passing a new HTML
string to the <<iref layout>> method.  Display of particular elements
can be changed dynamically by using the <<iref set>> method to set the 
<code>class</code> or <code>style</code> of particular elements
identified by their <code>id</code> or <code>name</code> attribute
values.<p>

In this regard, it is often useful to define new CSS classes using the
<code>-style</code> option.  For example, suppose certain element
contains an error, and so should be rendered with red text; or suppose
that a certain element should sometimes be hidden.  These can easily
be handled, as follows.<p>

First, add the relevant CSS classes:<p>

<pre>
    $hf configure -style {
        .hidden { display: none; }
        .error  { color: red; }
    }
</pre>

Second, write an HTML layout that includes <code>id</code> attributes
for the elements you want to affect dynamically.<p>

<pre>
    &lt;span id="element1"&gt;
    I can say hello:
    &lt;item name="hello"&gt;
    &lt;/span&gt;
</pre>

Then, setting the class of the <code>element1</code> element will make
the text change color or the whole element disappear:<p>

<pre>
    $hf set element1 class hidden     ;# Hide it
    $hf set element1 class error      ;# Turn it red
    $hf set element1 class ""         ;# Set it back to normal
</pre>

<<section COMMANDS>>

This module defines the following commands.<p>

<<deflist commands>>

<<defitem htmlframe {htmlframe <i>pathName</i> ?<i>options...</i>?}>>

Creates a new <<iref htmlframe>> widget named <i>pathName</i>, and
returns <i>pathName</i>.  The widget supports all of the 
<<xref htmlviewer(n)>> options; however, the ones most likely to be
of interest are the following:<p>

<<deflist options>>

<<defopt {-hyperlinkcmd <i>command</i>}>>

Specifies a <i>command</i> to be called if the user clicks on a
hyperlink. The command will be called with one additional argument,
the link's URL.  It is up to the client to handle the link in some
way.<p>

<<defopt {-shrink <i>flag</i>}>>

The widget is configured with <code>-shrink</code> set to <b>yes</b>
by default; it will be just big enough to hold its contents.<p>

<<defopt {-styles <i>css</i>}>>

Specifies a CSS style sheet to add to the widget's default styles.
This style sheet overrides the built-in defaults, and can be
overridden by <code>&lt;style&gt;...&lt;/style&gt;</code> sheets and
<code>style</code> attributes in the input.<p>

<</deflist options>>

<</deflist commands>>

<<section "INSTANCE COMMAND">>

The htmlframe(n) widget has all of the subcommands of the 
<<xref htmlviewer(n)>> widget, and adds the following:<p>

<<deflist instance>>

<<defitem cget {<i>pathName</i> cget <i>option</i>}>>

Returns the value of the specified <i>option</i>.<p>

<<defitem configure {<i>pathName</i> configure <i>option value...</i>}>>

Sets the value of one or more of the object's
options.<p>

<<defitem layout {<i>pathName</i> layout <i>html</i>}>>

Lays out the children of the widget using the HTML layout.  Any 
<code>&lt;item&gt;</code>'s without matching child widgets are ignored.<p>

<<defitem set {<i>pathName</i> set <i>id attribute value</i>}>>

Sets the <i>value</i> of the named <i>attribute</i> for the HTML
element with the given <i>id</i>.  If there is no element with that
ID, the command looks for an element whose <code>name</code> matches
the <i>id</i>.  If neither is found, the command throws an error.<p>

This is convenience wrapper around <<xref htmlviewer(n)>>'s 
<code>search</code> and <code>attribute</code> subcommands.<p>

<<defitem get {<i>pathName</i> get <i>id attribute</i>}>>

Gets the <i>value</i> of the named <i>attribute</i> for the HTML
element with the given <i>id</i>.  If there is no element with that
ID, the command looks for an element whose <code>name</code> matches
the <i>id</i>.  If neither is found, the command throws an error.<p>

This is convenience wrapper around <<xref htmlviewer(n)>>'s 
<code>search</code> and <code>attribute</code> subcommands.<p>


<</deflist instance>>

<<section ENVIRONMENT>>

projectgui(n) requires Tcl 8.5 or later.

To use projectgui(n) in a Tcl script, the environment variable
<code>TCLLIBPATH</code> must include the parent of the package
directory.

<<section AUTHOR>>

Will Duquette<p>

<<section HISTORY>>

Original package.

<</manpage>>






