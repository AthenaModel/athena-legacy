<title><<project>> <<version>>: Architecture</title>
<style>
<<standardstyle>>
</style>
</head>

<<swallow {
    # Macro Definitions

    template o {object} {<b>[xref objects.$object ::$object]</b>}

    template event {name} {<b>&lt;$name&gt;</b>}
 
 }>>

<body>
<<banner>>

<h2>Architecture</h2>

<<hrule>>

<<contents>>

<<hrule>>

<<preface changelog "Change Log">>

<<changelog>>

<<change 11/11/2011 Created will>>
Initial Draft
<</change>>

<</changelog>>

<<hrule>>

<<section overview "Overview">>

Athena is a desktop application written in Tcl/Tk.  It allows the user
to create, edit, run, and query a scenario involving political decisions,
military actions, and civilian responses.  This document describes the
architecture of this application along a number of axes:<p>

<ul>
  <li> Data Management
  <li> Model/View/Controller
  <li> Package Architecture
  <li> Multi-Threading
  <li> Significant Objects
</ul>

<<section data "Data Management">>

Athena is a document-centric application.  Athena scenarios are stored
in scenario files, which have a ".adb" file type.  Scenario files are
SQLite database files; the schema is defined by the
<<xref projectlib(n)>> module <<xref scenariodb(n)>>.<p>

<<section data.checkpoint "Checkpoint/Restore">>

When the current scenario is saved, the scenario file should contain
the complete state of the Athena simulation, so that it can be loaded
again later.  Following JNEM and CBS practice, we call saving this
state <i>taking a checkpoint</i>, and reloading the state <i>doing a
restore</i>.<p>

Checkpoint/restore is difficult to design into an application after
the fact; Athena has been designed with checkpoint/restore in mind
from day one.<p>

Checkpoint/restore is managed by the application's <<o scenario>>
object.<p>

<<section data.rdb "Run-time Database (RDB)">>

Athena stores most of its working data in an SQLite database called
the <i>run-time database</i> (RDB), which has the same schema as
the Athena scenario file.  The RDB serves two purposes:<p>

<ul>
  <li> Tcl's support for structured data is somewhat weak; SQLite
       provides a useful and efficient way to both define and query large
       quantities of simulation data.<p>

  <li> Taking a checkpoint is largely a matter of copying the contents
       of the RDB.<p>
</ul><p>

The RDB is accessed as the <<o rdb>> object; the lifetime and contents
of the RDB are managed by the <<o scenario>> object.<p>

<<section data.rdb.appsql "Application SQL Extensions">>

The application user interface requires a variety of additional
application-specific SQL functions, e.g., for accessing the current
simulation time.  These functions cannot be used in the permanent
schema defined by <<xref scenariodb(n)>>--if we were to do so, the
resulting database could not be opened by any application that fails
to define them.  Instead, these SQL functions are defined for the RDB
by the <<o scenario>> object.<p>

In addition, the user interface makes use of a large number of
temporary SQL views.  These <i>GUI views</i> are defined by
<<o scenario>>.  Most are read from the <code>gui_views.sql</code>
file; some are defined on-the-fly.


<<section data.saveable "Saveable Objects">>

Many Athena objects also have significant in-memory state that must be
saved as part of a checkpoint.  These objects all support the Athena
<<xref saveable(i)>> interface, which includes
<b>checkpoint</b> and <b>restore</b> methods.  The
<b>checkpoint</b> method returns the object's state as a single
text string (often a Tcl dictionary); the <b>restore</b> method
restores the object's state given such a string.
See <<xref saveable(i)>> for a complete description of the protocol.<p>

All saveable objects register themselves with the application's
<<o scenario>> object, which is then responsible for checkpointing and
restoring them when appropriate.<p>

<<section func "Functional Architecture">>

Athena's functional architecture is shown in <<xref fig.archfunc>>.<p>

<<figure fig.archfunc "Functional Architecture" AthenaFunctionalArchitecture.png>>

Functionally, Athena is divided into two major areas, known as the <i>User
Interface</i> and the <i>Simulation</i>.  The Simulation is where the
models reside, and where all changes to the RDB are made.  In a
model/view/controller architecture, it corresponds to both the model
and the controller.  The User Interface is the view.  It presents the
model to the user, and allows the user to make changes.  Interactions
between the Simulation and the User Interface are tightly
constrained:<p>

<ul>
  <li> The User Interface controls which scenario is currently loaded,
       i.e., it is responsible for triggering File/New, File/Open,
       File/Save, and related operations.  The code which actually
       loads the scenario data is part of the Simulation.<p>
       
  <li> Once a scenario has been created or loaded, the User Interface
       can only change the scenario data by sending
       <i>orders</i> to the Simulation.  An order is a stylized
       procedure call; each order has a name and a number of carefully
       defined and validated parameters.  The order is the basic unit
       of action for the user-controlled undo/redo.<p>
       <ul>
         <li> Orders can be accepted or rejected.  A rejected order returns a
              dictionary of human readable error messages by parameter; the
              user interface can present this information to the user as it
              likes.<p>

         <li> The orders that can be accepted at any given time depend on the
              <<xref func.simstate "Simulation State">>.<p>
       </ul><p>
         
       
       See <<xref mars:order(n)>> for more information on order
       handling.<p>

  <li> The Simulation is largely unaware of the existence of the User
       Interface.  When an event occurs in the Simulation that the User
       Interface cares about whether in response to an order or to a
       scenario control request, the relevant simulation object sends a
       <<xref mars:notifier(n)>> event, e.g., after each time tick
       <<o sim>> object sends the <<event Tick>> event.  A single
       event may produce a number of distinct events.   User
       Interface objects bind to the events they care about.<p>

  <li> The User Interface may maintain significant state of its own
       regarding which data is displayed and how it is displayed,
       e.g., map zoom levels, plotted variables, and so forth.  Some
       of this data may be saved with the scenario; however, none of
       it is allowed to affect the simulation results in any way.<p>

  <li> The User Interface is allowed to query the Simulation freely,
       either by querying the RDB or by making direct calls to query
       subcommands defined by Simulation objects.<p>

       <b>This is the one weak point in this architecture.</b>
       Control is carefully constrained, but the User Interface
       remains tightly coupled with the simulation.<p>
</ul>

<<section func.ui "User Interface Specifics">>

TBD.  This section might discuss:<p>

<ul>
  <li> The role of the appwin(sim) module.
  <li> The nature of browsers.
  <li> Scenario mode vs. Simulation mode.
  <li> Order dialogs.
  <li> The role of the appserver(sim) module, especially as regards
       decoupling the User Interface from the Simulation.
</ul><p>

<<section func.simstate "Simulation State">>

The <i>simulation state</i> constrains the actions that the User
Interface can take at any given time, i.e., the orders that it can
send.  There are four states:<p>

<dl>
  <dt> <b>PREP</b> - Scenario Preparation
  <dd> In this state the user may freely create and revise scenarios.
       The simulation proper has not yet been initialized.  The
       <<o simclock>> sits at time 0, and that only by courtesy;
       simulated time has not actually begun.<p>

  <dt> <b>PAUSED</b> - Simulation Paused
  <dd> The simulation has been initialized, but time is not currently
       advancing.  Many scenario details (e.g., the number of actors,
       groups, and neighborhoods) are now fixed; other details, such
       as actor strategies, may be adjusted by the user.<p>

  <dt> <b>RUNNING</b> - Simulation Running
  <dd> The simulation is currently executing models and advancing
       simulation time.  The simulation is under application control.
       All the user can do is choose to pause execution, and to change
       the data displayed by the User Interface.<p>

  <dt> <b>SNAPSHOT</b> - Snapshot Mode
  <dd> Each time the simulation transitions from <i>PAUSED</i> to
       <i>RUNNING</i>, it takes a snapshot of the current simulation
       state.  The user can revisit these snapshots, looking at the
       results or resuming execution as of that time.<p>
</dl>

<<xref fig.simstates>> shows the possible state transitions and the
triggering events.  "SIM:LOCK", etc., are the orders that cause the
state transitions to occur; they are sent by the User Interface in
response to various user interactions.<p>

Note that the transitions between <b>PAUSED</b> and <b>SNAPSHOT</b>
are not governed by orders.  While in snapshot mode, the user can
select any previous snapshot, each of which is essentially a complete
scenario.  As with File/New, File/Open, and File/Save, these are
meta-actions that determine which scenario is being used, and hence
are outside of the order scheme.  The user returns to the PAUSED state
by returning to the latest simulation time, or by choosing to
"re-enter the time stream" at some earlier time.<p>


<<figure fig.simstates "Simulation States" AthenaSimStates.png>>

<<section mt "Multi-Threading">>

<b>Note: The architecture described in this section is experimental,
and the Engine thread has not yet been implemented.  Multi-threading
can be enabled by passing the <code>-threads</code> option to Athena
at start-up; however, this is not recommended for general use.</b><p>

Athena can run either single-threaded or multi-threaded.  The goal of
multi-threading is to keep the User Interface responsive while the
Simulation is <b>RUNNING</b>.<p>

In multi-threaded mode, Athena uses three threads:<p>

<dl>
  <dt> <b>App</b> - Main Application Thread
  <dd> This is the main thread, created automatically when the
       application is invoked.  It contains the User Interface, and is
       generally in charge.<p>

  <dt> <b>Engine</b> - Model Engine Thread
  <dd> <b>Not Yet Implemented.</b> This thread is responsible for the
       simulation proper, i.e., the 
       models.  It handles simulation initialization and time
       advances.  In other words, this thread is the whole point of
       multi-threaded mode.<p>

  <dt> <b>Logger</b> - Debugging Log Thread
  <dd> Both the App thread and the Engine thread can write to the
       debugging log, which means that access to the log needs to be
       synchronized.  This is done by giving control of the log to a
       third thread; App and Engine both send log messages
       asynchronously to the Logger thread.<p>
</dl><p>

See <<xref package>> for a description of how the code is layed out on
the disk to support multi-threading.<p>

<<section mt.tcl "Multi-Threaded Tcl/Tk">>

In Tcl's threading model, threads are independent entities each of
which contains its own Tcl interpreter.  Threads communicate by
sending messages to each other, much as separate processes might.<p>

It is possible to create a thread so that it performs a given task and
then terminates.  However, it is more typical to create threads that
initialize themselves and then enter the Tcl event loop.  Commands may
then be sent to the thread using the <b>thread::send</b> command.
Sent commands are queued in the Tcl event loop, and handled by the
receiving thread in the order in which they are received.<p>

<<section mt.tcl.sync "Synchronous vs. Asynchronous Send">>

Commands may be sent synchronously or asynchronously by specifying
<b>thread::send</b>'s <b>-async</b> option.  When a command is sent
synchronously, the sending thread will block until the command has
been executed, and will receive the command's return value.  When a
command is sent asynchronously, control returns to the sending thread
immediately and no return value is received.<p>

Synchronous sends must be carefully controlled: the application will
deadlock if thread A synchronously calls thread B, and in response
thread B synchronously calls thread A.  When combined with a
forwarding proxy, however, synchronous sends are extremely useful: the
calling thread can access another thread as though the receiving
object were in the same thread. <p>

To avoid ambiguity, this document will refer to the <b>thread::send</b>
and <b>thread::send -async</b> commands as <b>sync-send</b> and
<b>async-send</b> respectively.<p>

<<section mt.tcl.tk "Tk and Threads">>

Some people have reported success in using Tk in multiple threads.
It is safest, however, to confine Tk usage to a single thread, and
preferably the main thread.  This is usually no hardship.<p>

<<section mt.proxies "Proxy Objects">>

Tcl threads are treated almost like separate processes; each thread
runs its own set of code, and hence has its own set of objects.  It is
often necessary for a thread to access <i>remote</i> objects, i.e.,
objects in other threads, and this is usually done via a <i>proxy
object.</i> A proxy object stands in for the remote object, and often
presents the same interface to the caller. Calls to the proxy are
magically sent to the remote object.<p>

The simplest kind of proxy is called a <i>forwarding</i> proxy.  This
is an object, often implemented as a single proc, which simply
forwards all subcommands to an object of the same name in another
thread using either <b>sync-send</b> or <b>async-send</b>, as
appropriate.<p>

A synchronous forwarding proxy can make an object that resides in
another thread look like it resides in the calling thread.  This can
simplify program logic at the expense of responsiveness.  This is
often worthwhile.  GRAM, for example, must reside in the Engine
thread, but is also a <<xref saveable(i)>> with significant in-memory
state. A synchronous forwarding proxy defined in the App thread will allow the
<<o scenario>> object to checkpoint and restore GRAM without changing
the <<o scenario>> at all.<p>

<<section mt.conventions "Thread Conventions">>

In order to avoid deadlock, we will adopt the following
conventions:<p>

<ul>
  <li> The App thread may use <b>sync-send</b> or <b>async-send</b> to
       send commands to other threads, trading off synchroneity for
       responsiveness as it seems appropriate.  Long operations, such
       as executing a time tick, will usually use <b>async-send</b>
       coupled with some notification sent back by the recipient.
       Short operations, such as checkpoint and restore, will usually use
       <b>sync-send</b>.<p>

  <li> The App thread must be designed not to <b>sync-send</b> a
       command to a thread that is currently processing an
       <b>async-send</b>, e.g., it mustn't ask to checkpoint GRAM
       while the Engine thread is advancing time.  The simulation
       state machine described in <<xref func.simstate>> largely takes care
       of this.<p>

  <li> Other threads may only use <b>async-send</b> to communicate
       with each other or with the App thread.  In this case, the
       commands sent will usually be notifications of some kind, and
       will often be turned into <<xref notifier(n)>> events by the
       receiving object in the App thread.<p>
</ul>

<<section mt.app "The Application Thread">>

The Application or "App" thread is the main thread of the program.  It
functions more or less the same in either single-threaded or
multi-threaded mode; in the former, it simply hands off control to
other threads from time to time.  The primary difference between the
two modes from the App thread's point of view is whether it is dealing
with real objects (single-threaded) or with proxies to real objects in
other threads (multi-threaded).  The nature and identity of each of these
proxies will be described below, under with the relevant thread.<p>

<<section mt.logger "The Logger Thread">>

The Logger thread is responsible for creating and managing the
debugging log.  It consists of two primary objects:<p>

<dl>
  <dt> <b>::app</b>
  <dd> The application object, which is responsible for initializing
       the thread and handling notifications to the App thread.<p>

  <dt> <b>::log</b>
  <dd> A standard <<xref logger(n)>> object, used to write messages to
       the log.<p>
</dl>

The Logger thread is created by the App thread's <<o log>> proxy object,
which mimics an instance of <<xref logger(n)>>.  In single-threaded
mode, <<xref logger(n)>> subcommands are delegated directly to a
<<xref logger(n)>> component; in multi-threaded mode they are passed
to the Logger thread's <<o log>> object using <b>async-send</b>.
Tcl's Thread package ensures that these messages are processed in the
order they are received; no other synchronization is required.<p>

The Engine thread defines its own <<o log>> proxy, which simply
forwards all subcommands to the Logger thread using
<b>async-send</b>.<p>

Because the sending threads do not need to wait for the log messages
to be written to disk, this mechanism actually results in a slight
performance gain.<p>

<<section mt.engine "The Engine Thread">>

<b>This section is preliminary, as the Engine thread has not yet been
implemented.</b>

The Engine thread is created by the App thread's <<o engine>> object.
In single-threaded mode, the <<o engine>> object provides the
Simulation with its <b>start</b> and <b>tick</b> operations, which are
executed on scenario lock and on time-advance, respectively.

In multi-threaded mode, the <<o engine>> object creates and configures
the Engine thread, and forwards these requests to it.  In addition,
the App thread's <<o engine>> object creates proxies for a number of
modules that reside in the Engine thread.  GRAM, for example, is
represented in the App thread by a synchronous forwarding proxy,
<<o aram>>.  This allows <<o scenario>> to checkpoint and restore
GRAM, and magic inputs and events executed in the <b>PAUSED</b> state
to give inputs to GRAM.<p>

The Engine thread will include an <<o engine>> object of its own,
running as a slave of the App thread's <<o engine>> object.  When a
tick is requested, for example, App's <<o engine>> will
<b>async-send</b> the request to the Engine thread's <<o engine>>.
The Engine's <<o engine>> will send some notification back to the App
thread, resulting in an <<o engine>> <<event Tick>> event.  The
User interface will update, and App's <<o sim>> object will can then
either request another tick or return to the <b>PAUSE</b> state.<p>

The App's <<o engine>> object will define its own state machine with
two states, <b>WORKING</b> and <b>IDLE</b>.  The <<o engine>> will be
<b>WORKING</b> while the Engine thread is handling an
<b>async-send</b>, e.g., a time tick, and <b>IDLE</b> otherwise.  It
will be an error to request an asynchronous operation while the
<<o engine>> is <b>WORKING</b>.<p>


<<section package "Package Architecture">>

<b>Note: The package architecture described here was devised to support
<<xref mt>>, which has not yet been completely implemented.  For
normal use, the code resides in the app_sim(n), app_sim_shared(n), and
app_sim_ui(n) packages, which are as described.  The app_sim_logger(n)
package exists and is functional (when threads are enabled).  The
app_sim_engine(n) package is a stub, and is not currently used.</b><p>

The Athena application code is divided into five packages, three
thread packages and two functionality packages.  Each thread gets its
own package, which defines its <<o app>> object and is responsible for
initializing and configuring the thread's code.  The bulk of code in
each thread will usually come from one or more of the functionality
packages.<p>

The packages are as follows:<p>

<ul>
  <li> <b>app_sim(n)</b>
       <ul>
         <li> Main package for the App thread (and for the application
              as a whole).
         <li> Resides in <code>lib/app_sim</code>.
         <li> Loaded by <<xref athena(1)>> in main thread.
         <li> Loads the <b>app_sim_shared(n)</b> and
              <b>app_sim_ui(n)</b> packages.
       </ul><p>

  <li> <b>app_sim_engine(n)</b>
       <ul>
         <li> Main package for the Engine thread.  <b>Not Yet Implemented.</b>
         <li> Resides in <code>lib/app_sim/engine</code>.
         <li> Loaded into the Engine thread by the App thread when
              running in multi-threaded mode.
         <li> Loads the <b>app_sim_shared(n)</b> package.
       </ul><p>
       
  <li> <b>app_sim_logger(n)</b>
       <ul>
         <li> Main package for the Logger thread.
         <li> Resides in <code>lib/app_sim/logger</code>.
         <li> Loaded into the Logger thread by the App thread when
              running in multi-threaded mode.
       </ul><p>

  <li> <b>app_sim_shared(n)</b>
       <ul>
         <li> Main functionality package.  Most of the application
              code is in this package.
         <li> Resides in <code>lib/app_sim/shared</code>.
         <li> Loaded by the App and Engine threads.
       </ul><p>
       
  <li> <b>app_sim_ui(n)</b>
       <ul>
         <li> User interface package -- Tk and appserver code.
         <li> Resides in <code>lib/app_sim/ui</code>.
         <li> Loaded only by the App thread.
         <li> This code could reside in <b>app_sim(n)</b>, but as it
              is both large and easily separated, it was moved here.
       </ul><p>
</ul>

<<section objects "Significant Objects">>

This section is a glossary of the most important objects in the
application. <b>Note: The descriptions for multi-threaded mode are
accurate but experimental, and multi-threaded mode has not yet been
completely implemented.</b><p>

<<section objects.app ::app>>

Each thread has an <<o app>> object which is responsible for:<p>

<ul>
  <li> Initializing and configuring the thread.
  <li> Providing standard services (e.g., <code>::app error</code>) to
       the thread.
</ul><p>

<<section objects.aram ::aram>>

In single-threaded mode, an instance of <<xref gram(n)>>. In
multi-threaded mode, the Engine thread contains an instance of
<<xref gram(n)>>, and the App thread contains a synchronous forwarding
proxy of the same name.<p>

<<section objects.engine ::engine>>

In single-threaded mode, the <<o engine>> object is simply responsible
for invoking the simulation models when requested.  In multi-threaded
mode, the <<o engine>> exists in both the App and Engine threads, but
runs in different modes.  In the App thread it creates the Engine
thread and a variety of proxy objects; in the Engine thread it invokes
the simulation models, as before, and sends notifications back to the
App thread.<p>

<<section objects.log ::log>>

In single-threaded mode, the <<o log>> object is a simple wrapper
around an instance of <<xref logger(n)>>.  In multi-threaded mode,
<<o log>> is a distinct object in every thread:<p>

<ul>
  <li> In Logger, it is an instance of <<xref logger(n)>>.
  <li> In Engine, it is an asynchronous forwarding proxy of Logger's
       <<o log>>.
  <li> In App, it is a more complicated proxy, which is responsible
       also for creating the Logger thread and handling notifications
       from the Logger thread.
</ul>

<<section objects.parm ::parm>>

The <<o parm>> object is a wrapper around <<xref parmdb(n)>>.  It can
run in two modes, <b>master</b> and <b>slave</b>.  In the App thread
it runs as a <b>master</b>, whether the application is single-threaded or
multi-threaded.  In the Engine thread it runs as a slave; it is
intended to simply echo the contents of the master object in the App
thread.<p>

It is the responsibility of the App's <<o engine>> to keep the two
objects synchronized.<p>

<<section objects.rdb ::rdb>>

The <<o rdb>> object controls the RDB.  SQLite is multi-threaded, so
the object is essentially the same in both the App and Engine
threads.  In either case it is an instance of <<xref scenariodb(n)>>.
It is the responsible of the thread's <<o app>> object to make sure
that all required SQL functions and GUI views are defined (see
<<xref data.rdb.appsql>>).<p>

The RDB is created in "WAL" mode, which allows one writer and an
arbitrary number of readers at the same time.  Consequently, only one
thread can write to the RDB.  In general, the Engine thread can write
to the RDB when it is processing any request, whether synchronous or
asynchronous, and the App thread can write to the RDB at other
times.<p>

More specifically:<p>

<ul>
  <li> The Engine can write to the RDB during a <b>sync-send</b>.
       Because the App blocks during <b>sync-send</b>s, it will not be
       writing to the RDB.<p>

  <li> The Engine can write to the RDB during an <b>async-send</b>.
       At this time, the App's <<o engine>> will be <b>WORKING</b>,
       and the simulation state will be <b>RUNNING</b>.  The user is
       not allowed to send any order but SIM:PAUSE in the
       <b>RUNNING</b> state, and so this condition is met.<p>

  <li> Thus, the App thread can write to the RDB whenever it can
       execute an order from the user, i.e., in <b>PREP</b> or
       <b>PAUSED</b>, and when not calling the Engine thread
       synchronously.<p>
</ul>

<<section objects.scenario ::scenario>>

The <<o scenario>> object resides in the App thread; it is responsible for
creating, loading, and saving scenarios, handling snapshots, and so forth.<p>

<<section objects.sim ::sim>>

The <<o sim>> object resides in the App thread.  It is responsible for
the simulation state (<<xref func.simstate>>) and for controlling the
advance of simulation time.<p>

<<section objects.simclock ::simclock>>

In single-threaded mode there is a single <<xref simclock(n)>> object
called <<o simclock>> that maintains the current simulation time.<p>

In multi-threaded mode, each thread has its own instance of
<<xref simclock(n)>>; these instances must be kept synchronized.<p>

<b>The following scheme is preliminary.</b>  The Engine thread will
contain the master simulation clock, as time advances in the middle of
each simulation tick.  Each time it advances the lock, the Engine will
notify the Logger thread immediately; thus, all log messages produced 
by the Engine will have the correct timestamp.<p>

The App thread, however, will be notified of the new time at the
<i>end</i> of each simulation tick, as that is the first time it will
be able to see any of the data updated by the tick.<p>

<hr>
<address><a href="http://eis.jpl.nasa.gov/~will/">Will Duquette</a> / <a href="mailto:William.H.Duquette@jpl.nasa.gov">
William.H.Duquette@jpl.nasa.gov</a></address>

</body> </html>



