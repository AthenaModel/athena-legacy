<html> <head>
<title><<project>> <<version>>: Configuration Management Plan</title>
<style>
<<standardstyle>>
</style>
</head>

<<swallow {
    # Macro Definitions

    # <<tree>>
    # <<treedir path>> Description <</treedir>>
    #    ...
    # <</tree>>

    template tree {} {
        |<--
        <table border="0" cellspacing="0" cellpadding="0"> 
    }

    template treedir {path} {
        set trans {
            +   &nbsp;&nbsp;&nbsp;&nbsp; 
            <   <i> 
            >   </i>
        }

        set path [string map $trans  $path]
    } {
        |<--
        <tr><td><b><tt>$path</tt></b></td>
        <td>
    }

    template /treedir {} {
        </td>
        </tr>
    }

    template /tree {} {
        |<--
        </table>
    }


}>>

<body>
<<banner>>

<h2>Configuration Management Plan</h2>

<<hrule>>

<<contents>>

<<hrule>>

<<preface changelog "Change Log">>

<<changelog>>

<<change 10/7/2011 Updated will>>
<ul>
  <li> Changed the naming convention for experimental branches; they
       are now named "yyyymm_name" rather than "yyyymmdd_name".<p>

  <li> Updated the official build procedure; Athena and Mars version
       strings are now handled differently.<p>
</ul>
<</change>>

<<change 1/9/2009 Updated will>>
Initial Draft
<</change>>

<</changelog>>

<<hrule>>

<<section overview "Overview">>

Athena uses uses Subversion for version control, and Bugzilla for
package tracking.  This document describes how this works out in
practice.<p>

<<section overview.mars "Mars Simulation Infrastructure Library">>

Athena relies on a number of Tcl packages and extensions which are
contained in the Mars Simulation Infrastructure Library.  This
document explains how Athena uses Subversion to access Mars.<p>

<<section overview.numbering "Athena Version Numbering">>

Versions of the Athena software are numbered <i>x.y.z</i> where <i>x</i>
is the major release number, <i>y</i> is the minor release number, and
<i>z</i> is the build number.  The value of <i>x</i> is incremented at
the beginning of each development cycle.  The value of <i>y</i> is 0
during normal development and is incremented for each specific release
branch.  The value of <i>z</i> is incremented for each build. For
example, the baseline development build for Athena 1 is 1.0.0, followed
by 1.0.1, 1.0.2, and so forth.  The first release baseline is 1.1.0,
followed by 1.1.1, 1.1.2, and so forth, as needed.  Additional release
branches 1.2, 1.3, and so forth may be added for special releases.
Meanwhile, main line development then continues with build 2.0.0.<p>

By convention, the main development branch for Athena 1 is called 1.0.x
(even though it's really the project trunk); the release branches are
called 1.1.x, 1.2.x, and so forth.<p>

<<section overview.tree "Project Tree">>

The project directory tree is as follows:<p>

<<table tab.tree "Project Directory Tree">>
<<tree>>

<<treedir <root>/       >> Root of project tree<</treedir>>
<<treedir +bin/         >> Executables (both binaries and scripts)<</treedir>>
<<treedir ++athena.tcl  >> <<xref athena(1)>> launcher source code<</treedir>>
<<treedir ++athena      >> <<xref athena(1)>> binary<</treedir>>
<<treedir ++athena_test >> <<xref athena_test(1)>> application test
                           suite.<</treedir>>
<<treedir +docs/        >> Project documentation<</treedir>>
<<treedir ++dev/        >> Miscellaneous development documentation<</treedir>>
<<treedir ++man1/       >> Man page section (1): Executables<</treedir>>
<<treedir ++man5/       >> Man page section (5): File Formats<</treedir>>
<<treedir ++mann/       >> Man page section (n): Tcl Commands<</treedir>>
<<treedir ++mani/       >> Man page section (i): Tcl Interfaces<</treedir>>
<<treedir ++mansim/     >> Man page section (sim): <<xref athena_sim(1)>>
                           internals.<</treedir>>
<<treedir +lib/         >> Tcl Libraries <</treedir>>
<<treedir ++<name>/     >> Tcl source code for package
                           <i>name</i><</treedir>>
<<treedir ++app_<name>/ >> Tcl source code for <<xref athena(1)>> application
                           athena_<i>name</i><</treedir>>
<<treedir +mars/...     >> Mars Simulation Infrastructure Library<</treedir>>
<<treedir +src/         >> C/C++ source directory<</treedir>>
<<treedir ++lib<name>/  >> C/C++ source code for library
                           lib<i>name</i>.a<</treedir>>
<<treedir +test/        >> Top-level test directory<</treedir>>
<<treedir ++<name>/     >> Test code for application <i>name</i>.<</treedir>>
<<treedir +tools/       >> Tools directory<</treedir>>
<<treedir ++basekits/   >> Tcl/Tk basekits<</treedir>>
<</tree>>
<</table>>

<b>Notes:</b><p>

<ul>
  <li> The structure of Tcl package directories is described in the
       <i>Mars Tcl Coding Standard</i>.
</ul>

<<section overview.docs "Development Documentation">>

Athena development documentation consists of:<p>

<ul>
  <li> Software manual pages (man pages)
  <li> Memos
  <li> Other documents: this CM Plan, etc.
</ul><p>

Software manual pages are stored in the repository project tree, as
described in <<xref overview.tree>>, and are written in
<<xref mars:mars_man(5)>> format.<p>

Other documents may be written in HTML or in MS Word; note that Word
documents should be saved in both Word and PDF formats. HTML documents
usually use the <<xref mars:mars_doc(5)>> extended HTML format.<p>

Memos will be saved on the Athena web page:<p>

<pre>http://eis.jpl.nasa.gov/athena</pre>

Because memos are date-stamped, they need not be version-controlled in
the repository.<p>

Other documents, such as this CM plan, will be stored in the
repository in the <code>docs/dev</code> directory.<p>

<<section overview.references "References">>

<<xrefset marscm "<i>Mars Configuration Management Plan</i>" ../../mars/docs/dev/cm.html>>

<<xrefset tps "<i>Third-Party Software List</i>" tps.html>>

<<xref marscm>><p>

<<xref tps>><p>

<i>Bugzilla</i>, <<link http://www.bugzilla.org>><p>

<i>Subversion</i>, <<link http://subversion.tigris.org>><p>

<i>Pragmatic Version Control: Using Subversion</i>, by Mike Mason,
Pragmatic Bookshelf, 2006.<p>

<<section vc "Version Control">>

Athena uses Subversion more or less as described in <i>Pragmatic Version
Control using Subversion</i>.<p>

<<section vc.repository "The Subversion Repository">>

The Athena Subversion repository URL is<p>

<pre>    https://oak.jpl.nasa.gov/svn</pre>

For developers at JPL, this may be abbreviated <code>https://oak/svn</code>.<p>

In the remainder of this document, the string <i>repository</i> will
mean the repository's base URL in either of the above forms.<p>


The repository can contain multiple projects; for example, there are
separate projects for Athena and for its infrastructure, Mars.  The
project URLs are:<p>

<pre>
     <i>repository</i>/mars/
     <i>repository</i>/athena/
</pre>

or, more generally,

<pre>
     <i>repository</i>/<i>project</i>/
</pre>


Each project has the following internal structure:<p>


<pre>
    <i>repository</i>/<i>project</i>/trunk/
    <i>repository</i>/<i>project</i>/branches/
    <i>repository</i>/<i>project</i>/tags/
</pre>

The <code>trunk</code> directory contains the project's files on the
main line of development.  Subdirectories of the <code>branches</code>
directory represent development branches. Subdirectories of the
<code>tags</code> directory represent snapshots of development, e.g.,
the 1.0.7 build.


<<section vc.branches "Subversion Branches and Tags">>

This section explains how Athena uses Subversion branches and tags to
facilitate Athena development.  Procedures appear in
<<xref proc>>.<p>

<<table tab.branches "Branches and Tags">>
<table border="1" cellspacing="0">

<tr align="left">
<th>Branch/Tag</th>
<th>Example</th>
<th>Description</th>
</tr>

<tr valign="top">
<td><code>trunk/</code></td>
<td><code>trunk/</code></td>
<td>All current development</td>
</tr>

<tr valign="top">
<td><code>tags/athena_<i>x.y.z</i></code></td>
<td><code>tags/athena_1.0.7</code></td>
<td>Snapshot of Athena build <i>x.y.x</i></td>
</tr>

<tr valign="top">
<td><code>branches/<i>user</i>/<i>yyyymm_name</i></code></td>
<td><code>branches/will/201110_sample</code></td>
<td>Experimental branch</td>
</tr>

<tr valign="top">
<td><code>branches/bug/<i>nnnn</i></code></td>
<td><code>branches/bug/1776</code></td>
<td>Bug-fix branch</td>
</tr>
</table>
<</table>>

<<section vc.branches.builds "Build Tags">>

At each official build during normal development, the trunk is tagged
for the build as "<code>tags/athena_<i>x.y.z</i></code>".  This serves as
a snapshot of the build, and allows it to be recovered at any time.<p>

<<section vc.branches.release "Release Branches">>

When preparing for a specific release, a release branch is created as
directory as "<code>branches/athena_x.y.<i>x</i></code>", where
<i>x.y</i> is the base version number.  Thus, the 1.1 release branch
will be "<code>branches/athena_1.1.x</code>". The release branch can be
checked out just as the trunk is; and changes can be committed and
builds tagged in the same way.  Thus, development can continue on the
trunk while the last bugs are being fixed for release on the release branch.<p>

<<section vc.branches.exper "Experimental Branches">>

Developers can create branches on which to do experimental coding; the
results can later be merged with the trunk or abandoned.  Experimental
branches are created with branch name
"<code>branches/<i>user</i>/<i>yyyymm_name</i></code>",
where <i>user</i> is the developer's user name, <i>yyyymm</i> is the current
year and month, and <i>name</i> is some brief name for the experiment.
Experimental branches can then be checked out just like release branches.<p>

<<section vc.branches.bugfix "Bug-fix Branches">>

When fixing complicated bugs over a period of time, it is sometimes
useful to do the fix on a separate branch.  This allows multiple
commits without any chance of destabilizing the trunk.  Such branches
should be called "<code>branches/bug/<i>nnnn</i></code>", where
<code>nnnn</code> is the bug number.  The completed fix can be merged
back to the trunk just as with an experimental branch.<p>

<<section vc.mars "Mars Simulation Interface Library">>

Athena relies on infrastructure in the Mars Simulation Interface
Library, which is also stored in the Subversion repository.  Each
version of Athena needs to be tied to a specific version of Mars, and
the mechanism needs to allow for Athena to run with Mars at both
development time (when Athena is running as a Tcl script loading
packages from <code>lib/</code> directories) and in test and
production (when Athena is running as a standalone executable created
using Tcl Dev Kit).<p>

See the <<xref marscm>> for additional details.<p>

<<section vc.mars.mainline "Main Line Development">>

In general, it is most convenient if Mars simply appears to be part of
the Athena codebase.  At the same time, it must have its own existence,
as it has other clients in addition to Athena.  Fortunately, Subversion
has a mechanism for this.  The <code>svn:externals</code> property,
when applied to a directory in Subversion, causes external projects to
be checked out into subdirectories.  Consequently, we can set
svn:externals as follows on the <code>athena/trunk/</code> directory:<p>

<pre>
    $ svn propset svn:externals <i>repository</i>/athena/trunk \
         "mars <i>repository</i>/mars/trunk"
</pre>

When <code>athena/trunk/</code> is checked out as, say,
<code>athena/</code>, this property setting will automatically cause
subversion to check out <code>mars/trunk/</code> as
<code>athena/mars/</code>.  The Athena scripts and Makefiles can then be
made to access the Mars libraries and development tools just as though
they were part of the Athena project itself.<p>

<<section vc.mars.builds "Build Snapshots">>

It's appropriate for the Athena trunk to rely on the Martian trunk, for
they are developed in tandem.  However, each build of Athena needs to be
associated with a particular build of Mars.  The
<<xref mars:mars_link(1)>> tool can be used to link a
Athena build with a Mars build either by using
<code>svn:externals</code> or by using <code>svn copy</code> to pull
the code for the build of Mars into the Athena code base.<p>

The procedures in <<xref proc>> do the former, as it more clearly
indicates which version of Mars is in use.<p>

<<section vc.mars.branches "Release Branches">>

Athena release branches need to support bug fixes in Mars,
while allowing Mars development to proceed unhindered.  The easiest
method is to use <<xref mars:mars_link(1)>> to pull a copy of the
desired version of Mars onto the Athena release branch.  Bug fixes can
then be done on the release branch, and merged back into Mars as
desired.<p>

The procedures for this are detailed in <<xref proc>>.<p>

<<section bug "Package Tracking">>

Both bugs and new requirements will be tracked using Bugzilla.
The Athena Bugzilla Server resides at

<pre>    <<link https://oak.jpl.nasa.gov/bugzilla>></pre>

<<section bug.product "Product">>

Bugzilla relates bugs to a specific Product, Version, and Component.
Each Athena development branch is entered as a separate product, e.g.,
"Athena 1.0", "Athena 1.1", "Athena 2.0".  All bugs written against a
particular branch will assigned to that branch's product.<p>

<<section bug.version "Version">>

The "Version" field indicates the build of Athena in which the
bug was found. If the bug was originally written against the same
branch, the version will be "B<i>z</i>" where <i>z</i> is the build
number, the last number in the <i>x.y.z</i> version number.  If the
bug was originally written against a different branch, then the
version will be "V<i>x.y</i>" where <i>x.y</i> identifies the branch.<p>

<<section bug.component "Component">>

Every bug is written against some "component" of the project.  The
following components will be used:<p>


<<table tab.components "Bugzilla Components">>
<table border="1" cellspacing="0">

<tr align="left">
<th>Component</th>
<th>Description</th>
</tr>

<tr valign="top">
<td>CM Process</td>
<td>Makefiles, build tools, CM tools, etc.</td>
</tr>

<tr valign="top">
<td>Code</td>
<td>Source code (plus related data and documentation)</td>
</tr>

<tr valign="top">
<td>Data</td>
<td>Data files, plus related documentation</td>
</tr>

<tr valign="top">
<td>Documentation</td>
<td>Purely documentation-related changes.</td>
</tr>

</table>
<</table>>

<<section bug.whiteboard "Status Whiteboard">>

By convention, the Status Whiteboard field is used to record the build
in which the bug was fixed or otherwise resolved.  The following text
is used:<p>

<pre>    Fixed in <i>x.y.z</i></pre>

where <i>x.y.z</i> is the build version.<p>

<<section bug.severity "Severity">>

Every bug has a severity; Bugzilla defines the following categories:<p>

<<table tab.severity "Bugzilla Severities">>
<table border="1" cellspacing="0">

<tr align="left">
<th>Severity</th>
<th>Description</th>
</tr>

<tr valign="top">
<td><b>Blocker</b></td>
<td>Blocks development and/or testing work</td>
</tr>

<tr valign="top">
<td><b>Critical</b></td>
<td>Crashes, loss of data, severe memory leak</td>
</tr>

<tr valign="top">
<td><b>Major</b></td>
<td>Major loss of function</td>
</tr>

<tr valign="top">
<td><b>Normal</b></td>
<td>Average severity</td>
</tr>

<tr valign="top">
<td><b>Minor</b></td>
<td>Minor loss of function, or other problem where easy workaround is
present</td>
</tr>

<tr valign="top">
<td><b>Trivial</b></td>
<td>Cosmetic problem like misspelled words or misaligned text</td>
</tr>

<tr valign="top">
<td><b>Enhancement</b></td>
<td>Request for enhancement</td>
</tr>

</table>
<</table>>

New features are tracked as "Enhancements"; other bugs are usually set
to "Normal" except in unusual cases.<p>

<<section bug.lifecycle "Life Cycle">>

The "Status" and "Resolution" fields track a bug through its life
cycle, as shown in the following table, which was pulled
from the Bugzilla documentation.<p>

Bugs are created with a Status of <b>NEW</b>, and might
or might not be <b>ASSIGNED</b>.  When it is <b>RESOLVED</b>, the
developer might give it a Resolution of <b>FIXED</b>, <b>INVALID</b>,
<b>DUPLICATE</b>, or <b>WONTFIX</b> (which in practice often means
<b>LATER</b>).<p>

When I&amp;T verifies that the bug is resolved, it is marked
<b>VERIFIED</b>.<p>

<<table tab.lifecycle "Bug Status and Resolution">>
<table border="1" cellspacing="0">

<tr align="left">
<th>STATUS</th>
<th>RESOLUTION</th>
</tr>

<tr valign="top">
<td>
The <b>Status</b> field indicates the general health of a bug.  Only
certain status transitions are allowed.<p>
</td>
<td>
The <b>Resolution</b> field indicates what happened to this bug.
</td>
</tr>

<tr valign="top">
<td>
<b>UNCONFIRMED</b>: This bug has recently been added to the database. Nobody
has validated that this bug is true. Users who have the "canconfirm"
permission set may confirm this bug, changing its state to <b>NEW</b>. Or, it
may be directly resolved and marked <b>RESOLVED</b>.<p>

<b>NEW</b>: This bug has recently been added to the assignee's list of
bugs and must be processed. Bugs in this state may be accepted, and
become <b>ASSIGNED</b>, passed on to someone else, and remain <b>NEW</b>, or
resolved and marked <b>RESOLVED</b>.<p>

<b>ASSIGNED</b>: This bug is not yet resolved, but is assigned to the
proper person. From here bugs can be given to another person and
become <b>NEW</b>, or resolved and become <b>RESOLVED</b>.<p>
 
<b>REOPENED</b>: This bug was once resolved, but the resolution was
deemed incorrect. For example, a <b>WORKSFORME</b> bug is
<b>REOPENED</b> when more information shows up and the bug is now
reproducible. From here bugs are either marked <b>ASSIGNED</b> or
<b>RESOLVED</b>.
</td> 
<td>
No resolution yet. All bugs which are in one of these "open" states
have the resolution set to blank. All other bugs will be marked with
one of the following resolutions.
</td>
</tr>

<tr valign="top">
<td>
<b>RESOLVED</b>: A resolution has been taken, and it is awaiting
verification by QA. From here bugs are either re-opened and become
<b>REOPENED</b>, are marked <b>VERIFIED</b>, or are closed for good
and marked <b>CLOSED</b>.<p>
 
<b>VERIFIED</b>: QA has looked at the bug and the resolution and
agrees that the appropriate resolution has been taken. Bugs remain in
this state until the product they were reported against actually
ships, at which point they become <b>CLOSED</b>.<p>
 
<b>CLOSED</b>: The bug is considered dead, the resolution is
correct. Any zombie bugs who choose to walk the earth again must do so
by becoming <b>REOPENED</b>.
</td>
<td>
<b>FIXED</b>: A fix for this bug is checked into the tree and tested.<p>
 
<b>INVALID</b>: The problem described is not a bug.<p>
 
<b>WONTFIX</b>: The problem described is a bug which will never be fixed.<p>
 
<b>LATER</b>: The problem described is a bug which will not be fixed
in this version of the product.<p>
 
<b>REMIND</b>: The problem described is a bug which will probably not
be fixed in this version of the product, but might still be.<p>
 
<b>DUPLICATE</b>: The problem is a duplicate of an existing
bug. Marking a bug duplicate requires the bug# of the duplicating bug
and will at least put that bug number in the description field.<p>
 
<b>WORKSFORME</b>: All attempts at reproducing this bug were futile,
and reading the code produces no clues as to why the described
behavior would occur. If more information appears later, the bug can
be reopened.
</td>
</tr>

</table>
<</table>>

<<section bug.text "Report Description">>

Bug reports should include enough specific information to allow the
bug to be reproduced.  When the bug is fixed, the comment should
include the precise test needed to verify the fix.<p>


<<section proc "Procedures">>

This section documents the steps involved in the following CM procedures:<p>

<<sectioncontents proc>>

<<section proc.dev "Developer Procedures">>

These procedures are used by the development team in general.<p>

<<section proc.dev.setup "Setting Up the Development Environment">>

The description below assumes the reader is preparing to set up a Athena
development environment for main-line development.<p>

<<procedure>>

<<step>>
Install ActiveTcl Enterprise Edition on your workstation as

<pre>  /usr/local/ActiveTclEE-<i>yyyy</i>Q<i>n</i></pre>

where <i>yyyy</i> is the year and <i>n</i> is the quarter number for
the quarterly release of ActiveTcl Enterprise Edition.  The software
is available from the project's technical contacts with ActiveState.
<</step/>>
n/a
<</step>>


<<step>>
Set up your Subversion password for your <i>username</i> on your
normal development machine.<p>

You'll need a login on <code>oak.jpl.nasa.gov</code> with
<code>sudo</code> privileges, or help from a developer who has it.<p>

You'll be asked for the <code>oak</code> login password, and then your
new Subversion password, twice.
<</step/>>
<pre>
$ ssh oak
$ sudo htpasswd -m /home/apache2/etc/svn-auth <i>username</i>
$ exit
</pre>
<</step>>


<<step>>
Create the <code>~/athena_pkgs</code> directory.  All checked out tags
and branches of Athena will reside in this directory.
<</step/>>
<pre>
$ cd ~
$ mkdir ~/athena_pkgs
</pre>
<</step>>


<<step>>
Check out the Athena trunk as Athena 1.0.x.  You'll be asked for your Subversion password once or twice; then it will be cached.
<</step/>>
<pre>
$ cd ~/athena_pkgs
$ svn checkout <i>repository</i>/athena/trunk athena_1.0.x
</pre>
<</step>>


<<step>>
Make Athena 1.0.x the active Athena version.
<</step/>>
<pre>
$ ln -s ~/athena_pkgs/athena_1.0.x ~/athena
</pre>
<</step>>

<<step>>
Add these lines to your <code>.bash_profile</code>:
<</step/>>
<pre>
# Athena Settings
export PATH=/usr/local/ActiveTclEE-<i>yyyy</i>Q<i>n</i>:~/athena/bin:...
</pre>
<</step>>


<<step>>
Resource your <code>.bash_profile</code>, making these definitions available.
<</step/>>
<pre>
$ cd ~
$ source .bash_profile
</pre>
<</step>>


<<step>>
Do a development build of Athena.
<</step/>>
<pre>
See <<xref proc.dev.build>>
</pre>
<</step>>

<</procedure>>

<<section proc.dev.co_trunk "Checking out the Trunk">>

Check out the project's trunk in order to do main-line development.
The name of the trunk is invariably "<code>trunk</code>"; however, for
convenience it is always checked out as a version, e.g.,
"<code>1.0.x</code>".<p>

<<procedure>>

<<step>>
Go to the <code>athena_pkgs</code> directory.
<</step/>>
<pre>
$ cd ~/athena_pkgs
</pre>
<</step>>


<<step>>
Check out the trunk.
<</step/>>
<pre>
$ svn checkout <i>repository</i>/athena/trunk athena_1.0.x
</pre>
<</step>>

<<step>>
Make this the current version.
<</step/>>
<pre>
$ rm ~/athena
$ ln -s ~/athena_pkgs/athena_1.0.x ~/athena
</pre>
<</step>>


<<step>>
Do a development build.
<</step/>>
See <<xref proc.dev.build>>.
<</step>>


<<step>>
Go to work.
<</step/>>
<pre>
$ cd ~/athena
$ ...
</pre>
<</step>>




<</procedure>>


<<section proc.dev.co_tag "Checking out a Snapshot">>

Snapshots (tags) are usually created only for particular builds, and
have names like "<code>tags/athena_<i>x.y.z</i></code>".  Consequently,
tags can usually be checked out without specifying a directory name.
Don't commit changes to tags.<p>

<<procedure>>

<<step>>
Go to the <code>athena_pkgs</code> directory.
<</step/>>
<pre>
$ cd ~/athena_pkgs
</pre>
<</step>>


<<step>>
Check out the tag.
<</step/>>
<pre>
$ svn checkout <i>repository</i>/athena/tag/athena_1.0.7
</pre>
<</step>>


<<step>>
Switch to this version of Athena.
<</step/>>
<pre>
$ rm ~/athena
$ ln -s ~/athena_pkgs/athena_1.0.7 ~/athena
</pre>
<</step>>


<<step>>
Go to work.
<</step/>>
<pre>
$ cd ~/athena
$ ...
</pre>
<</step>>

<</procedure>>

<<section proc.dev.resync "Resyncing with the Repository">>

<<procedure>>

<<step>>
Go to any directory in a Subversion working copy, and ask for an
update.  The directory and all subdirectories will be resynced.
<</step/>>
<pre>
$ svn update
</pre>
<</step>>

<</procedure>>

<<section proc.dev.status "Checking the Status of a Working Copy">>

<<procedure>>

<<step>>
Go to any directory in a Subversion working copy, and ask for
status.  The directory and all subdirectories will be checked.<p>

Add the <code>-u</code> option to check for updates from other
developers, and for potential conflicts.
<</step/>>
<pre>
$ svn status
</pre>

or<p>

<pre>
$ svn status -u
</pre>
<</step>>

<</procedure>>


<<section proc.dev.bugfix "Fixing a Bug">>

Use the <<xref mars:mars_commit(1)>> tool to commit
changes related to a particular bug report.  Using
<<xref mars:mars_commit(1)>> has the following effects:

<ul>
  <li> The changes will be related to the specific Bugzilla bug number.
  <li> The change comment will be attached to the bug report in Bugzilla.
</ul>

See the <<xref mars::mars_commit(1)>> man page for details.<p>

Note: If you have made changes to both Athena and Mars, you need to
commit them separately.<p>

<<section proc.dev.unfix "Backing Out a Bug Fix">>

Subversion makes it easy to back out changes made in a particular
revision.  The process is described in detail in Section 9.5 of
<i>Pragmatic Version Control using Subversion</i>.<p>

<<section proc.dev.querybug "Finding Out What Changed in a Bug Fix">>

There are two mechanisms for determining what changed in a particular
bug fix.<p>


<<procedure>>

<<step>>
Find the bug in Bugzilla, and check the comments.  Every change
made for the bug that was committed using
<<xref mars:mars_commit(1)>> should have a comment that lists the
changed files.
<</step/>>
n/a
<</step>>


<<step>>
Alternatively, go to the top directory of your working copy, and get a
change log. Search in the log for the bug fix. The log entry will
contain the text "<code>#{num}</code>", where num is the bug
number. Note that there might be more than one log entry. 
<</step/>>
<pre>
$ svn log -v . &gt;log.txt
</pre>
<</step>>


<<step>>
Either way, you'll also find the Subversion revision number for the
specific change, e.g., "1234".  You can get a difference listing for
any file included in the change using that revision number.
<</step/>>
<pre>
$ svn diff -c 1234 <i>repository</i>/<i>path</i>
</pre>
<</step>>

<</procedure>>

<<section proc.dev.mkdir "Adding a New Directory to the Repository">>

<<procedure>>

<<step>>
Check out a working copy, and go to the parent directory of the new
directory.
<</step/>>
<pre>
$ cd ~/athena/...
</pre>
<</step>>


<<step>>
Create the new directory, scheduling it for addition to the repository.
<</step/>>
<pre>
$ svn mkdir <i>name</i>
</pre>
<</step>>


<<step>>
If the directory is added as part of a bug fix, commit the change as
part of the overall fix. Otherwise, commit it now.
<</step/>>
<pre>
$ svn commit -m"<i>description</i>"
</pre>
<</step>>

<</procedure>>

<<section proc.dev.newfile "Adding a New File to the Repository">>

<<procedure>>

<<step>>
Check out a working copy, and go to the directory in which the new
file should be created.
<</step/>>
<pre>
$ cd ~/athena/...
</pre>
<</step>>


<<step>>
Create the new file however you  like.
<</step/>>
<pre>
$ touch <i>name</i>
</pre>
<</step>>


<<step>>
Add the new file to the repository.
<</step/>>
<pre>
$ svn add <i>name</i>
</pre>
<</step>>


<<step>>
If the file is added as part of a bug fix, commit the change as
part of the overall fix. Otherwise, commit it now.
<</step/>>
<pre>
$ svn commit -m"<i>description</i>"
</pre>
<</step>>

<</procedure>>

<<section proc.dev.delfile "Deleting a File from the Repository">>

<<procedure>>

<<step>>
Check out a working copy, and go to the directory in which the
file resides.
<</step/>>
<pre>
$ cd ~/athena/...
</pre>
<</step>>


<<step>>
Remove the file.
<</step/>>
<pre>
$ svn delete <i>name</i>
</pre>
<</step>>


<<step>>
If the file is being deleted as part of a bug fix, commit the deletion as
part of the overall fix. Otherwise, commit it now.
<</step/>>
<pre>
$ svn commit -m"<i>description</i>"
</pre>
<</step>>

<</procedure>>

<<section proc.dev.build "Performing a Development Build">>

A development build is simply a build performed during the course of
development.  A full development build:<p>

<ul>
  <li> Builds C/C++ libraries
  <li> Builds the documentation tree
  <li> Packs the <code>athena.tcl</code> launch script and all relevant
       libraries and files into the <<xref athena(1)>> executable.
  <li> Runs the full test suite.
</ul><p>

It's also possible to do just part of this.<p>

This procedure presumes that the version to be built is the current
version.<p>

<<procedure>>

<<step>>
Go to the version directory.
<</step/>>
<pre>
$ cd ~/athena
</pre>
<</step>>


<<step>>
Build everything from scratch.
<</step/>>
<pre>
$ make clean all
</pre>
<</step>>


<<step>>
Run all tests, if desired.
<</step/>>
<pre>
$ make test
</pre>
<</step>>


<<step>>
The previous two steps can be combined into a single command.
<</step/>>
<pre>
$ make build
</pre>
<</step>>


<<step>>
Read the header of <code>~/athena/Makefile</code> for other possibilities.
<</step/>>
<pre>
emacs ~/athena/Makefile
</pre>
<</step>>

<</procedure>>



<<section proc.dev.mk_exbranch "Creating an Experimental Branch">>

An experimental branch allows a developer to make drastic changes in a
safe sandbox.  Once made, the changes can be abandoned or merged into
a branch or the trunk.  Experimental branches are usually based on the
trunk, but can also be based on any branch or tag.  This procedure
will assume that the branch is based on the trunk.<p>

<<procedure>>

<<step>>
Create the branch.  Branches belonging to a particular developer are
placed in a subdirectory named after the developer's user name.  The
branch directory itself includes the current date and the name of the
experiment.
<</step/>>
<pre>
$ svn copy <i>repository</i>/athena/trunk \
    <i>repository</i>/athena/branches/will/20081010_widget
</pre>
<</step>>


<<step>>
Check out the branch using a pseudo-version number.
<</step/>>
E.g., as "<code>athena_1.0.wid</code>".  See <<xref proc.dev.co_exbranch>>.
<</step>>


<<step>>
By default, the new branch will be linked with the Mars trunk.  If
desired, link it with some other version of Mars.
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.1.wid
$ mars link 1.7
$ mars link save
</pre>
<</step>>


<<step>>
Update the default version number for this branch.
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.1.wid
$ emacs ~/athena_pkgs/athena_1.1.wid/MakeDefs
</pre>

Set <code>ATHENA_VERSION</code> to <code>1.1.wid</code> and commit the
change.
<</step>>

<</procedure>>


<<section proc.dev.co_exbranch "Checking out an Experimental Branch">>

Experimental branches are named for the developer, the date on which
the branch was created, and the experiment itself, e.g.,
"<code>branches/will/20081010_widget</code>" was created on 10 October
2008 by "will" and has something to do with widgets.  It's usually
necessary to pick a directory name when checking out an experimental
branch; a common strategy is to use the directory name
"<code>athena_<i>x.y</i>.name</code>" where <i>x</i> and <i>y</i> are
the major and minor versions of the development branch or trunk, and
name is the experiment name, or some abbreviation of it, e.g.,
"<code>athena_1.0.wid</code>".<p>

<<procedure>>

<<step>>
Go to the <code>athena_pkgs</code> directory.
<</step/>>
<pre>
$ cd ~/athena_pkgs
</pre>
<</step>>


<<step>>
Check out the branch.
<</step/>>
<pre>
$ svn checkout <i>repository</i>/athena/branches/will/20081017_widget \
    athena_1.0.wid
</pre>
<</step>>


<<step>>
Switch to this version of Athena.
<</step/>>
<pre>
$ rm ~/athena
$ ln -s ~/athena_pkgs/athena_1.0.wid ~/athena
</pre>
<</step>>


<<step>>
Go to work.
<</step/>>
<pre>
$ cd ~/athena
$ ...
</pre>
<</step>>

<</procedure>>


<<section proc.dev.merge "Merging Changes from an Experimental Branch">>

Subversion makes it easy to merge changes from one branch to another.
The process is described in detail in Section 9.8 of <i>Pragmatic
Version Control using Subversion</i>.



<<section proc.cm "CM Procedures">>

These procedures are used by the build/release manager.<p>

<<section proc.cm.build "Performing an Official Build">>

An official, or "CM", build is one that will be packaged for delivery
to Integration and Test (I&amp;T).  It is rather more complicated than a
development build, particularly as it involves not only tagging the
development branch, but also building the Mars Simulation
Infrastructure Library.<p>

Note that some of the Mars-related steps only apply when Mars is
externally linked, i.e., on the Athena trunk.  Release branches generally
include their own copy of Mars; thus, no special steps need be taken.<p>

<<procedure>>

<<step>>
Make sure that all developers have committed all required code changes.
<</step/>>
n/a
<</step>>

<<step>>
<b>Trunk Only.</b> Perform an official build of Mars, if
necessary (that is, if anything has changed since the previous Athena
build).
<</step/>>
See the <<xref marscm>>.  We'll assume that the
resulting Mars build is Mars 1.6.
<</step>>

<<step>>
Determine the Athena build number.
<</step/>>
We'll assume it's Athena 1.0.9.
<</step>>

<<step>>
Check out the desired trunk or branch of Athena into a directory named
for the new build.
<</step/>>
<pre>
$ cd ~/athena_pkgs
$ svn checkout <i>repository</i>/athena/trunk athena_1.0.9
</pre>
<</step>>


<<step>>
Update the build notes file with a description of the changes, and
check it into the repository.
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.0.9/docs
$ emacs build_notes.ehtml
$ svn commit -m"Updated for Build 1.0.9"
</pre>
<</step>>


<<step>>
<b>Trunk Only.</b>  The embedded Mars working copy will contain the
Mars trunk.  Temporarily link the working copy to the specific version
of Mars built earlier.
<</step/>>
If your <code>PATH</code> environment variable contains
<code>~/mars/bin/</code>, then

<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ mars link 1.6
</pre>

Otherwise,<p>

<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ ./mars/bin/mars link 1.6
</pre>

This is equivalent to:<p>

<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ svn switch <i>repository</i>/mars/tags/mars_1.6 mars
</pre>

<</step>>

<<step>>
Do a development build and test of the client. Resolve any errors, and
retest, until the client builds cleanly. Commit any changes.
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ make build
</pre>
<</step>>


<<step>>
Tag the build, updating the working copy to the tagged version. 
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ make tag ATHENA_VERSION=1.0.9
</pre>

This is equivalent to:<p>

<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ svn copy . <i>repository</i>/athena/tags/athena_1.0.9
$ svn switch <i>repository</i>/athena/tags/athena_1.0.9 .
$ echo 1.0.9 > lib/projectlib/version.txt
$ svn commit lib/projectlib/version.txt
</pre>
<</step>>

<<step>>
<b>Trunk Only.</b>  Permanently link the tagged version to the
required version of Mars.  Note that the previous step set the
embedded version of Mars back to the Mars trunk.<p>
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ mars link 1.6
$ mars link save
</pre>

This is equivalent to:<p>

<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ svn switch <i>repository</i>/mars/tags/mars_1.6 mars
$ svn propset svn:externals \
    "mars <i>repository</i>/mars/tags/mars_1.6" .
$ svn commit -m"Permanently link with Mars 1.6" .
</pre>

<</step>>


<<step>>
Perform the official CM build. Installation, source, and documentation
tarballs will be created automatically:<p>

<ul>
  <li> <code>~/athena_pkgs/athena_1.0.9.tgz</code>
  <li> <code>~/athena_pkgs/athena_1.0.9_src.tgz</code>
  <li> <code>~/athena_pkgs/athena_1.0.9_docs.tgz</code>
</ul>
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.0.9
$ make cmbuild
</pre>
<</step>>


<<step>>
Install the build's documentation on the Athena web page. The
documentation will be installed in the following AFS directory:<p>

<pre>   /afs/jpl/group/athena/www/doc_1.0.9</pre>

The documents will then be available on the web at:

<pre> http://eis.jpl.nasa.gov/athena/doc_1.0.9/docs/developer.html</pre>
<</step/>>
<pre>
$ klog
$ cd ~/athena_pkgs/athena_1.0.9
$ make installdocs
</pre>
<</step>>


<<step>>
The previous two steps can be combined:
<</step/>>
<pre>
$ klog
$ cd ~/athena_pkgs/athena_1.0.9
$ make cmbuild installdocs
</pre>
<</step>>


<<step>>
Copy the tarballs to the archive directory on AFS.
<</step/>>
<pre>
$ cd /afs/jpl/group/athena/www/archive
$ mkdir athena_1.0.9
$ cd athena_1.0.9
$ mv ~/athena_pkgs/athena_1.0.9*.tgz .
</pre>
<</step>>


<<step>>
Add the new build's documentation tree to the main index on the Athena
web page.  Add a link to

<pre> http://eis.jpl.nasa.gov/athena/doc_1.0.9/docs/developer.html</pre>

<</step/>>
<pre>
$ cd /afs/jpl/group/athena/www
$ emacs index.html
</pre>
<</step>>


<</procedure>>


<<section proc.cm.mk_relbranch "Creating a Release Branch">>

A release branch allows developers to fix bugs for release in a stable
code base, while continuing main-line development  on the trunk.  A
release branch can be based on any branch or tag; it's probably best
to base it on a tag.  For example, suppose that the Athena 1.1 feature
freeze is in effect following the build of Athena 1.0.33.<p>

In addition, each release branch should copy the version of Mars
on which it is based, so that Mars bugs can be fixed on the release
branch.<p> 

Create the release branch as follows:<p>

<<procedure>>

<<step>>
Copy the desired branch, trunk, or tag to <code>athena/branches</code>.
<</step/>>
<pre>
$ svn copy <i>repository</i>/athena/tags/athena_1.0.33 \
	<i>repository</i>/athena/branches/athena_1.1.x
</pre>
<</step>>


<<step>>
Check out the branch.
<</step/>>
<pre>
$ cd ~/athena_pkgs
$ svn checkout <i>repository</i>/athena/branches/athena_1.1.x
</pre>
<</step>>


<<step>>
Determine which version of Mars the branch is currently linked with.
It will be the same version as the the tag on which the branch is based.
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.1.x
$ mars link
</pre>
<</step>>


<<step>>
Copy the linked version of Mars into the release branch.
<</step/>>
<pre>
$ cd ~/athena_pkgs/athena_1.1.x
$ mars link save -ascopy
</pre>
<</step>>


<<step>>
Update the default version number for this branch.
<</step/>>
<pre>
$ emacs ~/athena_pkgs/athena_1.1.x/MakeDefs
</pre>

Set <code>ATHENA_VERSION</code> to <code>1.1.x</code> and commit the
change.
<</step>>

<</procedure>>




<<section proc.cm.co_relbranch "Checking out a Release Branch">>

Release branches are for a particular major and minor version
<i>x.y</i> of Athena, e.g., Athena 1.1.  All builds on the branch will
have the same major and minor versions; consequently the branch is
usually called "<code>branches/athena_<i>x.y</i>.x</code>", e.g.,
"<code>branches/athena_1.1.x</code>".  Checking out a
release branch is just like checking out a tag, except that changes
can be committed.<p>

<<procedure>>

<<step>>
Go to the <code>athena_pkgs</code> directory.
<</step/>>
<pre>
$ cd ~/athena_pkgs
</pre>
<</step>>


<<step>>
Check out the branch.
<</step/>>
<pre>
$ svn checkout <i>repository</i>/athena/branches/athena_1.1.x
</pre>
<</step>>


<<step>>
Switch to this version of Athena.
<</step/>>
<pre>
$ rm ~/athena
$ ln -s ~/athena_pkgs/athena_1.1.x ~/athena
</pre>
<</step>>


<<step>>
Go to work.
<</step/>>
<pre>
$ cd ~/athena
$ ...
</pre>
<</step>>

<</procedure>>


<<section proc.cm.baseline "Establishing a New Development Baseline">>


A new development baseline is established when active development is
complete for one one major version, and it is desired to allow
preliminary development to begin for the next major version, e.g.,
when finishing work on version 1.0 and commencing work on version 2.0.
This process often takes place over a period of some weeks; typical
steps are as follows.<p>

<<procedure>>

<<step>>
Create a Bugzilla product for the new version, e.g., "Athena 2.0".  Give
it the components specified in <<xref bug.component>>.
<</step>>

<<step>>
Move all "Enhancements" from "Athena 1.0" to "Athena 2.0".  They aren't
really bugs, and so don't need to be retained with "Athena 1.0".
This can greatly shrink the set of packages associated with the version
that's nearing completion, and makes it clearer what remains to be
done.<p>

These first two steps can often be done well in advance of the rest.
<</step>>

<<step>>
Do the final Athena 1.0 build, e.g., "<code>athena_1.0.33</code>", as
described in <<xref proc.cm.build>>.
<</step>>

<<step>>
Create a Athena 1.1 release branch, "<code>athena_1.1.x</code>", based on
the final Athena 1.0 build, as described in <<xref proc.cm.mk_relbranch>>.
All future work leading up to the delivery will be done on this branch. 
<</step>>

<<step>>
On the release branch, update <code>lib/projectlib/version.txt</code>,
e.g., to "1.1.x".
<</step>>

<<step>>
On the trunk, update <code>lib/projectlib/version.txt</code>,
e.g., to "2.0.x".
<</step>>

<<step>>
Create a new Bugzilla product for the release branch, e.g., "Athena 1.1".
<</step>>

<<step>>
Clone all bugs remaining in the "Athena 1.0" product to both the "Athena
1.1" and "Athena 2.0" products, to maintain a record of known bugs in
each branch.
<</step>>

<<step>>
At this point, development can proceed independently on Athena 1.1 and
Athena 2.0.  Note that any bugs found in Athena 1.1 should be cloned to
the "Athena 2.0" product in Bugzilla.
<</step>>

<</procedure>>


<<section proc.cm.release "Releasing the Software">>

Releasing the software involves creating a release branch, as
described in <<xref proc.cm.mk_relbranch>>, updating all documentation as
required, and doing an official build on the release branch.  The
resulting tarball is the release installation set.<p>
 
The installation tarball is usually distributed on a CD with the <i>Athena
Operator's Guide</i>.<p>


<hr>
<address><a href="http://eis.jpl.nasa.gov/~will/">Will Duquette</a> / <a href="mailto:William.H.Duquette@jpl.nasa.gov">
William.H.Duquette@jpl.nasa.gov</a></address>

</body> </html>


