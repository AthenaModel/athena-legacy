<<manpage {gofer(i)} "Gopher Type Interface">>

<<section SYNOPSIS>>

<<itemlist>>

<<section DESCRIPTION>>

A gofer type is a collection of recipes for computing a particular kind of
output value, so called because it goes and gets the output value on
demand.  A value of a gofer type specifies a particular recipe and the
ingredients it needs to compute the desired output.

For example, one might define a gofer type called 
<code>::gofer_civgroups</code>, whose values evaluate to lists of civilian
groups.  Such a type might support a large number of recipes:<p>

<ul>
    <li> All non-empty civilian groups
    <li> All civilian groups resident in neighborhood <i>n</i>
    <li> All civilian groups with a mood greater than <i>x</i>
    <li> All civilian groups that support actor <i>a</i>
</ul>

The first recipe has no ingredients, i.e., no additional parameters required
to compute the desired list of groups.

In the second recipe, the ingredient is the identity of the neighborhood,
<i>n</i>, and so on for the third and fourth.

Gofer types can be used as parameter types for orders, and especially for
tactics.  Consider a tactic that requires a list of civilian groups: by
using a gofer type, the analyst can select a dynamic set of groups, a set that 
might change as the simulation runs, simply by specifying the rule used to 
identify the groups in the set.  For this reason, we refer to a gofer type's
recipes as <i>gofer rules</i>, or just <i>rules</i> for short.<p>

A gofer type is implemented as a Tcl ensemble command, usually as an
instance of <<xref gofer(n)>>.<p>

<<subsection Operations>>

Gofer types support the following operations on their values.<p>

First, a value can be validated.  Validation finds any errors, and if valid
puts the value in canonical form.  In other words, a gofer type is a validation
type like all of the others in Athena and Mars.<p>

Second, a narrative can be computed from a value.  The narrative is a 
human-readable string, usually a noun phrase, that describes the output and 
how it will be computed, 
e.g., "all non-empty civilian groups resident in N1".<p>

Third, a value can be evaluated, resulting in an output value of the desired
type.<p>

Suppose a tactic has a parameter of a gofer type.  The tactic will validate
parameter values using the gofer type, as it does for any other parameter.  
It will include the parameter's narrative in its own narrative, e.g.,<p>

<blockquote>
Actor JOE funds $25M of ENI for <b>all non-empty civilian groups in N1</b><p>
</blockquote>

Finally, when the tactic executes it will evaluate the value, and make use
of the output.<p>

<<subsection "Gofer Dictionaries">>

Every gofer type value is a Tcl dictionary with at least one key, <b>_rule</b>, whose value is the name of the rule to apply.  Other keys may be added 
depending on the rule.  For example, values for the four rules given above 
might be represented like this:<p>

<pre>
    _rule all
    _rule by_nbhood n N1
    _rule by_moodgt x 30.0
    _rule supports  a JOE 
</pre>

These values are called <i>gofer dictionaries</i>, or <i>gdicts</i>.  In 
canonical form,<p>

<ul>
    <li> The <b>_rule</b> key will be the first key.
    <li> The rule name will be in lower case.
    <li> The remaining keys will be only those related to the selected rule.
    <li> The values of those keys will be in canonical form for their types.
</ul><p>

<<subsection "Required Rules">>

The set of rules will usually vary significantly from one gofer type to
another.  However, every gofer type must implement at least the
<b>by_value</b> rule, which simply returns its input <b>raw_value</b>.

After all, the analyst will sometimes want to just specify the value to
use, rather than telling the application how to compute it.  The 
<b>by_value</b> rule is how the gofer type supports this.<p>

Thus,<p>

<pre>
    _rule by_value raw_value {A B C} 
</pre>

will evaluate (if valid) to "A B C".<p> 

<<subsection "Raw Value Conversion">>

Gofer types are a new construct, and there are many existing orders and
tactics that ought to use them.  For example, the FUNDENI tactic has a 
<b>glist</b> parameter whose value is a list of civilian groups.  At present,
the user must always select an explicit list; and there are existing Athena
scenarios that use this tactic.  How do we transition the tactic to use
a gofer type without breaking existing scenarios?<p>

The answer lies in the canonical form of a gofer type value.  A raw value
will never begin with the token "<b>_rule</b>"; a gofer value always will.
The application can check for the presence of "<b>_rule</b>"; if absent, it
can assume that the value is a raw value and convert it to a gofer value
using the <b>by_value</b> rule.  (This is another reason why all types
must support the <b>by_value</b> rule.)<p>

<<subsection "Definition">>

Any object that adheres to this interface is <i>de facto</i> a gofer type.
Most gofer types, however, are instances of <<xref gofer(n)>>, and are
defined as follows:<p>

<ul>
    <li> First, the developer identifies the rules that will make up the type,
         and defines a <<xref gofer_rule(i)>> object for each of them.  This
         object knows how to validate and evaluate and compute a narrative
         for a specific rule, and defines the rule's parameters.<p>

         The rule objects are typically defined within the namespace of the
         type to which they are principly related.<p>

    <li> Next, the developer creates an instance of <<xref gofer(n)>>,
         mapping the type's rule names to rule objects and providing a
         <<xref dynaform(n)>> form specification to allow the type's values
         to be edited (see <<xref "EDITING">>).
</ul>

Additional rules can be added to the type as needed.<p>

<<section "EDITING">>

Gofer type values can be edited by using the <b>gofer</b> field type
in <<xref dynaform(n)>> scripts, or by using the <<xref goferfield(n)>>
widget directly in other contexts.<p>

Because gofer type values can be arbitrarily complex, each type must define
a <<xref dynaform(n)>> script that will be used to display and edit its values
in an appropriate way.  The form will be used by itself in a 
<<xref dynabox(n)>> popup, rather than being embedded within a larger form,
so it can use all of the space it needs to.<p>

The dynaform script should include prose that makes it clear what the user is
selecting.  The first data field in the form should always be a selector
called <b>_rule</b>; each rule supported by the type should have a case 
within the selector.  For example:<p>

<pre>
    rc "" -width 3in -span 3
    label {
        Enter a rule for selecting a set of civilian groups.
    }

    rc "" -for _rule
    selector _rule {
        case by_value "By name" {
            cc "  " -for raw_value
            enumlonglist raw_value -dictcmd {::civgroup namedict} \
                -width 30 -height 10 
        }
        case by_nbhood "Resident in" {
            cc "  " -for n
            enumlong n -showkeys yes -dictcmd {::nbhood namedict}
        }
    }
</pre>

Note that the form is free to use whatever text strings it likes to present
the rules to the user; thus, the <b>by_value</b> rule is presented as 
"By name", which is friendlier for this particular type.<p>

<<section "SUBCOMMANDS">>

Each <<xref gofer(i)>> ensemble must implement at least the following
subcommands, some of which are provided automatically by 
<<xref gofer(n)>>.<p>

<<deflist subcommands>>

<<defitem dynaform {dynaform}>>

This subcommand is implemented automatically by <<xref gofer(n)>>.
It returns the name of the type's <<xref dynaform(n)>>.<p>

<<defitem eval {eval <i>gdict</i>}>>

Evaluates the <i>gdict</i> to produce the desired output value, e.g., 
a particular list of civilian groups.  Depending on the gofer type, the
chosen rule, and the current circumstances, the result might be the empty
string; users of gofer types must take this into account.<p>
    
<<defitem narrative {narrative <i>gdict</i> ?-brief?}>>

Returns a human-readable narrative description of the chosen rule.
The narrative should include all of the relevant parameters, and should
be stated as a noun phrase so that it can be included in other strings
(e.g., in <<xref tactic(i)>> narratives).<p>

If the <b>-brief</b> option is included, then the length of the narrative
should be constrained in cases where the full narrative could be 
arbitrarily long.  In the example shown above, the first rule is
<b>by_value</b>; its <b>raw_value</b> is
an arbitrarily long list of group names.  It can be constrained by 
trimming the list to some fixed number, and putting an ellipsis on the
end.<p>

Typical brief narratives can be up to about 120 characters.<p>

<<defitem validate {validate <i>gdict</i>}>>

Validates the <i>gdict</i>, returning it in canonical form, and throwing
<b>INVALID</b> on any error.  See <<xref "Gofer Dictionaries">> for
a description of the canonical form.<p>

<</deflist subcommands>>

<<section "RULE CONSTRUCTORS">>

The author of a gofer type might elect to define additional subcommands called
"rule constructors".  These create a valid <i>gdict</i> for a given rule.
The example shown above has a <b>by_nbhood</b> rule with an <b>n</b> parameter.
This type could define a <b>by_nbhood</b> constructor like this:<p>

<pre>
    set gdict [gofer_civgroups by_nbhood $n]
</pre>

This is more concise, more maintainable, and potentially much less fragile 
than the alternative:

<pre>
    set gdict [dict create _rule by_nbhood n $n]
</pre>

<<section AUTHOR>>

Will Duquette<p>

<<section HISTORY>>

Original interface.

<</manpage>>



